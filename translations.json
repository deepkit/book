{
    "german": {
        "Introduction": "Einführung",
        "TypeScript is JavaScript that scales. A language designed to implement complex use cases. It allows JavaScript to be written with types that are checked and removed at compile time. This resulting type safety allows for easier writing and maintenance of complex applications. This, among other things, is what has made TypeScript so popular: It allows finding bugs in code, especially on a large scale, much faster and easier than would be possible with pure JavaScript - and it works with JavaScript, not against it.": "TypeScript ist JavaScript, das skalierbar ist. Eine Sprache, die für die Implementierung komplexer Anwendungsfälle entwickelt wurde. Sie ermöglicht es, JavaScript mit Typen zu schreiben, die zur Kompilierzeit geprüft und entfernt werden. Die daraus resultierende Typsicherheit erleichtert das Schreiben und die Wartung komplexer Anwendungen. Dies ist es auch, was TypeScript so populär gemacht hat: Es ermöglicht das Auffinden von Fehlern im Code, insbesondere in großem Umfang, viel schneller und einfacher, als es mit reinem JavaScript möglich wäre - und es arbeitet mit JavaScript, nicht dagegen.",
        "Deepkit is TypeScript that scales. A framework written in TypeScript for TypeScript, designed to develop very complex software in TypeScript. It brings many design patterns known from the Enterprise to TypeScript and introduces completely new features that are only possible with TypeScript’s new type system to increase development speed especially in teams. Small applications can also benefit from this new approach, as Deepkit comes with many libraries for very common use cases that can be used individually or in combination. The framework itself is designed to be as agile as possible and as complex as necessary, not only to get initial results quickly, but also to maintain development speed in the long term.": "Deepkit ist TypeScript, das skaliert. Ein Framework, das in TypeScript für TypeScript geschrieben wurde, um sehr komplexe Software in TypeScript zu entwickeln. Es bringt viele aus dem Enterprise-Bereich bekannte Entwurfsmuster nach TypeScript und führt völlig neue Funktionen ein, die nur mit dem neuen TypeScript-Typsystem möglich sind, um die Entwicklungsgeschwindigkeit vor allem in Teams zu erhöhen. Auch kleine Anwendungen können von diesem neuen Ansatz profitieren, da Deepkit viele Bibliotheken für sehr häufige Anwendungsfälle enthält, die einzeln oder in Kombination verwendet werden können. Das Framework selbst ist darauf ausgelegt, so agil wie möglich und so komplex wie nötig zu sein, nicht nur um schnell erste Ergebnisse zu erzielen, sondern auch um die Entwicklungsgeschwindigkeit langfristig zu erhalten.",
        "JavaScript is now the largest developer community in the world and provides the developer with a correspondingly large selection of many libraries and tools to cover the needs of a project. However, it is not always easy to find the right library. Often the philosophies, API and code qualities of these differ so much that a lot of sticky code and additional abstractions have to be introduced by the developer in order for these libraries to work properly with each other at all. The provision of core functions, which are needed by virtually every project, in nicely abstracted libraries brought together in a framework by a manufacturer or a community has proven itself again and again in the last decades: Java Spring, PHP Symfony/Laravel, and C++ QT are just a few very well-known and successful examples. These frameworks offer to the developer often far common and decades proven concepts, which are converted into libraries or components, in order to be able to be used so comfortably among themselves harmonizing demand-fairly. The offered functionalities and design patterns are thereby not cubed, but based on sometimes over decades old concepts, which worked satisfactorily by the fight in the competition with alternative ideas.": "JavaScript ist heute die größte Entwicklergemeinschaft der Welt und bietet dem Entwickler eine entsprechend große Auswahl an vielen Bibliotheken und Werkzeugen, um die Bedürfnisse eines Projekts abzudecken. Allerdings ist es nicht immer einfach, die richtige Bibliothek zu finden. Oft unterscheiden sich deren Philosophien, API und Code-Qualitäten so sehr, dass der Entwickler eine Menge klebrigen Code und zusätzliche Abstraktionen einführen muss, damit diese Bibliotheken überhaupt richtig miteinander arbeiten. Die Bereitstellung von Kernfunktionen, die praktisch jedes Projekt benötigt, in schön abstrahierten Bibliotheken, die von einem Hersteller oder einer Community in einem Framework zusammengeführt werden, hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele. Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehntelang bewährte Konzepte, die in Bibliotheken oder Komponenten umgesetzt werden, um so bequem untereinander bedarfsgerecht eingesetzt werden zu können. Die angebotenen Funktionalitäten und Entwurfsmuster sind dabei nicht gewürfelt, sondern basieren auf teilweise über Jahrzehnte alten Konzepten, die sich im Kampf mit alternativen Ideen bewährt haben.",
        "JavaScript has seen massive progress over the years, so that more and more design patterns from the enterprise environment can now be applied. Design patterns that can be found in more and more libraries, frameworks, and tools. However, JavaScript and also TypeScript have the problem that in order to efficiently apply many proven enterprise patterns, decisive functions are missing in the language itself. This does not mean that these design patterns cannot be applied in general, but that they are less efficient than in other current languages.": "JavaScript hat in den letzten Jahren enorme Fortschritte gemacht, so dass immer mehr Design Patterns aus dem Unternehmensumfeld angewendet werden können. Entwurfsmuster, die in immer mehr Bibliotheken, Frameworks und Tools zu finden sind. Allerdings haben JavaScript und auch TypeScript das Problem, dass für die effiziente Anwendung vieler bewährter Enterprise Patterns entscheidende Funktionen in der Sprache selbst fehlen. Das bedeutet nicht, dass diese Entwurfsmuster nicht generell angewendet werden können, sondern dass sie weniger effizient sind als in anderen gängigen Sprachen.",
        "TypeScript completely removes its type information at compile time, once TypeScript is converted to JavaScript, so no information about it exists in the generated JavaScript or at runtime. It is undeniable that types are very valuable during development and when checking the correctness of the program. However, types also have tremendous value at runtime. This value is reflected where at runtime data is transformed (converted/serialized), data is validated, meta-information is added to objects, or interface information is required. In these and many other use cases, type information can be very useful at runtime because it provides libraries with the information needed to efficiently provide functionality. Currently, many of these use cases instead use alternatives that incompletely mimic TypeScript’s type system, forcing the developer to write types in a new way that has nothing to do with TypeScript’s syntax. The result is that TypeScript’s powerful type system can no longer show its strength here, and less ergonomic and less efficient ways of working must be used instead.": "TypeScript entfernt seine Typinformationen bei der Kompilierung vollständig, sobald TypeScript in JavaScript konvertiert ist, so dass im generierten JavaScript oder zur Laufzeit keine Informationen darüber vorhanden sind. Es ist unbestreitbar, dass Typen während der Entwicklung und bei der Überprüfung der Korrektheit des Programms sehr wertvoll sind. Aber auch zur Laufzeit haben Typen einen enormen Wert. Dieser Wert zeigt sich dort, wo zur Laufzeit Daten transformiert (konvertiert/serialisiert), Daten validiert, Meta-Informationen zu Objekten hinzugefügt oder Schnittstelleninformationen benötigt werden. In diesen und vielen anderen Anwendungsfällen können Typinformationen zur Laufzeit sehr nützlich sein, da sie Bibliotheken mit den Informationen versorgen, die sie zur effizienten Bereitstellung von Funktionen benötigen. Derzeit verwenden viele dieser Anwendungsfälle stattdessen Alternativen, die das TypeScript-Typsystem unvollständig nachahmen und den Entwickler dazu zwingen, Typen auf eine neue Art und Weise zu schreiben, die nichts mit der Syntax von TypeScript zu tun hat. Das Ergebnis ist, dass TypeScripts mächtiges Typsystem hier nicht mehr seine Stärke ausspielen kann und stattdessen weniger ergonomische und weniger effiziente Arbeitsweisen verwendet werden müssen.",
        "Deepkit Framework": "Deepkit-Rahmenwerk",
        "Deepkit has developed a type compiler that leaves type information in place, allowing dynamic types to be computed at runtime and existing type information to be read at runtime. With this paradigm shift, completely new ways of working are possible, providing the required information for the aforementioned use cases, radically simplifying the development of complex software, and giving the code more expressiveness. It is thus possible for the first time to use the full power and expressiveness of TypeScript at runtime as well.": "Deepkit hat einen Typ-Compiler entwickelt, der Typinformationen an Ort und Stelle belässt, so dass dynamische Typen zur Laufzeit berechnet und vorhandene Typinformationen zur Laufzeit gelesen werden können. Mit diesem Paradigmenwechsel werden völlig neue Arbeitsweisen möglich, die die benötigten Informationen für die oben genannten Anwendungsfälle bereitstellen, die Entwicklung komplexer Software radikal vereinfachen und dem Code mehr Ausdruckskraft verleihen. Damit ist es erstmals möglich, die volle Leistungsfähigkeit und Ausdruckskraft von TypeScript auch zur Laufzeit zu nutzen.",
        "Based on this paradigm shift, Deepkit has developed a whole set of libraries for use cases that can be found in just about any program: Validation, Serialization, Database Abstraction, CLI parser, HTTP Router, RPC Framework, Logger, Template System, Event System and many more. The fundamental difference from other libraries is that type information is at the core of the functionality and as much TypeScript as possible should be reused at runtime, so less boilerplate needs to be written by the developer and even complex programs can be seen at a glance what they are doing. Finally, one of the key features of TypeScript is to give expression to even complex code, and Deepkit brings these expressiveness benefits to the runtime in the form of a powerful framework to now better scale application architecture with appropriate enterprise patterns.": "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Bibliotheken für Anwendungsfälle entwickelt, die in nahezu jedem Programm zu finden sind: Validierung, Serialisierung, Datenbankabstraktion, CLI-Parser, HTTP-Router, RPC-Framework, Logger, Template-System, Event-System und viele mehr. Der grundlegende Unterschied zu anderen Bibliotheken besteht darin, dass Typinformationen den Kern der Funktionalität ausmachen und so viel TypeScript wie möglich zur Laufzeit wiederverwendet werden sollte, so dass der Entwickler weniger Boilerplate schreiben muss und selbst komplexe Programme auf einen Blick erkennen können, was sie gerade tun. Schließlich besteht eine der wichtigsten Eigenschaften von TypeScript darin, selbst komplexem Code Ausdruckskraft zu verleihen, und Deepkit bringt diese Vorteile der Ausdruckskraft zur Laufzeit in Form eines leistungsstarken Frameworks, um die Anwendungsarchitektur mit geeigneten Unternehmensmustern besser skalieren zu können.",
        "Deepkit consists of two large areas: One is the Deepkit Libraries and the Deepkit Framework. The Deepkit Libraries are a whole family of standalone TypeScript libraries (NPM packages) that are good at one topic and are optimized, well tested, and designed to complement each other optimally. A project can use individual Deepkit libraries, or the entire Deepkit framework, which brings together all the capabilities of the libraries and complements them with additional tools such as the debugger. All together, it allows the developer to create complex, fast, and production-ready applications. Deepkit supports a wide range of use cases. From simple command-line tools (CLI programs) to web applications and micro-services to desktop or mobile applications. The code is designed to run in any known JavaScript engine (browser as well as NodeJS) and integrates beautifully with other frameworks such as Angular, React, and Vue. The claim behind Deepkit Framework is to apply clean code, SOLID principles, and enterprise design patterns to not only offer correspondingly high code quality, but to allow the user to apply them as well. Deepkit also tries to promote these same principles in its documentation and examples, but does not force the developer to follow them themselves.": "Deepkit besteht aus zwei großen Bereichen: Zum einen aus den Deepkit Libraries und dem Deepkit Framework. Bei den Deepkit-Bibliotheken handelt es sich um eine ganze Familie eigenständiger TypeScript-Bibliotheken (NPM-Pakete), die ein Thema gut beherrschen und die optimiert, gut getestet und so konzipiert sind, dass sie sich gegenseitig optimal ergänzen. Ein Projekt kann einzelne Deepkit-Bibliotheken oder das gesamte Deepkit-Framework verwenden, das alle Fähigkeiten der Bibliotheken zusammenfasst und durch zusätzliche Tools wie den Debugger ergänzt. Alles zusammen ermöglicht es dem Entwickler, komplexe, schnelle und produktionsreife Anwendungen zu erstellen. Deepkit unterstützt eine breite Palette von Anwendungsfällen. Von einfachen Befehlszeilentools (CLI-Programmen) über Webanwendungen und Microservices bis hin zu Desktop- oder mobilen Anwendungen. Der Code ist so konzipiert, dass er in jeder bekannten JavaScript-Engine (sowohl im Browser als auch in NodeJS) läuft und sich hervorragend in andere Frameworks wie Angular, React und Vue integrieren lässt. Der Anspruch hinter Deepkit Framework ist es, sauberen Code, SOLID-Prinzipien und Enterprise Design Patterns anzuwenden, um nicht nur eine entsprechend hohe Code-Qualität zu bieten, sondern auch dem Nutzer die Möglichkeit zu geben, diese anzuwenden. Deepkit versucht, diese Prinzipien auch in der Dokumentation und in den Beispielen zu fördern, zwingt den Entwickler aber nicht, sie selbst zu befolgen.",
        "High-Performance": "Leistungsstarke",
        "One of the most difficult problems in software development is to maintain a high development speed even after months or years, especially when the code and the team grow. There are many frameworks that promise to get you started quickly and allow you to cobble together more complex applications on your own in a very short time. However, these usually have the common problem that the development speed decreases drastically the older the project or the larger the team becomes. It is not uncommon that even after a few months and only a handful of developers, the development speed collapses to such an extent that it drops to 1% of the original speed. To counteract this phenomenon, it is necessary to apply established design patterns and use the right framework and libraries in advance. Enterprise design patterns have established themselves for the reason that they scale excellently even with larger applications and large teams. Correctly applied, they develop their capabilities especially when a project is to be developed over a longer period of time (several months to years).": "Eines der schwierigsten Probleme bei der Softwareentwicklung ist es, auch nach Monaten oder Jahren ein hohes Entwicklungstempo beizubehalten, insbesondere wenn der Code und das Team wachsen. Es gibt viele Frameworks, die einen schnellen Einstieg versprechen und es ermöglichen, komplexere Anwendungen in kürzester Zeit selbst zusammenzuschustern. Diese haben jedoch meist das Problem, dass die Entwicklungsgeschwindigkeit drastisch abnimmt, je älter das Projekt oder je größer das Team wird. Nicht selten bricht die Entwicklungsgeschwindigkeit schon nach wenigen Monaten und nur einer Handvoll Entwickler so stark ein, dass sie auf 1 % der ursprünglichen Geschwindigkeit sinkt. Um diesem Phänomen entgegenzuwirken, ist es notwendig, bereits im Vorfeld etablierte Entwurfsmuster anzuwenden und die richtigen Frameworks und Bibliotheken zu verwenden. Enterprise Design Patterns haben sich aus dem Grund etabliert, dass sie auch bei größeren Anwendungen und großen Teams hervorragend skalieren. Richtig angewandt, entfalten sie ihre Fähigkeiten vor allem dann, wenn ein Projekt über einen längeren Zeitraum (mehrere Monate bis Jahre) entwickelt werden soll.",
        "Design patterns have their advantages in theory, but in practice almost every pattern also has its disadvantages. These disadvantages vary depending on the language and framework, since the language and framework themselves determine how ergonomically a pattern can be applied. Just because a certain pattern can be used in a language, it does not mean that it automatically makes development better and faster. Some languages are better suited than others for applying certain patterns. With JavaScript or even TypeScript itself, various design patterns are often usable in the core, but there are limitations here that massively affect the user experience and thus speed. For example, Typescript decorators with all their idiosyncrasies may become necessary if a dependency injection framework specifies and is based on them. Deepkit’s runtime type system ensures that these design patterns can be applied in the most ergonomic way and with as little boilerplate as possible, unlocking their power to maintain high development speed not only initially, but also over the long term.": "Entwurfsmuster haben in der Theorie ihre Vorteile, aber in der Praxis hat fast jedes Muster auch seine Nachteile. Diese Nachteile variieren je nach Sprache und Framework, da die Sprache und das Framework selbst bestimmen, wie ergonomisch ein Muster angewendet werden kann. Nur weil ein bestimmtes Muster in einer Sprache verwendet werden kann, heißt das nicht, dass es automatisch die Entwicklung besser und schneller macht. Einige Sprachen sind für die Anwendung bestimmter Muster besser geeignet als andere. Bei JavaScript oder auch TypeScript selbst sind verschiedene Design Patterns oft im Kern verwendbar, aber es gibt hier Einschränkungen, die das Benutzererlebnis und damit die Geschwindigkeit massiv beeinträchtigen. So können z.B. Typescript-Dekoratoren mit all ihren Eigenheiten notwendig werden, wenn ein Dependency-Injection-Framework diese vorgibt und darauf aufbaut. Das Laufzeit-Typsystem von Deepkit stellt sicher, dass diese Entwurfsmuster auf die ergonomischste Art und Weise und mit so wenig Boilerplate wie möglich angewandt werden können, um nicht nur anfangs, sondern auch langfristig eine hohe Entwicklungsgeschwindigkeit zu gewährleisten.",
        "Isomorphic TypeScript": "Isomorphes TypeScript",
        "One of the biggest advantages of TypeScript is that complex code can be written better in many use cases. This includes frontend, backend, CLI tools, mobile and desktop apps, and much more. When a project spans these use cases and relies almost exclusively on TypeScript, it is called Isomorphic TypeScript. Using TypeScript in as much code as possible can massively increase development speed. So the following advantages are then suddenly available:": "Einer der größten Vorteile von TypeScript ist, dass komplexer Code in vielen Anwendungsfällen besser geschrieben werden kann. Dazu gehören Frontend, Backend, CLI-Tools, mobile und Desktop-Anwendungen und vieles mehr. Wenn ein Projekt diese Anwendungsfälle überspannt und fast ausschließlich auf TypeScript basiert, wird es als Isomorphic TypeScript bezeichnet. Die Verwendung von TypeScript in so viel Code wie möglich kann die Entwicklungsgeschwindigkeit massiv erhöhen. Die folgenden Vorteile sind dann plötzlich verfügbar:",
        "Code can be shared between departments (frontend, backend, microservice, etc).": "Der Code kann von verschiedenen Abteilungen gemeinsam genutzt werden (Frontend, Backend, Microservice usw.).",
        "Models, types and interfaces": "Modelle, Typen und Schnittstellen",
        "Validation": "Validierung",
        "Business logic": "Geschäftslogik",
        "A unified audit system of a single package manager.": "Ein einheitliches Auditsystem für einen einzigen Paketmanager.",
        "Reuse of known third-party libraries in all departments.": "Wiederverwendung bekannter Bibliotheken von Drittanbietern in allen Abteilungen.",
        "Knowledge sharing within teams.": "Wissensaustausch innerhalb von Teams.",
        "Recruitment is simplified to one group (and the biggest one: JavaScript developers).": "Die Rekrutierung wird auf eine Gruppe (und zwar die größte: JavaScript-Entwickler) vereinfacht.",
        "Deepkit framework and its runtime type system are designed to exploit these and more advantages of Isomorphic TypeScript to the utmost, so that its maximum powers are revealed.": "Das Deepkit-Framework und sein Laufzeit-Typsystem sind so konzipiert, dass sie diese und weitere Vorteile von Isomorphic TypeScript optimal ausnutzen, so dass ihre maximale Leistungsfähigkeit zum Vorschein kommt.",
        "Old approaches such as the dual stack (frontend and backend in different languages) can no longer keep up by far, since the context switch between the languages alone already costs an enormous amount of energy and time. All the other advantages that have already been explained even make it an unfair comparison. An isomorphic tech stack like TypeScript, properly applied, is many times faster in development time on a fundamental level than any combination of a dual stack for backend/frontend like Java/JavaScript, PHP/JavaScript, or even JavaScript/JavaScript. Since faster development speed also means less time needed for the same features, it also means that Isomorphic TypeScript saves cash. Besides all the advantages already presented, this is the killer argument to use Isomorphic TypeScript in all the next especially commercial projects.": "Alte Ansätze wie der Dual Stack (Frontend und Backend in verschiedenen Sprachen) können da bei weitem nicht mehr mithalten, da allein der Kontextwechsel zwischen den Sprachen schon enorm viel Energie und Zeit kostet. All die anderen Vorteile, die bereits erläutert wurden, machen den Vergleich sogar unfair. Ein isomorpher Tech-Stack wie TypeScript ist, richtig angewandt, auf fundamentaler Ebene um ein Vielfaches schneller in der Entwicklungszeit als jede Kombination aus einem dualen Stack für Backend/Frontend wie Java/JavaScript, PHP/JavaScript oder gar JavaScript/JavaScript. Da eine schnellere Entwicklungsgeschwindigkeit auch bedeutet, dass weniger Zeit für dieselben Funktionen benötigt wird, bedeutet dies auch, dass Isomorphic TypeScript bares Geld spart. Neben all den bereits vorgestellten Vorteilen ist dies das Hauptargument für den Einsatz von Isomorphic TypeScript in allen nächsten, insbesondere kommerziellen Projekten.",
        "Runtime Types": "Laufzeittypen",
        "Runtime type information in TypeScript unlocks new workflows and features that were previously unavailable or required workarounds. Modern development processes rely heavily on declaring types and schemas for tools like GraphQL, validators, ORMs, and encoders such as ProtoBuf. These tools may require developers to learn new languages specific to their use case, like ProtoBuf and GraphQL having their own declaration language, or validators using their own schema APIs or JSON-Schema.": "Laufzeit-Typinformationen in TypeScript erschließen neue Workflows und Funktionen, die bisher nicht verfügbar waren oder Umgehungen erforderten. Moderne Entwicklungsprozesse sind stark auf die Deklaration von Typen und Schemata für Tools wie GraphQL, Validatoren, ORMs und Encoder wie ProtoBuf angewiesen. Diese Tools können es erforderlich machen, dass Entwickler neue, für ihren Anwendungsfall spezifische Sprachen erlernen, wie z. B. ProtoBuf und GraphQL mit ihrer eigenen Deklarationssprache oder Validatoren, die ihre eigenen Schema-APIs oder JSON-Schema verwenden.",
        "TypeScript has become powerful enough to describe complex structures and even replace declaration formats like GraphQL, ProtoBuf, and JSON-Schema entirely. With a runtime type system, it's possible to cover the use cases of these tools without any code generators. The Deepkit library aims to provide runtime type information and make it easier to develop efficient and compatible solutions.": "TypeScript ist mittlerweile leistungsfähig genug, um komplexe Strukturen zu beschreiben und sogar Deklarationsformate wie GraphQL, ProtoBuf und JSON-Schema vollständig zu ersetzen. Mit einem Laufzeit-Typsystem ist es möglich, die Anwendungsfälle dieser Tools ohne Codegeneratoren abzudecken. Die Deepkit-Bibliothek zielt darauf ab, Laufzeittypinformationen bereitzustellen und die Entwicklung effizienter und kompatibler Lösungen zu erleichtern.",
        "Deepkit is built upon the ability to read type information at runtime, using as much TypeScript type information as possible for efficiency. The runtime type system allows reading and computing dynamic types, such as class properties, function parameters, and return types. Deepkit hooks into TypeScript's compilation process to ensure that all type information is embedded into the generated JavaScript, enabling developers to access type information programmatically.": "Deepkit basiert auf der Fähigkeit, Typinformationen zur Laufzeit zu lesen, wobei so viele TypeScript-Typinformationen wie möglich für die Effizienz verwendet werden. Das Laufzeit-Typsystem ermöglicht das Lesen und Berechnen dynamischer Typen, wie Klasseneigenschaften, Funktionsparameter und Rückgabetypen. Deepkit klinkt sich in den Kompilierungsprozess von TypeScript ein, um sicherzustellen, dass alle Typinformationen in das generierte JavaScript eingebettet werden, so dass Entwickler programmatisch auf Typinformationen zugreifen können.",
        "With Deepkit, developers can use their existing TypeScript types for various application possibilities, simplifying their development process and making their work more efficient.": "Mit Deepkit können Entwickler ihre vorhandenen TypeScript-Typen für verschiedene Anwendungsmöglichkeiten nutzen, was ihren Entwicklungsprozess vereinfacht und ihre Arbeit effizienter macht.",
        "Installation": "Installation",
        "To install Deepkit's runtime type system two packages are needed. The type compiler in `@deepkit/type-compiler` and the runtime in `@deepkit/type`. The type compiler can be installed in `package.json` _devDependencies_, because it is only needed at build time.": "Um das Laufzeitsystem von Deepkit zu installieren, werden zwei Pakete benötigt. Der Typ-Compiler in `@deepkit/type-compiler` und die Laufzeit in `@deepkit/type`. Der Type-Compiler kann in `package.json` _devDependencies_ installiert werden, da er nur zur Build-Zeit benötigt wird.",
        "Runtime type information is not generated by default. It must be set `\"reflection\": true` in the `tsconfig.json` file to enable it in all files in the same folder of this file or in all subfolders. If decorators are to be used, `\"experimentalDecorators\": true` must be enabled in `tsconfig.json`. This is not strictly necessary to work with `@deepkit/type`, but necessary for certain functions of other deepkit libraries and in `@deepkit/framework`.": "Laufzeittypinformationen werden standardmäßig nicht erzeugt. Es muss `\"reflection\": true` in der `tsconfig.json` Datei gesetzt werden, um es in allen Dateien im gleichen Ordner dieser Datei oder in allen Unterordnern zu aktivieren. Wenn Dekoratoren verwendet werden sollen, muss `\"experimentalDecorators\": true` in `tsconfig.json` aktiviert werden. Dies ist nicht unbedingt notwendig, um mit `@deepkit/type` zu arbeiten, aber notwendig für bestimmte Funktionen anderer Deepkit-Bibliotheken und in `@deepkit/framework`.",
        "_File: tsconfig.json_": "_Datei: tsconfig.json_",
        "Type compiler": "Typ-Compiler",
        "TypeScript itself does not allow to configure the type compiler via a `tsconfig.json`. It is necessary to either use the TypeScript compiler API directly or a build system like Webpack with _ts-loader_. To save this inconvenient way for Deepkit users, the Deepkit type compiler automatically installs itself in `node_modulestypescript` once `@deepkit/type-compiler` is installed (this is done via NPM install hooks).": "TypeScript selbst erlaubt es nicht, den Type-Compiler über eine `tsconfig.json` zu konfigurieren. Es ist notwendig, entweder die TypeScript-Compiler-API direkt oder ein Build-System wie Webpack mit _ts-loader_ zu verwenden. Um Deepkit-Nutzern diesen umständlichen Weg zu ersparen, installiert sich der Deepkit-Type-Compiler automatisch in `node_modulestypescript`, sobald `@deepkit/type-compiler` installiert ist (dies geschieht über NPM-Installationshaken).",
        "This makes it possible for all build tools that access the locally installed TypeScript (the one in `node_modulestypescript`) to automatically have the type compiler enabled. This makes _tsc_, Angular, webpack, _ts-node_, and some other tools automatically work with the deepkit type compiler.": "Dies macht es möglich, dass alle Build-Tools, die auf das lokal installierte TypeScript (das in `node_modulestypescript`) zugreifen, automatisch den Type-Compiler aktiviert haben. Dadurch arbeiten _tsc_, Angular, webpack, _ts-node_ und einige andere Tools automatisch mit dem Deepkit-Type-Compiler.",
        "If the type compiler could not be successfully installed automatically (for example because NPM install hooks are disabled), this can be done manually with the following command:": "Wenn der Type Compiler nicht automatisch installiert werden konnte (z. B. weil die NPM-Installationshaken deaktiviert sind), kann dies mit dem folgenden Befehl manuell durchgeführt werden:",
        "Note that `deepkit-type-install` must be run if the local typescript version has been updated (for example, if the typescript version in package.json has changed and `npm install` is run).": "Beachten Sie, dass `deepkit-type-install` ausgeführt werden muss, wenn die lokale Typescript-Version aktualisiert wurde (z.B. wenn die Typescript-Version in package.json geändert wurde und `npm install` ausgeführt wird).",
        "Webpack": "Webpack",
        "If you want to use the type compiler in a webpack build, you can do so with the `ts-loader` package (or any other typescript loader that supports transformer registration).": "Wenn Sie den Type Compiler in einem Webpack-Build verwenden möchten, können Sie dies mit dem Paket `ts-loader` tun (oder mit jedem anderen Typescript-Loader, der die Registrierung von Transformern unterstützt).",
        "_File: webpack.config.js_": "_Datei: webpack.config.js_",
        "Typen-Decorators": "Typen-Dekoratoren",
        "Type decorators are normal TypeScript types that contain meta-information to change the behavior of various functions at runtime. Deepkit already provides some type decorators that cover some use cases. For example, a class property can be marked as primary key, reference, or index. The database library can use this information at runtime to create the correct SQL queries without prior code generation.": "Typdekoratoren sind normale TypeScript-Typen, die Meta-Informationen enthalten, um das Verhalten verschiedener Funktionen zur Laufzeit zu ändern. Deepkit bietet bereits einige Typdekoratoren, die einige Anwendungsfälle abdecken. Zum Beispiel kann eine Klasseneigenschaft als Primärschlüssel, Referenz oder Index markiert werden. Die Datenbankbibliothek kann diese Informationen zur Laufzeit verwenden, um die richtigen SQL-Abfragen ohne vorherige Codegenerierung zu erstellen.",
        "Validator constraints such as `MaxLength`, `Maximum`, or `Positive` can also be added to any type. It is also possible to tell the serializer how to serialize or deserialize a particular value. In addition, it is possible to create completely custom type decorators and read them at runtime, in order to use the type system at runtime in a very individual way.": "Validator-Bedingungen wie \"MaxLength\", \"Maximum\" oder \"Positiv\" können ebenfalls zu jedem Typ hinzugefügt werden. Es ist auch möglich, dem Serialisierer mitzuteilen, wie er einen bestimmten Wert serialisieren oder deserialisieren soll. Darüber hinaus ist es möglich, vollständig benutzerdefinierte Typdekoratoren zu erstellen und diese zur Laufzeit auszulesen, um das Typsystem zur Laufzeit auf sehr individuelle Weise zu nutzen.",
        "Deepkit comes with a whole set of type decorators, all of which can be used directly from `@deepkit/type`. They are designed not to come from multiple libraries, so as not to tie code directly to a particular library such as Deepkit RPC or Deepkit Database. This allows easier reuse of types, even in the frontend, although database type decorators are used for example.": "Deepkit verfügt über eine ganze Reihe von Typdekoratoren, die alle direkt aus `@deepkit/type` verwendet werden können. Sie sind so konzipiert, dass sie nicht aus mehreren Bibliotheken stammen, um den Code nicht direkt an eine bestimmte Bibliothek wie Deepkit RPC oder Deepkit Database zu binden. Dies ermöglicht eine einfachere Wiederverwendung von Typen, auch im Frontend, obwohl zum Beispiel Datenbanktypdekoratoren verwendet werden.",
        "Following is a list of existing type decorators. The validator and serializer of `@deepkit/type` and `@deepkit/bson` and Deepkit Database of `@deepkit/orm` used this information differently. See the corresponding chapters to learn more about this.": "Es folgt eine Liste der vorhandenen Typdekoratoren. Der Validator und Serialisierer von `@deepkit/type` und `@deepkit/bson` sowie die Deepkit-Datenbank von `@deepkit/orm` verwenden diese Informationen anders. Siehe die entsprechenden Kapitel, um mehr darüber zu erfahren.",
        "Integer/Float": "Ganzzahl/Fließkomma",
        "Integer and floats are defined as a base as `number` and has several sub-variants:": "Integer und Floats sind als Basis als `Number` definiert und haben mehrere Untervarianten:",
        "Here the `id` of the user is a number at runtime, but is interpreted as an integer in the validation and serialization.": "Hier ist die \"ID\" des Benutzers zur Laufzeit eine Zahl, wird aber bei der Validierung und Serialisierung als Ganzzahl interpretiert.",
        "This means that here, for example, no floats may be used in validation and the serializer automatically converts floats into integers.": "Das bedeutet, dass hier z.B. keine Fließkommazahlen in der Validierung verwendet werden dürfen und der Serialisierer automatisch Fließkommazahlen in Ganzzahlen umwandelt.",
        "The subtypes can be used in the same way and are useful if a specific range of numbers is to be allowed.": "Die Subtypen können auf die gleiche Weise verwendet werden und sind nützlich, wenn ein bestimmter Zahlenbereich zugelassen werden soll.",
        "Float": "Schwimmer",
        "UUID": "UUID",
        "UUID v4 is usually stored as a binary in the database and as a string in JSON.": "UUID v4 wird in der Regel als Binärwert in der Datenbank und als String in JSON gespeichert.",
        "MongoID": "MongoID",
        "Marks this field as ObjectId for MongoDB. Resolves as a string. Is stored in the MongoDB as binary.": "Markiert dieses Feld als ObjectId für MongoDB. Wird als String aufgelöst. Wird in der MongoDB als Binärdatei gespeichert.",
        "Bigint": "Bigint",
        "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save since bigint in JavaScript has an unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the types `BinaryBigInt` and `SignedBinaryBigInt` are available.": "Standardmäßig wird der normale bigint-Typ als Zahl in JSON (und long in BSON) serialisiert. Dies schränkt jedoch die Speichermöglichkeiten ein, da bigint in JavaScript eine unbegrenzte potenzielle Größe hat, während numbers in JavaScript und long in BSON begrenzt sind. Um diese Einschränkung zu umgehen, gibt es die Typen `BinaryBigInt` und `SignedBinaryBigInt`.",
        "`BinaryBigInt` is the same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (`abs(x)`).": "BinaryBigInt\" ist dasselbe wie \"bigint\", wird aber in Datenbanken zu einem vorzeichenlosen Binärwert mit unbegrenzter Größe (anstelle von 8 Byte in den meisten Datenbanken) und in JSON zu einem String serialisiert. Negative Werte werden in positive umgewandelt (`abs(x)`).",
        "Deepkit ORM stores BinaryBigInt as a binary field.": "Deepkit ORM speichert BinaryBigInt als binäres Feld.",
        "`SignedBinaryBigInt` is the same as `BinaryBigInt` but is able to store negative values as well. Deepkit ORM stores `SignedBinaryBigInt` as binary. The binary has an additional leading sign byte and is represented as an uint: 255 for negative, 0 for zero, or 1 for positive.": "`SignedBinaryBigInt` ist dasselbe wie `BinaryBigInt`, kann aber auch negative Werte speichern. Deepkit ORM speichert `SignedBinaryBigInt` als Binärwert. Der Binärwert hat ein zusätzliches vorangestelltes Vorzeichenbyte und wird als uint dargestellt: 255 für negativ, 0 für Null oder 1 für positiv.",
        "MapName": "Kartenname",
        "To change the name of a property in the serialization.": "So ändern Sie den Namen einer Eigenschaft in der Serialisierung.",
        "Group": "Gruppe",
        "Properties can be grouped together. For serialization you can for example exclude a group from serialization. See the chapter Serialization for more information.": "Eigenschaften können in Gruppen zusammengefasst werden. Bei der Serialisierung können Sie z.B. eine Gruppe von der Serialisierung ausschließen. Weitere Informationen finden Sie im Kapitel Serialisierung.",
        "Data": "Daten",
        "Each property can add additional meta-data that can be read via the Reflection API. See xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] for more information.": "Jede Eigenschaft kann zusätzliche Metadaten hinzufügen, die über die Reflection-API gelesen werden können. Weitere Informationen finden Sie unter xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection].",
        "Excluded": "Ausgeschlossen",
        "Each property can be excluded from the serialization process for a specific target.": "Jede Eigenschaft kann für ein bestimmtes Ziel vom Serialisierungsprozess ausgeschlossen werden.",
        "Embedded": "Eingebettet",
        "Marks the field as an embedded type.": "Markiert das Feld als eingebetteten Typ.",
        "It's possible to change the prefix (which is per default the property name).": "Es ist möglich, das Präfix zu ändern (das standardmäßig der Eigenschaftsname ist).",
        "Entity": "Entität",
        "To annotate interfaces with entity information. Only used in the database context.": "Zum Annotieren von Schnittstellen mit Entitätsinformationen. Wird nur im Datenbankkontext verwendet.",
        "InlineRuntimeType": "InlineRuntimeType",
        "TODO": "TODO",
        "ResetDecorator": "ResetDecorator",
        "Database": "Datenbank",
        "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "TODO: PrimaryKey, AutoIncrement, Referenz, BackReference, Index, Unique, DatabaseField.",
        "See xref:validation.adoc#validation-constraint-types[Validation Constraint Types].": "Siehe xref:validation.adoc#validation-constraint-types[Validation Constraint Types].",
        "Custom Type Decorators": "Benutzerdefinierte Typendekorateure",
        "aTypeDecoratorCanBeDefinedAsFollows": "aTypeDecoratorCanBeDefinedAsFollows",
        "By convention, a type decorator is defined to be an object literal with a single optional property `__meta` that has a tuple as its type. The first entry in this tuple is its unique name and all subsequent tuple entries are arbitrary options. This allows a type decorator to be equipped with additional options.": "Konventionell ist ein Typdekorator als ein Objektliteral mit einer einzigen optionalen Eigenschaft `__meta` definiert, die ein Tupel als Typ hat. Der erste Eintrag in diesem Tupel ist sein eindeutiger Name und alle folgenden Tupel-Einträge sind beliebige Optionen. Damit kann ein Typdekorator mit zusätzlichen Optionen ausgestattet werden.",
        "The type decorator is used with the intersection operator `&`. Any number of type decorators can be used on one type.": "Der Typdekorator wird mit dem Schnittpunktsoperator `&` verwendet. Eine beliebige Anzahl von Typdekoratoren kann für einen Typ verwendet werden.",
        "The type decorators can be read out via the type objects of `typeOf<T>()` and `metaAnnotation`:": "Die Typdekoratoren können über die Typobjekte von `typeOf<T>()` und `metaAnnotation` ausgelesen werden:",
        "The result in `annotation` is either an array with options if the type decorator `myAnnotation` was used or `undefined` if not. If the type decorator has additional options as seen in `AnnotationOption`, the passed values can be found in the array.": "Das Ergebnis in `Annotation` ist entweder ein Array mit Optionen, wenn der Typdekorator `myAnnotation` verwendet wurde oder `undefined` wenn nicht. Wenn der Typdekorator zusätzliche Optionen hat, wie in `AnnotationOption` zu sehen, können die übergebenen Werte in dem Array gefunden werden.",
        "Already supplied type decorators like `MapName`, `Group`, `Data`, etc have their own annotation object:": "Bereits mitgelieferte Typdekoratoren wie `MapName`, `Group`, `Data`, usw. haben ihr eigenes Anmerkungsobjekt:",
        "See xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] to learn more.": "Siehe xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] für weitere Informationen.",
        "External Classes": "Externe Klassen",
        "Since TypeScript does not include type information per default, imported types/classes from other packages (that did not use @deepkit/type-compiler) will not have type information available.": "Da TypeScript standardmäßig keine Typinformationen enthält, haben importierte Typen/Klassen aus anderen Paketen (die nicht @deepkit/type-compiler verwendet haben) keine Typinformationen zur Verfügung.",
        "To annotate types for an external class, use `annotateClass` and make sure this function is executed in the bootstrap phase of your application before the imported class is used somewhere else.": "Um Typen für eine externe Klasse zu annotieren, verwenden Sie `annotateClass` und stellen Sie sicher, dass diese Funktion in der Bootstrap-Phase Ihrer Anwendung ausgeführt wird, bevor die importierte Klasse irgendwo anders verwendet wird.",
        "`MyExternalClass` can now be used in serialization functions and in the reflection API.": "MyExternalClass\" kann jetzt in Serialisierungsfunktionen und in der Reflection-API verwendet werden.",
        "To following shows how to annotate generic classes:": "Im Folgenden wird gezeigt, wie man generische Klassen annotiert:",
        "Reflection": "Reflexion",
        "To work directly with the type information itself, there are two basic variants: Type objects and Reflection classes. Reflection classes are discussed below. The function `typeOf` returns type objects, which are very simple object literals. It always contains a `kind` which is a number and gets its meaning from the enum `ReflectionKind`. `ReflectionKind` is defined in the `@deepkit/type` package as follows:": "Um direkt mit den Typinformationen selbst zu arbeiten, gibt es zwei grundlegende Varianten: Typobjekte und Reflektionsklassen. Reflection-Klassen werden weiter unten behandelt. Die Funktion `typeOf` gibt Typobjekte zurück, die sehr einfache Objektliterale sind. Sie enthält immer ein `kind`, das eine Zahl ist und seine Bedeutung aus dem enum `ReflectionKind` erhält. ReflectionKind\" ist im Paket \"@deepkit/type\" wie folgt definiert:",
        "There are a number of possible type objects that can be returned. The simplest ones are `never`, `any`, `unknown`, `void, null,` and `undefined`, which are represented as follows:": "Es gibt eine Reihe von Objekten des Typs, die zurückgegeben werden können. Die einfachsten sind `nie`, `irgendwie`, `unbekannt`, `void, null` und `undefined`, die wie folgt dargestellt werden:",
        "For example, number 0 is the first entry of the `ReflectionKind` enum, in this case `never`, number 1 is the second entry, here `any`, and so on. Accordingly, primitive types like `string`, `number`, `boolean` are represented as follows:": "Zum Beispiel ist die Nummer 0 der erste Eintrag der Aufzählung `ReflectionKind`, in diesem Fall `never`, Nummer 1 ist der zweite Eintrag, hier `any`, und so weiter. Dementsprechend werden primitive Typen wie `string`, `number`, `boolean` wie folgt dargestellt:",
        "These rather simple types have no further information at the type object, because they were passed directly as type argument to `typeOf`. However, if types are passed via type aliases, additional information can be found at the type object.": "Diese eher einfachen Typen haben keine weiteren Informationen am Typobjekt, da sie direkt als Typargument an `typeOf` übergeben wurden. Wenn Typen jedoch über Typ-Aliase übergeben werden, können zusätzliche Informationen am Typ-Objekt gefunden werden.",
        "In this case, the name of the type alias 'Title' is also available. If a type alias is a generic, the types passed will also be available at the type object.": "In diesem Fall ist auch der Name des Typ-Alias \"Titel\" verfügbar. Handelt es sich bei einem Typ-Alias um einen generischen Typ, so sind die übergebenen Typen auch am Typobjekt verfügbar.",
        "If the type passed is the result of an index access operator, the container and the index type are present:": "Wenn der übergebene Typ das Ergebnis eines Indexzugriffsoperators ist, sind der Container und der Indextyp vorhanden:",
        "Interfaces and object literals are both output as Reflection.objectLiteral and contain the properties and methods in the `types` array.": "Schnittstellen und Objektliterale werden beide als Reflection.objectLiteral ausgegeben und enthalten die Eigenschaften und Methoden im Array `types`.",
        "Index signatures are also in the `types` array.": "Indexsignaturen befinden sich auch im Array `types`.",
        "Classes are similar to object literals and also have their properties and methods under a `types` array in addition to `classType` which is a reference to the class itself.": "Klassen sind ähnlich wie Objektliterale und haben auch ihre Eigenschaften und Methoden unter einem `types`-Array, zusätzlich zu `classType`, das ein Verweis auf die Klasse selbst ist.",
        "Note that the type of Reflection.propertySignature has changed to Reflection.property and Reflection.methodSignature has changed to Reflection.method. Since properties and methods on classes have additional attributes, this information can also be retrieved. The latter additionally include `visibility`, `abstract`, and `default`.": "Beachten Sie, dass sich der Typ von Reflection.propertySignature in Reflection.property und Reflection.methodSignature in Reflection.method geändert hat. Da Eigenschaften und Methoden von Klassen zusätzliche Attribute haben, können diese Informationen ebenfalls abgerufen werden. Zu den letzteren gehören zusätzlich \"Sichtbarkeit\", \"abstrakt\" und \"Standard\".",
        "Type objects of classes contain only the properties and methods of the class itself and not of super-classes. This is contrary to type objects of interfacesobject-literals, which have all property signatures and method signatures of all parents resolved into `types`. To resolve the property and methods of the super-classes, either ReflectionClass and its `ReflectionClass.getProperties()` (see following sections) or `resolveTypeMembers()` of `@deepkit/type` can be used.": "Typobjekte von Klassen enthalten nur die Eigenschaften und Methoden der Klasse selbst und nicht die von Oberklassen. Dies steht im Gegensatz zu Typobjekten von Interface-Objekt-Literalen, die alle Eigenschaftssignaturen und Methodensignaturen aller Eltern in `Typen` aufgelöst haben. Um die Eigenschaften und Methoden der Superklassen aufzulösen, können entweder ReflectionClass und dessen `ReflectionClass.getProperties()` (siehe folgende Abschnitte) oder `resolveTypeMembers()` von `@deepkit/type` verwendet werden.",
        "There is a whole plethora of type objects. For example for literal, template literals, promise, enum, union, array, tuple, and many more. To find out which ones all exist and what information is available, it is recommended to import `Type` from `@deepkit/type`. It is a `union` with all possible subtypes like TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, and many more. There you can find the exact structure.": "Es gibt eine ganze Fülle von Typobjekten. Zum Beispiel für Literal, Template-Literale, Promise, Enum, Union, Array, Tupel und viele mehr. Um herauszufinden, welche Typen es gibt und welche Informationen verfügbar sind, empfiehlt es sich, `Type` aus `@deepkit/type` zu importieren. Es ist eine `Union` mit allen möglichen Untertypen wie TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, und vielen mehr. Dort können Sie die genaue Struktur finden.",
        "Type Cache": "Typ Cache",
        "Type objects are cached for type aliases, functions, and classes as soon as no generic argument is passed. This means that a call to `typeOf<MyClass>()` always returns the same object.": "Typobjekte werden für Typ-Aliase, Funktionen und Klassen zwischengespeichert, sobald kein generisches Argument übergeben wird. Das bedeutet, dass ein Aufruf von `typeOf<MyClass>()` immer das gleiche Objekt zurückgibt.",
        "However, as soon as a generic type is used, new objects are always created, even if the type passed is always the same. This is because an infinite number of combinations are theoretically possible and such a cache would effectively be a memory leak.": "Sobald jedoch ein generischer Typ verwendet wird, werden immer neue Objekte erstellt, auch wenn der übergebene Typ immer derselbe ist. Dies liegt daran, dass theoretisch unendlich viele Kombinationen möglich sind und ein solcher Cache praktisch ein Speicherleck wäre.",
        "However, as soon as a type is instantiated multiple times in a recursive type, it is cached. However, the duration of the cache is limited only to the moment the type is computed and does not exist thereafter. Also, although the Type object is cached, a new reference is returned and is not the exact same object.": "Sobald ein Typ jedoch mehrfach in einem rekursiven Typ instanziiert wird, wird er zwischengespeichert. Die Dauer des Zwischenspeichers ist jedoch nur auf den Moment der Berechnung des Typs beschränkt und existiert danach nicht mehr. Auch wenn das Type-Objekt zwischengespeichert wird, wird eine neue Referenz zurückgegeben, die nicht genau dasselbe Objekt ist.",
        "`MyType<string>` is cached as long as `Object` is computed. The PropertySignature of `a` and `b` thus have the same `type` from the cache, but are not the same Type object.": "MyType<string>\" wird zwischengespeichert, solange \"Object\" berechnet wird. Die PropertySignature von `a` und `b` haben also denselben `Type` aus dem Cache, sind aber nicht dasselbe Type-Objekt.",
        "All non-root Type objects have a parent property, which usually points to the enclosing parent. This is valuable, for example, to find out whether a Type is part of a union or not.": "Alle Nicht-Wurzel-Type-Objekte haben eine Parent-Eigenschaft, die in der Regel auf den umschließenden Parent verweist. Dies ist z. B. nützlich, um herauszufinden, ob ein Typ Teil einer Vereinigung ist oder nicht.",
        "'Ref 1' points to the actual union type object.": "Ref 1' verweist auf das eigentliche Objekt vom Typ Union.",
        "For cached Type objects as exemplified above, the `parent` properties are not always the real parents. For example, for a class that is used multiple times, although immediate types in `types` (TypePropertySignature and TypeMethodSignature) point to the correct TypeClass, the `type` of these signature types point to the signature types of the TypeClass of the cached entry. This is important to know so as not to infinitely read the parent structure, but only the immediate parent. The fact that the parent does not have infinite precision is due to performance reasons.": "Bei zwischengespeicherten Type-Objekten, wie oben beschrieben, sind die \"Parent\"-Eigenschaften nicht immer die wirklichen Eltern. Zum Beispiel verweisen bei einer Klasse, die mehrfach verwendet wird, die unmittelbaren Typen in `types` (TypePropertySignature und TypeMethodSignature) zwar auf die richtige TypeClass, aber der `type` dieser Signaturtypen verweist auf die Signaturtypen der TypeClass des gecachten Eintrags. Dies ist wichtig zu wissen, um nicht endlos die übergeordnete Struktur zu lesen, sondern nur die unmittelbar übergeordnete. Die Tatsache, dass die übergeordnete Struktur nicht unendlich genau ist, hat mit der Leistung zu tun.",
        "JIT Cache": "JIT-Cache",
        "In the further course some functions and features are described, which are often based on the type objects. To implement some of them in a performant way, a JIT (just in time) cache per type object is needed. This can be provided via `getJitContainer(type)`. This function returns a simple object on which arbitrary data can be stored. As long as no reference to the object is held, it will be deleted automatically by the GC as soon as the Type object itself is also no longer referenced.": "Im weiteren Verlauf werden einige Funktionen und Features beschrieben, die oft auf den Typobjekten basieren. Um einige von ihnen performant zu implementieren, wird ein JIT (just in time) Cache pro Typobjekt benötigt. Dieser kann über `getJitContainer(type)` bereitgestellt werden. Diese Funktion gibt ein einfaches Objekt zurück, in dem beliebige Daten gespeichert werden können. Solange kein Verweis auf das Objekt gehalten wird, wird es automatisch von der GC gelöscht, sobald auch das Type-Objekt selbst nicht mehr referenziert wird.",
        "Reflection-Klassen": "Reflexions-Klassen",
        "In addition to the `typeOf<>()` function, there are various reflection classes that provide an OOP alternative to the Type objects. The reflection classes are only available for classes, InterfaceObject literals and functions and their direct sub-types (Properties, Methods, Parameters). All deeper types must be read again with the Type objects.": "Zusätzlich zur Funktion `typeOf<>()` gibt es verschiedene Reflection-Klassen, die eine OOP-Alternative zu den Type-Objekten darstellen. Die Reflection-Klassen sind nur für Klassen, InterfaceObject-Literale und Funktionen und deren direkte Untertypen (Properties, Methods, Parameters) verfügbar. Alle tieferen Typen müssen mit den Type-Objekten neu eingelesen werden.",
        "Receive type information": "Informationen zur Art des Empfangs",
        "In order to provide functions that operate on types, it can be useful to offer the user to pass a type manually. For example, in a validation function, it might be useful to provide the type to be requested as the first type argument and the data to be validated as the first function argument.": "Um Funktionen bereitzustellen, die mit Typen arbeiten, kann es sinnvoll sein, dem Benutzer die Möglichkeit zu geben, einen Typ manuell zu übergeben. In einer Validierungsfunktion könnte es beispielsweise sinnvoll sein, den anzufordernden Typ als erstes Typargument und die zu validierenden Daten als erstes Funktionsargument anzugeben.",
        "In order for this function to get the type `string`, it must tell this to the type compiler.": "Damit diese Funktion den Typ `String` erhält, muss sie dies dem Typ-Compiler mitteilen.",
        "`ReceiveType` with the reference to the first type arguments `T` signals the type compiler that each call to `validate` should put the type in second place (since `type` is declared in second place). To then read out the information at runtime, the `resolveReceiveType` function is used.": "`ReceiveType` mit dem Verweis auf das erste Typ-Argument `T` signalisiert dem Typ-Compiler, dass jeder Aufruf von `validate` den Typ an zweiter Stelle setzen soll (da `type` an zweiter Stelle deklariert ist). Um die Information dann zur Laufzeit auszulesen, wird die Funktion `resolveReceiveType` verwendet.",
        "It is useful to assign the result to the same variable to avoid creating a new one unnecessarily. In `type` now either a type object is stored or an error is thrown, if for example no type argument was passed, Deepkit's type compiler was not installed correctly, or the emitting of type information is not activated (see the section Installation above).": "Es ist sinnvoll, das Ergebnis der gleichen Variable zuzuweisen, um nicht unnötig eine neue Variable zu erzeugen. In `type` wird nun entweder ein Typobjekt gespeichert oder es wird ein Fehler ausgelöst, wenn z.B. kein Typargument übergeben wurde, der Typcompiler von Deepkit nicht korrekt installiert wurde oder die Ausgabe von Typinformationen nicht aktiviert ist (siehe den Abschnitt Installation oben).",
        "Bytecode": "Bytecode",
        "To learn in detail how Deepkit encodes and reads the type information in JavaScript, this chapter is intended. It explains how the types are actually converted into bytecode, emitted in JavaScript, and then interpreted at runtime.": "Um im Detail zu erfahren, wie Deepkit die Typinformationen in JavaScript kodiert und liest, ist dieses Kapitel gedacht. Es erklärt, wie die Typen tatsächlich in Bytecode umgewandelt, in JavaScript ausgegeben und dann zur Laufzeit interpretiert werden.",
        "Typen-Compiler": "Typen-Compiler",
        "The type compiler (in @deepkit/type-compiler) is responsible for reading the defined types in the TypeScript files and compiling them into a bytecode. This bytecode has everything needed to execute the types in runtime.": "Der Type-Compiler (in @deepkit/type-compiler) ist dafür verantwortlich, die definierten Typen in den TypeScript-Dateien zu lesen und sie in einen Bytecode zu kompilieren. Dieser Bytecode enthält alles, was zur Ausführung der Typen zur Laufzeit benötigt wird.",
        "At the time of this writing, the type compiler is a so-called TypeScript transformer. This transformer is a plugin for the TypeScript compiler itself and converts a TypeScript AST (Abstract Syntax Tree) into another TypeScript AST. Deepkit's type compiler reads the AST in this process, produces the corresponding bytecode, and inserts it into the AST.": "Zum Zeitpunkt der Erstellung dieses Artikels ist der Type-Compiler ein sogenannter TypeScript-Transformer. Dieser Transformator ist ein Plugin für den TypeScript-Compiler selbst und konvertiert einen TypeScript AST (Abstract Syntax Tree) in einen anderen TypeScript AST. Der Type-Compiler von Deepkit liest dabei den AST ein, erzeugt den entsprechenden Bytecode und fügt ihn in den AST ein.",
        "TypeScript itself does not allow you to configure this plugin aka transformer via a tsconfig.json. It is either necessary to use the TypeScript compiler API directly, or a build system like Webpack with `ts-loader`. To save this inconvenient way for Deepkit users, the Deepkit type compiler automatically installs itself in `node_modulestypescript` whenever `@deepkit/type-compiler` is installed. This makes it possible for all build tools that access the locally installed TypeScript (the one in `node_modulestypescript`) to automatically have the type compiler enabled. This makes tsc, Angular, webpack, ts-node, and some other tools work automatically with Deepkit's type compiler.": "TypeScript selbst erlaubt es nicht, dieses Plugin aka Transformer über eine tsconfig.json zu konfigurieren. Es ist entweder notwendig, die TypeScript-Compiler-API direkt zu verwenden, oder ein Build-System wie Webpack mit `ts-loader`. Um Deepkit-Nutzern diesen umständlichen Weg zu ersparen, installiert sich der Deepkit-Type-Compiler automatisch in `node_modulestypescript`, wenn `@deepkit/type-compiler` installiert wird. Dies ermöglicht es allen Build-Tools, die auf das lokal installierte TypeScript (das in `node_modulestypescript`) zugreifen, den Type-Compiler automatisch zu aktivieren. Dadurch arbeiten tsc, Angular, webpack, ts-node und einige andere Tools automatisch mit dem Type-Compiler von Deepkit.",
        "If automatic running of NPM install scripts is not enabled and thus the locally installed typescript is not modified, this process must be run manually if you want to. Alternatively, the types compiler can be used manually in a build tool such as webpack. See the Installation section above.": "Wenn die automatische Ausführung von NPM-Installationsskripten nicht aktiviert ist und somit das lokal installierte Typescript nicht geändert wird, muss dieser Prozess manuell ausgeführt werden, wenn Sie dies wünschen. Alternativ kann der Types-Compiler auch manuell in einem Build-Tool wie Webpack verwendet werden. Siehe den Abschnitt Installation oben.",
        "Bytecode Encoding": "Bytecode-Kodierung",
        "The bytecode is a sequence of commands for a virtual machine and is encoded in the JavaScript itself as an array of references and string (the actual bytecode).": "Der Bytecode ist eine Folge von Befehlen für eine virtuelle Maschine und wird im JavaScript selbst als Array von Referenzen und String (dem eigentlichen Bytecode) kodiert.",
        "The existing commands themselves are each one byte in size and can be found in `@deepkit/type-spec` as `ReflectionOp` enums. At the time of this writing, the command set is over 81 commands in size.": "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und können in `@deepkit/type-spec` als `ReflectionOp`-Enums gefunden werden. Zum Zeitpunkt der Erstellung dieses Artikels umfasst der Befehlssatz über 81 Befehle.",
        "A sequence of commands is encoded as a string to save memory. So a type `string[]` is conceptualized as a bytecode program `[string, array]` which has the bytes `[5, 37]` and encoded with the following algorithm:": "Eine Folge von Befehlen wird als String kodiert, um Speicherplatz zu sparen. So wird ein Typ \"String[]\" als ein Bytecode-Programm \"String, Array\" konzipiert, das die Bytes \"5, 37\" hat und mit dem folgenden Algorithmus kodiert wird:",
        "Accordingly, a 5 becomes an `&` character and a 37 becomes an `F` character. Together they become `&F` and are emitted in Javascript as `['&F']`.": "Dementsprechend wird eine 5 zu einem \"&\"-Zeichen und eine 37 zu einem \"F\"-Zeichen. Zusammen werden sie zu `&F` und werden in Javascript als `['&F']` ausgegeben.",
        "To prevent naming conflicts, each type is given a \"_Ω\" prefix. For each explicitly defined type that is exported or used by an exported type, a bytecode is emitted the JavaScript. Classes and functions also receive a bytecode directly as a property.": "Um Namenskonflikte zu vermeiden, wird jeder Typ mit einem \"_Ω\"-Präfix versehen. Für jeden explizit definierten Typ, der exportiert oder von einem exportierten Typ verwendet wird, wird ein Bytecode in JavaScript ausgegeben. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.",
        "Virtual Machine": "Virtuelle Maschine",
        "A virtual machine (in `@deepkit/type` the class Processor) at runtime is responsible for decoding and executing the encoded bytecode. It always returns a type object, see the Reflection section above.": "Eine virtuelle Maschine (in `@deepkit/type` die Klasse Processor) ist zur Laufzeit für die Dekodierung und Ausführung des kodierten Bytecodes verantwortlich. Sie gibt immer ein Typobjekt zurück, siehe den Abschnitt \"Reflexion\" weiter oben.",
        "Validation is the process of checking data for correctness. Correctness is given if the type is the correct one and additional defined constraints are fulfilled. Deepkit generally distinguishes between type validation and the validation of additional constraints.": "Bei der Validierung werden die Daten auf ihre Korrektheit geprüft. Die Korrektheit ist gegeben, wenn der Typ der richtige ist und zusätzlich definierte Constraints erfüllt sind. Deepkit unterscheidet generell zwischen der Typvalidierung und der Validierung von zusätzlichen Constraints.",
        "Validation is used whenever data comes from a source that is considered uncertain. Uncertain means that no guaranteed assumptions can be made about the types or contents of the data, and thus the data could have literally any value at runtime.": "Die Validierung wird immer dann eingesetzt, wenn die Daten aus einer Quelle stammen, die als unsicher gilt. Ungewiss bedeutet, dass keine garantierten Annahmen über die Typen oder den Inhalt der Daten gemacht werden können und die Daten daher zur Laufzeit buchstäblich jeden Wert haben können.",
        "For example, data from user input is generally not considered secure. Data from an HTTP request (query parameter, body), CLI arguments, or a read-in file must be validated. If a variable is declared as a number, there must also be a number in it, otherwise the program may crash or a security hole may occur.": "So werden beispielsweise Daten aus Benutzereingaben im Allgemeinen nicht als sicher angesehen. Daten aus einer HTTP-Anfrage (Abfrageparameter, Body), CLI-Argumente oder eine eingelesene Datei müssen validiert werden. Wenn eine Variable als Zahl deklariert ist, muss sie auch eine Zahl enthalten, sonst kann das Programm abstürzen oder eine Sicherheitslücke entstehen.",
        "In a controller of an HTTP route, for example, the top priority is to check every user input (query parameter, body). Especially in the TypeScript environment, it is important not to use type casts, as they are fundamentally insecure.": "In einem Controller einer HTTP-Route ist es zum Beispiel oberste Priorität, jede Benutzereingabe (Query-Parameter, Body) zu prüfen. Gerade im TypeScript-Umfeld ist es wichtig, keine Typecasts zu verwenden, da diese grundsätzlich unsicher sind.",
        "This often seen code is a bug that can lead to a program crash or a security vulnerability because a type cast `as number` was used that does not provide any security at runtime. The user can simply pass a string as `limit` and the program would then work with a string in `limit`, although the code is based on the fact that it must be a number. To maintain this security at runtime there are validators and type guards. Also, a serializer could be used to convert `limit` to a number. More information about this can be found in xref:serialization.adoc[Serialization].": "Dieser häufig anzutreffende Code ist ein Fehler, der zu einem Programmabsturz oder einer Sicherheitslücke führen kann, weil ein Typ-Cast `als Zahl` verwendet wurde, der zur Laufzeit keine Sicherheit bietet. Der Benutzer kann einfach eine Zeichenkette als `Limit` übergeben und das Programm würde dann mit einer Zeichenkette in `Limit` arbeiten, obwohl der Code auf der Tatsache basiert, dass es eine Zahl sein muss. Um diese Sicherheit zur Laufzeit aufrechtzuerhalten, gibt es Validatoren und Type Guards. Außerdem könnte ein Serialisierer verwendet werden, um `limit` in eine Zahl zu konvertieren. Weitere Informationen hierzu finden Sie in xref:serialization.adoc[Serialization].",
        "Validation is an essential part of any application and it is better to use it once too often than once too little. Deepkit provides many validation options and has a high-performance implementation, so in most cases there is no need to worry about execution time. Use as much validation as possible, in case of doubt once more, to be on the safe side.": "Validierung ist ein wesentlicher Bestandteil jeder Anwendung und es ist besser, sie einmal zu oft als einmal zu wenig zu verwenden. Deepkit bietet viele Validierungsoptionen und hat eine leistungsstarke Implementierung, so dass man sich in den meisten Fällen keine Sorgen um die Ausführungszeit machen muss. Verwenden Sie so viel Validierung wie möglich, um im Zweifelsfall auf der sicheren Seite zu sein.",
        "In doing so, many components of Deepkit such as the HTTP router, the RPC abstraction, but also the database abstraction itself have validation built in and is performed automatically, so in many cases it is not necessary to do this manually.": "Dabei haben viele Komponenten von Deepkit wie der HTTP-Router, die RPC-Abstraktion, aber auch die Datenbankabstraktion selbst eine Validierung eingebaut, die automatisch durchgeführt wird, so dass es in vielen Fällen nicht notwendig ist, dies manuell zu tun.",
        "In the corresponding chapters (xref:cli.adoc[CLI], xref:http.adoc[HTTP], xref:rpc.adoc[RPC], xref:database.adoc[Database]) it is explained in detail when a validation happens automatically. Make sure that you know where restrictions or types have to be defined and don't use `any` to make these validations work well and safely automatically. This can save you a lot of manual work to keep the code clean and safe.": "In den entsprechenden Kapiteln (xref:cli.adoc[CLI], xref:http.adoc[HTTP], xref:rpc.adoc[RPC], xref:database.adoc[Database]) wird ausführlich erklärt, wann eine Validierung automatisch erfolgt. Stellen Sie sicher, dass Sie wissen, wo Einschränkungen oder Typen definiert werden müssen und verwenden Sie nicht `any`, damit diese Validierungen gut und sicher automatisch funktionieren. Dies kann Ihnen eine Menge manueller Arbeit ersparen, um den Code sauber und sicher zu halten.",
        "Use": "Verwenden Sie",
        "The basic function of the validator is to check a value for its type. For example, whether a value is a string. This is not about what the string contains, but only about its type. There are many types in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, and many more. Due to Typescript’s powerful type system, a large variety of different types are available.": "Die Grundfunktion des Validators besteht darin, einen Wert auf seinen Typ zu prüfen. Zum Beispiel, ob ein Wert eine Zeichenkette ist. Dabei geht es nicht darum, was der String enthält, sondern nur um seinen Typ. In Typescript gibt es viele Typen: String, Number, Boolean, Bigint, Objekte, Klassen, Schnittstellen, Generics, Mapped Types und viele mehr. Dank des leistungsfähigen Typensystems von Typescript steht eine große Anzahl verschiedener Typen zur Verfügung.",
        "In JavaScript itself, primitive types can be parsed with the `typeof` operator. For more complex types like interfaces, mapped types, or generic set/map this is not so easy anymore and a validator library like `@deepkit/type` becomes necessary. Deepkit is the only solution that allows to validate all TypesScript types directly without any detours.": "In JavaScript selbst können primitive Typen mit dem Operator `typeof` geparst werden. Für komplexere Typen wie Schnittstellen, gemappte Typen oder generische Sets/Maps ist dies nicht mehr so einfach und eine Validierungsbibliothek wie `@deepkit/type` wird notwendig. Deepkit ist die einzige Lösung, die es erlaubt, alle TypesScript-Typen direkt und ohne Umwege zu validieren.",
        "In Deepkit, type validation can be done using either the `validate`, `is`, or `assert` function.": "In Deepkit kann die Typprüfung entweder mit der Funktion `validate`, `is` oder `assert` durchgeführt werden.",
        "The function `is` is a so-called type guard and `assert` is a type assertion. Both will be explained in the next section.": "Die Funktion `ist` ist ein so genannter Type Guard und `assert` ist eine Type Assertion. Beide werden im nächsten Abschnitt erklärt.",
        "The function `validate` returns an array of found errors and on success an empty array. Each entry in this array describes the exact error code and the error message as well as the path when more complex types like objects or arrays are validated.": "Die Funktion `validate` gibt ein Array der gefundenen Fehler und bei Erfolg ein leeres Array zurück. Jeder Eintrag in diesem Array beschreibt den genauen Fehlercode und die Fehlermeldung sowie den Pfad, wenn komplexere Typen wie Objekte oder Arrays validiert werden.",
        "All three functions are used in roughly the same way. The type is specified or referenced as the first type argument and the data is passed as the first function argument.": "Alle drei Funktionen werden in etwa auf die gleiche Weise verwendet. Der Typ wird als erstes Typargument angegeben oder referenziert und die Daten werden als erstes Funktionsargument übergeben.",
        "If you work with more complex types like classes or interfaces, the array can also contain several entries.": "Wenn Sie mit komplexeren Typen wie Klassen oder Schnittstellen arbeiten, kann das Array auch mehrere Einträge enthalten.",
        "The validator also supports deep recursive types. Paths are then separated with a dot.": "Der Validator unterstützt auch tief rekursive Typen. Pfade werden dann mit einem Punkt getrennt.",
        "Take advantage of the benefits that TypeScript offers you. For example, more complex types like a `user` can be reused in multiple places without having to declare it again and again. For example, if a `user` is to be validated without its `id`, TypeScript utitilies can be used to quickly and efficiently create derived subtypes. Very much in the spirit of DRY (Don't Repeat Yourself).": "Nutzen Sie die Vorteile, die TypeScript Ihnen bietet. Zum Beispiel können komplexere Typen wie ein \"user\" an mehreren Stellen wiederverwendet werden, ohne ihn immer wieder deklarieren zu müssen. Wenn beispielsweise ein \"Benutzer\" ohne seine \"ID\" validiert werden soll, können TypeScript-Utilities verwendet werden, um schnell und effizient abgeleitete Subtypen zu erstellen. Ganz im Sinne von DRY (Don't Repeat Yourself).",
        "Deepkit is the only major framework that has the ability to access TypeScripts types in this way at runtime. If you want to use types in frontend and backend, types can be swapped out to a separate file and thus imported anywhere. Use this option to your advantage to keep the code efficient and clean.": "Deepkit ist das einzige große Framework, das auf diese Weise zur Laufzeit auf TypeScripts-Typen zugreifen kann. Wenn Sie Typen im Frontend und Backend verwenden wollen, können Typen in eine separate Datei ausgelagert und somit überall importiert werden. Nutzen Sie diese Möglichkeit zu Ihrem Vorteil, um den Code effizient und sauber zu halten.",
        "A type cast (contrary to type guard) in TypeScript is not a construct at runtime, but is only handled in the type system itself. It is not a safe way to assign a type to unknown data.": "Ein type cast (im Gegensatz zu type guard) ist in TypeScript kein Konstrukt zur Laufzeit, sondern wird nur im Typsystem selbst behandelt. Es ist kein sicherer Weg, unbekannten Daten einen Typ zuzuweisen.",
        "The `as string` code is not safe. The variable `data` could have literally any value, for example `{username: 123}`, or even `{}`, and would have the consequence that `username` is not a string, but something completely different and therefore the code `username.startsWith('@')` will lead to an error, so that in the worst case the program crashes. To guarantee at runtime that `data` here has a property `username` with the type string, type-guards must be used.": "Der \"as string\"-Code ist nicht sicher. Die Variable `data` könnte buchstäblich jeden Wert haben, z.B. `{Benutzername: 123}`, oder sogar `{}`, und hätte zur Folge, dass `Benutzername` kein String ist, sondern etwas völlig anderes und daher der Code `username.startsWith('@')` zu einem Fehler führt, so dass im schlimmsten Fall das Programm abstürzt. Um zur Laufzeit zu garantieren, dass `data` hier eine Eigenschaft `username` mit dem Typ string hat, müssen type-guards verwendet werden.",
        "Type guards are functions that give TypeScript a hint about what type the passed data is guaranteed to have at runtime. Armed with this knowledge, TypeScript then \"narrows\" the type as the code progresses. For example, `any` can be made into a string, or any other type in a safe way. So if there is data of which the type is not known (`any` or `unknown`), a type guard helps to narrow it down more precisely based on the data itself. However, the type guard is only as safe as its implementation. If you make a mistake, this can have severe consequences, because fundamental assumptions suddenly turn out to be untrue.": "Type Guards sind Funktionen, die TypeScript einen Hinweis darauf geben, welchen Typ die übergebenen Daten zur Laufzeit garantiert haben werden. Mit diesem Wissen ausgestattet, grenzt TypeScript dann den Typ im weiteren Verlauf des Codes ein. Zum Beispiel kann \"any\" in einen String oder einen anderen Typ auf sichere Weise umgewandelt werden. Wenn es also Daten gibt, deren Typ nicht bekannt ist (`any` oder `unknown`), hilft ein Type Guard bei der genaueren Eingrenzung auf Basis der Daten selbst. Der Type Guard ist jedoch nur so sicher wie seine Implementierung. Wenn Sie einen Fehler machen, kann dies schwerwiegende Folgen haben, weil sich grundlegende Annahmen plötzlich als unwahr erweisen.",
        "Type-Guard": "Typ-Guard",
        "A type guard on the above used type `User` could look in simplest form as follows. Note that the above explained special features with NaN are not part here and thus this type guard is not quite correct.": "Ein Type Guard für den oben verwendeten Typ `User` könnte in einfachster Form wie folgt aussehen. Beachten Sie, dass die oben erläuterten Besonderheiten bei NaN hier nicht zum Tragen kommen und somit dieser Type Guard nicht ganz korrekt ist.",
        "A type guard always returns a Boolean and is usually used directly in an If operation.": "Ein Type Guard gibt immer einen Booleschen Wert zurück und wird normalerweise direkt in einer If-Operation verwendet.",
        "Writing a separate function for each type guard, especially for more complex types, and then adapting it every time a type changes is extremely tedious, error-prone, and not efficient. Therefore, Deepkit provides the function `is`, which automatically provides a Type-Guard for any TypeScript type. This then also automatically takes into account special features such as the above-mentioned problem with NaN. The function `is` does the same as `validate`, but instead of an array of errors it simply returns a boolean.": "Für jeden Type-Guard eine eigene Funktion zu schreiben, insbesondere für komplexere Typen, und diese dann bei jeder Typänderung anzupassen, ist extrem mühsam, fehleranfällig und nicht effizient. Deshalb bietet Deepkit die Funktion `is`, die automatisch einen Type-Guard für jeden TypeScript-Typ bereitstellt. Dieser berücksichtigt dann auch automatisch Besonderheiten wie das oben erwähnte Problem mit NaN. Die Funktion `is` macht das Gleiche wie `validate`, aber statt eines Arrays von Fehlern gibt sie einfach einen Boolean zurück.",
        "A pattern that can be found more often is to return an error directly in case of incorrect validation, so that subsequent code is not executed. This can be used in various places without changing the complete flow of the code.": "Ein häufiger anzutreffendes Muster besteht darin, bei einer fehlerhaften Validierung direkt einen Fehler zurückzugeben, so dass der nachfolgende Code nicht ausgeführt wird. Dies kann an verschiedenen Stellen eingesetzt werden, ohne den gesamten Codefluss zu verändern.",
        "Alternatively, a TypeScript type assertion can be used. The `assert` function automatically throws an error if the given data does not validate correctly to a type. The special signature of the function, which distinguishes TypeScript type assertions, helps TypeScript to automatically narrow the passed variable.": "Alternativ kann auch eine TypeScript-Typ-Assertion verwendet werden. Die Funktion `assert` löst automatisch einen Fehler aus, wenn die übergebenen Daten nicht korrekt auf einen Typ validiert werden können. Die spezielle Signatur der Funktion, die TypeScript Type Assertions auszeichnet, hilft TypeScript, die übergebene Variable automatisch einzugrenzen.",
        "Here, too, take advantage of the benefits that TypeScript offers you. Types can be reused or customized using various TypeScript functions.": "Nutzen Sie auch hier die Vorteile, die Ihnen TypeScript bietet. Typen können mit verschiedenen TypeScript-Funktionen wiederverwendet oder angepasst werden.",
        "Error Reporting": "Fehlerberichterstattung",
        "The functions `is`, `assert` and `validates` return a boolean as result. To get exact information about failed validation rules, the `validate` function can be used. It returns an empty array if everything was validated successfully. In case of errors the array will contain one or more entries with the following structure:": "Die Funktionen `is`, `assert` und `validates` geben als Ergebnis einen boolschen Wert zurück. Um genaue Informationen über fehlgeschlagene Überprüfungsregeln zu erhalten, kann die Funktion `validate` verwendet werden. Sie gibt ein leeres Array zurück, wenn alles erfolgreich validiert wurde. Im Falle von Fehlern enthält das Array einen oder mehrere Einträge mit der folgenden Struktur:",
        "The function receives as first type argument any TypeScript type and as first argument the data to validate.": "Die Funktion erhält als erstes Typ-Argument einen beliebigen TypeScript-Typ und als erstes Argument die zu validierenden Daten.",
        "Complex types such as interfaces, classes, or generics can also be used.": "Komplexe Typen wie Schnittstellen, Klassen oder Generika können ebenfalls verwendet werden.",
        "Constraints": "Zwänge",
        "In addition to checking the types, other arbitrary constraints can be added to a type. The validation of these additional content constraints is done automatically after the types themselves have been validated. This is done in all validation functions like `validate`, `is`, and `assert`.": "Zusätzlich zur Überprüfung der Typen können weitere beliebige Einschränkungen zu einem Typ hinzugefügt werden. Die Validierung dieser zusätzlichen inhaltlichen Einschränkungen erfolgt automatisch, nachdem die Typen selbst validiert wurden. Dies geschieht in allen Validierungsfunktionen wie `validate`, `is` und `assert`.",
        "A restriction can be, for example, that a string must have a certain minimum or maximum length. These restrictions are added to the actual types via the type decorators. There is a whole variety of decorators that can be used. Own decorators can be defined and used at will in case of extended needs.": "Eine Einschränkung kann z. B. sein, dass eine Zeichenkette eine bestimmte Mindest- oder Höchstlänge haben muss. Diese Einschränkungen werden den eigentlichen Typen über die Typdekoratoren hinzugefügt. Es gibt eine ganze Reihe von Dekoratoren, die verwendet werden können. Eigene Dekoratoren können definiert und nach Belieben verwendet werden, wenn ein erweiterter Bedarf besteht.",
        "With `&` any number of type decorators can be added to the actual type. The result, here `username`, can then be used in all validation functions but also in other types.": "Mit `&` kann eine beliebige Anzahl von Typdekoratoren zum eigentlichen Typ hinzugefügt werden. Das Ergebnis, hier `username`, kann dann in allen Validierungsfunktionen, aber auch in anderen Typen verwendet werden.",
        "The function `validate` gives useful error messages coming from the constraints.": "Die Funktion `validate` liefert nützliche Fehlermeldungen aus den Constraints.",
        "This information can be represented for example wonderfully also at a form automatically and be translated by means of the `code`. Through the existing path for objects and arrays, fields in a form can filter out and display the appropriate error.": "Diese Informationen können z.B. wunderbar auch in einem Formular automatisch dargestellt und mittels des `Codes` übersetzt werden. Durch den vorhandenen Pfad für Objekte und Arrays können Felder in einem Formular herausgefiltert und der entsprechende Fehler angezeigt werden.",
        "An often useful use case is also to define an email with a RegExp constraint. Once the type is defined, it can be used anywhere.": "Ein oft nützlicher Anwendungsfall ist auch die Definition einer E-Mail mit einer RegExp-Beschränkung. Sobald der Typ definiert ist, kann er überall verwendet werden.",
        "Any number of constraints can be added.": "Es kann eine beliebige Anzahl von Beschränkungen hinzugefügt werden.",
        "Constraint Types": "Einschränkungstypen",
        "Validate&lt;typeof myValidator&gt;": "Validate&lt;typeof myValidator&gt;",
        "Validation using a custom validator function. See next section Custom Validator for more information.": "Validierung mit einer benutzerdefinierten Validator-Funktion. Weitere Informationen finden Sie im nächsten Abschnitt Benutzerdefinierter Validator.",
        "Pattern&lt;typeof myRegexp&gt;": "Pattern&lt;typeof myRegexp&gt;",
        "Defines a regular expression as validation pattern. Usually used for E-Mail validation or more complex content validation.": "Definiert einen regulären Ausdruck als Überprüfungsmuster. Wird in der Regel für die E-Mail-Validierung oder eine komplexere Inhaltsvalidierung verwendet.",
        "Alpha": "Alpha",
        "Validation for alpha characters (a-Z).": "Validierung für Alpha-Zeichen (a-Z).",
        "Alphanumeric": "Alphanumerisch",
        "Validation for alpha and numeric characters.": "Validierung für Alpha- und numerische Zeichen.",
        "Ascii": "Ascii",
        "Validation for ASCII characters.": "Validierung für ASCII-Zeichen.",
        "Decimal&lt;number, number&gt;": "Dezimal&lt;zahl, zahl&gt;",
        "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.": "Die Validierung für die Zeichenkette stellt eine Dezimalzahl dar, z. B. 0,1, .3, 1,1, 1,00003, 4,0 usw.",
        "MultipleOf&lt;number&gt;": "MultipleOf&lt;number&gt;",
        "Validation of numbers that are a multiple of given number.": "Validierung von Zahlen, die ein Vielfaches einer bestimmten Zahl sind.",
        "MinLength&lt;number&gt;, MaxLength&lt;number&gt;": "MinLength&lt;number&gt;, MaxLength&lt;number&gt;",
        "Validation for min/max length for arrays or strings.": "Validierung der minimalen/maximalen Länge für Arrays oder Strings.",
        "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;": "Beinhaltet&lt;'jede'&gt; Schließt&lt;'jede'&gt aus;",
        "Validation for an array item or sub string being included/excluded": "Validierung für ein Array-Element oder eine Teilzeichenkette, die eingeschlossen/ausgeschlossen wird",
        "Minimum&lt;number&gt;, Maximum&lt;number&gt;": "Minimum&lt;Zahl&gt;, Maximum&lt;Zahl&gt;",
        "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.": "Überprüfung, ob ein Wert das Minimum oder Maximum einer bestimmten Zahl ist. Dasselbe wie `>=` und `&lt;=`.",
        "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;": "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;",
        "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.": "Dasselbe wie Minimum/Maximum, aber ohne den Wert selbst. Dasselbe wie `>` und `<`.",
        "Positive, Negative, PositiveNoZero, NegativeNoZero": "Positiv, Negativ, PositivNichtNull, NegativNichtNull",
        "Validation for a value being positive or negative.": "Überprüfung, ob ein Wert positiv oder negativ ist.",
        "BeforeNow, AfterNow": "VorherJetzt, NachherJetzt",
        "Validation for a date value compared to now (new Date)..": "Validierung für einen Datumswert im Vergleich zu jetzt (neues Datum)..",
        "Email": "E-Mail",
        "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.": "Einfache Regexp-Validierung von Emails über `/^\\S+@\\S+$/`. Ist automatisch ein `String`, also keine Notwendigkeit, `String & Email` zu machen.",
        "integer": "Ganzzahl",
        "Ensures that the number is a integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.": "Stellt sicher, dass die Zahl eine Ganzzahl im richtigen Bereich ist. Ist automatisch eine \"Zahl\", so dass keine Notwendigkeit besteht, \"Zahl & Ganzzahl\" zu verwenden.",
        "See Special types: integer/floats for more information": "Siehe Spezielle Typen: Integer/Floats für weitere Informationen",
        "Custom validator": "Benutzerdefinierter Validierer",
        "If the built-in validators are not sufficient, custom validation functions can be created and used via the `Validate` decorator.": "Wenn die eingebauten Validatoren nicht ausreichen, können benutzerdefinierte Validierungsfunktionen erstellt und über den Dekorator `Validate` verwendet werden.",
        "Note that your custom validation function is executed after all built-in type validators have been called. If a validator fails, all subsequent validators for the current type are skipped. Only one failure is possible per type.": "Beachten Sie, dass Ihre benutzerdefinierte Validierungsfunktion ausgeführt wird, nachdem alle eingebauten Typvalidierer aufgerufen wurden. Wenn ein Validator fehlschlägt, werden alle nachfolgenden Validatoren für den aktuellen Typ übersprungen. Pro Typ ist nur ein Fehlschlag möglich.",
        "Generic Validator": "Generischer Validator",
        "In the Validator function the type object is available which can be used to get more information about the type using the validator. There is also a possibility to define an arbitrary validator option that must be passed to the validate type and makes the validator configurable. With this information and its parent references, powerful generic validators can be created.": "In der Validator-Funktion steht das Typ-Objekt zur Verfügung, das verwendet werden kann, um weitere Informationen über den Typ zu erhalten, der den Validator verwendet. Es besteht auch die Möglichkeit, eine beliebige Validator-Option zu definieren, die an den Validator-Typ übergeben werden muss und den Validator konfigurierbar macht. Mit diesen Informationen und ihren übergeordneten Referenzen können leistungsfähige generische Validatoren erstellt werden.",
        "Serialisation": "Serialisierung",
        "Serialization is the process of converting data types into a format suitable for transport or storage, for example. Deserialization is the process of undoing this. This is done loss-lessly, meaning that data can be converted to and from a serialization target without losing data type information or the data itself.": "Unter Serialisierung versteht man die Umwandlung von Datentypen in ein Format, das z. B. für den Transport oder die Speicherung geeignet ist. Die Deserialisierung ist der Prozess, der dies wieder rückgängig macht. Dies geschieht verlustfrei, d. h. Daten können in ein Serialisierungsziel und aus diesem heraus konvertiert werden, ohne dass Datentypinformationen oder die Daten selbst verloren gehen.",
        "In JavaScript, serialization is usually between JavaScript objects and JSON. JSON supports only String, Number, Boolean, Objects, and Arrays. JavaScript, on the other hand, supports many other types such as BigInt, ArrayBuffer, typed arrays, Date, custom class instances, and many more. Now, to transmit JavaScript data to a server using JSON, you need a serialization process (on the client) and a deserialization process (on the server), or vice versa if the server sends data to the client as JSON. Using `JSON.parse` and `JSON.stringify` is often not sufficient for this, as it is not lossless.": "In JavaScript erfolgt die Serialisierung normalerweise zwischen JavaScript-Objekten und JSON. JSON unterstützt nur String, Number, Boolean, Objects und Arrays. JavaScript hingegen unterstützt viele andere Typen wie BigInt, ArrayBuffer, typisierte Arrays, Date, benutzerdefinierte Klasseninstanzen und viele mehr. Um nun JavaScript-Daten mit JSON an einen Server zu übertragen, benötigen Sie einen Serialisierungsprozess (auf dem Client) und einen Deserialisierungsprozess (auf dem Server), oder umgekehrt, wenn der Server Daten als JSON an den Client sendet. Die Verwendung von `JSON.parse` und `JSON.stringify` ist dafür oft nicht ausreichend, da sie nicht verlustfrei ist.",
        "This serialization process is absolutely necessary for non-trivial data, since JSON loses its information even for basic types like a date. A new Date is finally serialized as a string in JSON:": "Dieser Serialisierungsprozess ist für nicht-triviale Daten absolut notwendig, da JSON selbst bei einfachen Typen wie einem Datum seine Informationen verliert. Ein neues Datum wird schließlich als String in JSON serialisiert:",
        "As you can see, the result of JSON.stringify is a JSON string. If you deserialize it again with JSON.parse, you will not get a date object, but a string.": "Wie Sie sehen können, ist das Ergebnis von JSON.stringify ein JSON-String. Wenn Sie es mit JSON.parse wieder deserialisieren, erhalten Sie kein Datumsobjekt, sondern einen String.",
        "Although there are various workarounds to teach JSON.parse to deserialize Date objects, they are error-prone and poorly performing. To enable type-safe serialization and deserialization for this case and many other types, a serialization process is necessary.": "Zwar gibt es verschiedene Workarounds, um JSON.parse die Deserialisierung von Datumsobjekten beizubringen, doch sind diese fehleranfällig und wenig leistungsfähig. Um eine typsichere Serialisierung und Deserialisierung für diesen Fall und viele andere Typen zu ermöglichen, ist ein Serialisierungsprozess erforderlich.",
        "There are four main functions available: `serialize`, `cast`, `deserialize` and `validatedDeserialize`. Under the hood of these functions, the globally available JSON serializer from `@deepkit/type` is used by default, but a custom serialization target can also be used.": "Es sind vier Hauptfunktionen verfügbar: `serialize`, `cast`, `deserialize` und `validatedDeserialize`. Unter der Haube dieser Funktionen wird standardmäßig der global verfügbare JSON-Serialisierer von `@deepkit/type` verwendet, es kann aber auch ein benutzerdefiniertes Serialisierungsziel verwendet werden.",
        "Deepkit Type supports user-defined serialization targets, but already comes with a powerful JSON serialization target that serializes data as JSON objects and then can be correctly and safely converted as JSON using JSON.stringify. With `@deepkit/bson`, BSON can also be used as a serialization target. How to create a custom serialization target (for example for a database driver) can be learned in the Custom Serializer section.": "Deepkit Type unterstützt benutzerdefinierte Serialisierungsziele, verfügt aber bereits über ein leistungsfähiges JSON-Serialisierungsziel, das Daten als JSON-Objekte serialisiert und dann mit JSON.stringify korrekt und sicher in JSON umgewandelt werden kann. Mit `@deepkit/bson` kann auch BSON als Serialisierungsziel verwendet werden. Wie man ein benutzerdefiniertes Serialisierungsziel (z.B. für einen Datenbanktreiber) erstellt, erfahren Sie im Abschnitt Benutzerdefinierter Serialisierer.",
        "Note that although serializers also validate data for compatibility, these validations are different from the validation in xref:validation.adoc[Validation]. Only the `cast` function also calls the full validation process from the xref:validation.adoc[Validation] chapter after successful deserialization, and throws an error if the data is not valid.": "Beachten Sie, dass die Serialisierer aus Kompatibilitätsgründen zwar auch Daten validieren, diese Validierungen sich aber von der Validierung in xref:validation.adoc[Validation] unterscheiden. Nur die Funktion `cast` ruft nach erfolgreicher Deserialisierung auch den vollständigen Validierungsprozess aus dem Kapitel xref:validation.adoc[Validation] auf und gibt einen Fehler aus, wenn die Daten nicht gültig sind.",
        "Alternatively, `validatedDeserialize` can be used to validate after deserialization. Another alternative is to manually call the `validate` or `validates` functions on deserialized data from the `deserialize` function, see xref:validation.adoc[Validation].": "Alternativ kann `validatedDeserialize` verwendet werden, um nach der Deserialisierung zu validieren. Eine weitere Alternative ist der manuelle Aufruf der Funktionen `validate` oder `validates` für deserialisierte Daten aus der Funktion `deserialize`, siehe xref:validation.adoc[Validation].",
        "All functions from serialization and validation throw a `ValidationError` from `@deepkit/type` on errors.": "Alle Funktionen aus Serialisierung und Validierung werfen bei Fehlern einen `ValidationError` aus `@deepkit/type`.",
        "Cast": "Cast",
        "Todo": "Todo",
        "Serialisierung": "Serialisierung",
        "The function `serialize` converts the passed data by default with the JSON serializer into a JSON object, that is: String, Number, Boolean, Object, or Array. The result of this can then be safely converted to a JSON using `JSON.stringify`.": "Die Funktion `serialize` konvertiert die übergebenen Daten standardmäßig mit dem JSON-Serializer in ein JSON-Objekt, d.h.: String, Number, Boolean, Object, oder Array. Das Ergebnis kann dann mit `JSON.stringify` sicher in ein JSON konvertiert werden.",
        "Deserialisierung": "Deserialisierung",
        "The function `deserialize` converts the passed data per default with the JSON serializer into the corresponding specified types. The JSON serializer expects a JSON object, i.e.: string, number, boolean, object, or array. This is usually obtained from a `JSON.parse` call.": "Die Funktion `deserialize` konvertiert die übergebenen Daten standardmäßig mit dem JSON-Serializer in die entsprechenden angegebenen Typen. Der JSON-Serializer erwartet ein JSON-Objekt, d.h.: String, Zahl, Boolean, Objekt oder Array. Dieses wird in der Regel durch einen `JSON.parse`-Aufruf gewonnen.",
        "If the correct data type is already passed (for example, a Date object in the case of `created`), then this is taken as it is.": "Wenn bereits der richtige Datentyp übergeben wird (z.B. ein Datumsobjekt im Fall von `created`), dann wird dieser so übernommen, wie er ist.",
        "Not only a class, but any TypeScript type can be specified as the first type argument. So even primitives or very complex types can be passed:": "Nicht nur eine Klasse, sondern jeder TypeScript-Typ kann als erstes Typ-Argument angegeben werden. Es können also auch Primitive oder sehr komplexe Typen übergeben werden:",
        "Soft Type Conversion": "Soft Type Konvertierung",
        "In the deserialization process a soft type conversion is implemented. This means that String and Number for String types or a Number for a String type can be accepted and converted automatically. This is useful, for example, when data is accepted via a URL and passed to the deserializer. Since the URL is always a string, Deepkit Type still tries to resolve the types for Number and Boolean.": "Bei der Deserialisierung wird eine weiche Typkonvertierung durchgeführt. Das bedeutet, dass String und Number für String-Typen oder eine Number für einen String-Typ akzeptiert und automatisch konvertiert werden können. Dies ist z.B. dann sinnvoll, wenn Daten über eine URL angenommen und an den Deserialisierer übergeben werden. Da es sich bei der URL immer um einen String handelt, versucht Deepkit Type weiterhin, die Typen Number und Boolean aufzulösen.",
        "The following soft type conversions are built into the JSON serializer:": "Die folgenden weichen Typkonvertierungen sind in den JSON-Serialisierer integriert:",
        "*number|bigint*: Number or Bigint accept String, Number, and BigInt. `parseFloat` or `BigInt(x)` are used in case of a necessary conversion.": "*Zahl|Bigint*: Number oder Bigint akzeptieren String, Number und BigInt. `parseFloat` oder `BigInt(x)` werden im Falle einer notwendigen Umwandlung verwendet.",
        "*boolean*: Boolean accepts Number and String. 0, '0', 'false' is interpreted as `false`. 1, '1', 'true' is interpreted as `true`.": "*Boolesch*: Boolean akzeptiert Zahl und String. 0, '0', 'false' wird als `false` interpretiert. 1, '1', 'wahr' wird als 'wahr' interpretiert.",
        "*string*: String accepts Number, String, Boolean, and many more. All non-string values are automatically converted with `String(x)`.": "*Zeichenfolge*: String akzeptiert Number, String, Boolean und viele mehr. Alle Nicht-String-Werte werden automatisch mit `String(x)` konvertiert.",
        "The soft conversion can also be deactivated:": "Die weiche Umwandlung kann auch deaktiviert werden:",
        "In the case of invalid data, no attempt is made to convert it and instead an error message is thrown.": "Bei ungültigen Daten wird nicht versucht, sie zu konvertieren, sondern es wird eine Fehlermeldung ausgegeben.",
        "Type-Decorators": "Typ-Dekoratoren",
        "Integer": "Integer",
        "Mapped": "Karte",
        "Naming Strategy": "Strategie der Namensgebung",
        "Benutzerdefinierter Serializer": "Benutzerdefinierter Serialisierer",
        "By default, `@deepkit/type` comes with a JSON serializer and type validation for TypeScript types. You can extend this and add or remove the serialization functionality or change the way validation is done, as validation is also linked to the serializer.": "Standardmäßig wird `@deepkit/type` mit einem JSON-Serialisierer und einer Typ-Validierung für TypeScript-Typen geliefert. Sie können dies erweitern und die Serialisierungsfunktionalität hinzufügen oder entfernen oder die Art der Validierung ändern, da die Validierung auch mit dem Serialisierer verknüpft ist.",
        "New Serializer": "Neuer Serialisierer",
        "A serializer is simply an instance of the `Serializer` class with registered serializer templates. Serializer templates are small functions that create JavaScript code for the JIT serializer process. For each type (String, Number, Boolean, etc.) there is a separate Serializer template that is responsible for returning code for data conversion or validation. This code must be compatible with the JavaScript engine that the user is using.": "Ein Serializer ist einfach eine Instanz der Klasse `Serializer` mit registrierten Serializer-Vorlagen. Serializer-Vorlagen sind kleine Funktionen, die JavaScript-Code für den JIT-Serializer-Prozess erzeugen. Für jeden Typ (String, Number, Boolean usw.) gibt es eine eigene Serializer-Vorlage, die für die Rückgabe von Code zur Datenkonvertierung oder -validierung zuständig ist. Dieser Code muss mit der JavaScript-Engine kompatibel sein, die der Benutzer verwendet.",
        "Only during the execution of the compiler template function do you (or should you) have full access to the full type. The idea is that you should embed all the information needed to convert a type directly into the JavaScript code, resulting in highly optimized code (also called JIT-optimized code).": "Nur während der Ausführung der Compiler-Vorlagenfunktion haben Sie (oder sollten Sie) vollen Zugriff auf den vollständigen Typ. Die Idee ist, dass Sie alle Informationen, die für die Umwandlung eines Typs erforderlich sind, direkt in den JavaScript-Code einbetten sollten, was zu hoch optimiertem Code führt (auch JIT-optimierter Code genannt).",
        "The following example creates an empty serializer.": "Im folgenden Beispiel wird ein leerer Serialisierer erstellt.",
        "As you can see, nothing has been converted (`created` is still a number, but we have defined it as `date`). To change this, we add a serializer template for deserialization of type Date.": "Wie Sie sehen können, wurde nichts umgewandelt (`created` ist immer noch eine Zahl, aber wir haben sie als `date` definiert). Um dies zu ändern, fügen wir eine Serializer-Vorlage für die Deserialisierung des Typs Date hinzu.",
        "Now our serializer converts the value into a Date object.": "Jetzt wandelt unser Serializer den Wert in ein Date-Objekt um.",
        "To do the same for serialization, we register another serialization template.": "Um das Gleiche für die Serialisierung zu tun, registrieren wir eine weitere Serialisierungsvorlage.",
        "Our new serializer now correctly converts the date from the Date object to a string in the serialization process.": "Unser neuer Serialisierer konvertiert nun das Datum aus dem Date-Objekt korrekt in eine Zeichenkette während des Serialisierungsprozesses.",
        "Examples": "Beispiele",
        "To see many more examples, you can take a look at the code of the link:https://github.com/deepkit/deepkit-framework/blob/master/packages/type/src/serializer.ts#L1688[JSON-Serializers] included in Deepkit Type.": "Um viele weitere Beispiele zu sehen, können Sie einen Blick auf den Code des Links:https://github.com/deepkit/deepkit-framework/blob/master/packages/type/src/serializer.ts#L1688[JSON-Serializer] werfen, der in Deepkit Type enthalten ist.",
        "Expanding A Serializer": "Einen Serialisierer erweitern",
        "If you want to extend an existing serializer, you can do so using class inheritance. This works because serializers should be written to register their templates in the constructor.": "Wenn Sie einen vorhandenen Serialisierer erweitern möchten, können Sie dies über Klassenvererbung tun. Dies funktioniert, weil Serialisierer so geschrieben werden sollten, dass sie ihre Vorlagen im Konstruktor registrieren.",
        "Dependency Injection": "Injektion von Abhängigkeiten",
        "Dependency Injection (DI) is a design pattern in which classes and functions _receive_ their dependencies. It follows the principle of Inversion of Control (IoC) and helps to better separate complex code in order to significantly improve testability, modularity and clarity. Although there are other design patterns, such as the service locator pattern, for applying the principle of IoC, DI has established itself as the dominant pattern, especially in enterprise software.": "Dependency Injection (DI) ist ein Entwurfsmuster, bei dem Klassen und Funktionen ihre Abhängigkeiten _empfangen_. Es folgt dem Prinzip der Inversion of Control (IoC) und hilft, komplexen Code besser zu trennen, um Testbarkeit, Modularität und Übersichtlichkeit deutlich zu verbessern. Obwohl es auch andere Entwurfsmuster, wie z. B. das Service-Locator-Muster, für die Anwendung des IoC-Prinzips gibt, hat sich DI vor allem in der Unternehmenssoftware als das dominierende Muster etabliert.",
        "To illustrate the principle of IoC, here is an example:": "Um das Prinzip von IoC zu veranschaulichen, hier ein Beispiel:",
        "The UserRepository class has an HttpClient as a dependency. This dependency in itself is nothing remarkable, but it is problematic that `UserRepository` creates the HttpClient itself.": "Die UserRepository-Klasse hat einen HttpClient als Abhängigkeit. Diese Abhängigkeit ist an sich nichts Bemerkenswertes, aber es ist problematisch, dass \"UserRepository\" den HttpClient selbst erstellt.",
        "It seems to be a good idea to encapsulate the creation of the HttpClient in the UserRepository, but this is not the case. What if we want to replace the HttpClient? What if we want to test UserRepository in a unit test without allowing real HTTP requests to go out? How do we know that the class even uses an HttpClient?": "Es scheint eine gute Idee zu sein, die Erstellung des HttpClient im UserRepository zu kapseln, aber das ist nicht der Fall. Was, wenn wir den HttpClient ersetzen wollen? Was ist, wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen rausgehen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient verwendet?",
        "Inversion of Control": "Umkehrung der Kontrolle",
        "In the thought of Inversion of Control (IoC) is the following alternative variant that sets the HttpClient as an explicit dependency in the constructor (also known as constructor injection).": "Im Gedanken der Inversion of Control (IoC) ist die folgende alternative Variante, die den HttpClient als explizite Abhängigkeit im Konstruktor setzt (auch bekannt als Konstruktorinjektion).",
        "Now UserRepository is no longer responsible for creating the HttpClient, but the user of UserRepository. This is Inversion of Control (IoC). The control has been reversed or inverted. Specifically, this code applies dependency injection, because dependencies are received (injected) and no longer created or requested. Dependency Injection is only one variant of IoC.": "Nun ist nicht mehr UserRepository für die Erstellung des HttpClient verantwortlich, sondern der Benutzer von UserRepository. Dies ist eine Umkehrung der Kontrolle (IoC). Die Kontrolle wurde umgedreht oder invertiert. Insbesondere wendet dieser Code Dependency Injection an, da Abhängigkeiten empfangen (injiziert) und nicht mehr erstellt oder angefordert werden. Dependency Injection ist nur eine Variante von IoC.",
        "Service Locator": "Service-Suchmaschine",
        "Besides DI, Service Locator (SL) is also a way to apply the IoC principle. This is commonly considered the counterpart to Dependency Injection, as it requests dependencies rather than receiving them. If HttpClient were requested in the above code as follows, it would be called a Service Locator pattern.": "Neben DI ist auch der Service Locator (SL) eine Möglichkeit, das IoC-Prinzip anzuwenden. Es wird gemeinhin als Gegenstück zur Dependency Injection betrachtet, da es Abhängigkeiten anfordert, anstatt sie zu empfangen. Wenn der HttpClient im obigen Code wie folgt angefordert würde, würde dies als Service-Locator-Muster bezeichnet werden.",
        "The function `locator.getHttpClient` can have any name. Alternatives would be function calls like `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` or a container call like `container.get(HttpClient)`. An import of a global is a slightly different variant of a service locator, using the module system itself as the locator:": "Die Funktion `locator.getHttpClient` kann einen beliebigen Namen haben. Alternativen wären Funktionsaufrufe wie `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` oder ein Container-Aufruf wie `container.get(HttpClient)`. Der Import eines Globals ist eine etwas andere Variante eines Service-Locators, der das Modulsystem selbst als Locator verwendet:",
        "All these variants have in common that they explicitly request the HttpClient dependency. This request can happen not only to properties as a default value, but also somewhere in the middle of the code. Since in the middle of the code means that it is not part of a type interface, the use of the HttpClient is hidden. Depending on the variant of how the HttpClient is requested, it can sometimes be very difficult or completely impossible to replace it with another implementation. Especially in the area of unit tests and for the sake of clarity, difficulties can arise here, so that the service locator is now classified as an anti-pattern in certain situations.": "Alle diese Varianten haben gemeinsam, dass sie die HttpClient-Abhängigkeit explizit anfordern. Diese Anforderung kann nicht nur an Eigenschaften als Standardwert erfolgen, sondern auch irgendwo mitten im Code. Da mitten im Code bedeutet, dass er nicht Teil einer Typschnittstelle ist, ist die Verwendung des HttpClient versteckt. Je nach Variante, wie der HttpClient angefordert wird, kann es manchmal sehr schwierig oder gar unmöglich sein, ihn durch eine andere Implementierung zu ersetzen. Gerade im Bereich der Unit-Tests und aus Gründen der Übersichtlichkeit können hier Schwierigkeiten auftreten, so dass der Service-Locator nun in bestimmten Situationen als Anti-Pattern eingestuft wird.",
        "With Dependency Injection, nothing is requested, but it is explicitly provided by the user or received by the code. As can be seen in the example of Inversion of Control, the dependency injection pattern has already been applied there. Specifically, constructor injection can be seen there, since the dependency is declared in the constructor. So UserRepository must now be used as follows.": "Bei Dependency Injection wird nichts angefordert, sondern explizit vom Benutzer bereitgestellt oder vom Code entgegengenommen. Wie im Beispiel der Inversion of Control zu sehen ist, wurde das Dependency Injection Pattern dort bereits angewendet. Konkret ist dort die Konstruktorinjektion zu sehen, da die Abhängigkeit im Konstruktor deklariert wird. Das UserRepository muss nun also wie folgt verwendet werden.",
        "The code that wants to use UserRepository must also provide (inject) all its dependencies. Whether HttpClient should be created each time or the same one should be used each time is now decided by the user of the class and no longer by the class itself. It is no longer requested (from the class's point of view) as in the case of the service locator, or created entirely by itself in the initial example. This inversion of the flow has various advantages:": "Der Code, der UserRepository verwenden will, muss auch alle seine Abhängigkeiten bereitstellen (injizieren). Ob der HttpClient jedes Mal neu erstellt oder derselbe verwendet werden soll, wird nun vom Benutzer der Klasse und nicht mehr von der Klasse selbst entschieden. Er wird nicht mehr (aus Sicht der Klasse) angefordert, wie im Fall des Service Locators, oder wie im Ausgangsbeispiel ganz von selbst erstellt. Diese Umkehrung des Ablaufs hat verschiedene Vorteile:",
        "The code is easier to understand because all dependencies are explicitly visible.": "Der Code ist einfacher zu verstehen, da alle Abhängigkeiten explizit sichtbar sind.",
        "The code is easier to test because all dependencies are unique and can be easily modified if needed.": "Der Code ist einfacher zu testen, da alle Abhängigkeiten eindeutig sind und bei Bedarf leicht geändert werden können.",
        "The code is more modular, as dependencies can be easily exchanged.": "Der Code ist modularer, da Abhängigkeiten leicht ausgetauscht werden können.",
        "It promotes the Separation of Concern principle, as UserRepository is no longer responsible for creating very complex dependencies itself when in doubt.": "Es fördert den Grundsatz der Trennung der Verantwortlichkeiten, da UserRepository im Zweifelsfall nicht mehr selbst für die Erstellung sehr komplexer Abhängigkeiten verantwortlich ist.",
        "But an obvious disadvantage can also be recognized directly: Do I really need to create or manage all dependencies like the HttpClient myself? Yes and No. Yes, there are many cases where it is perfectly legitimate to manage the dependencies yourself. The hallmark of a good API is that dependencies don't get out of hand, and that even then they are pleasant to use. For many applications or complex libraries, this may well be the case. To provide a very complex low-level API with many dependencies in a simplified way to the user, facades are wonderfully suitable.": "Ein offensichtlicher Nachteil ist aber auch direkt zu erkennen: Muss ich wirklich alle Abhängigkeiten wie den HttpClient selbst erstellen oder verwalten? Ja und Nein. Ja, es gibt viele Fälle, in denen es völlig legitim ist, die Abhängigkeiten selbst zu verwalten. Eine gute API zeichnet sich dadurch aus, dass die Abhängigkeiten nicht aus dem Ruder laufen, und dass sie selbst dann noch angenehm zu verwenden sind. Bei vielen Anwendungen oder komplexen Bibliotheken kann dies durchaus der Fall sein. Um eine sehr komplexe Low-Level-API mit vielen Abhängigkeiten dem Benutzer auf vereinfachte Weise zur Verfügung zu stellen, sind Fassaden wunderbar geeignet.",
        "Dependency Injection Container": "Dependency Injection Container",
        "For more complex applications, however, it is not necessary to manage all dependencies yourself, because that is exactly what a so-called dependency injection container is for. This not only creates all objects automatically, but also \"injects\" the dependencies automatically, so that a manual \"new\" call is no longer necessary. There are various types of injection, such as constructor injection, method injection, or property injection. This makes it easy to manage even complicated constructions with many dependencies.": "Für komplexere Anwendungen ist es jedoch nicht notwendig, alle Abhängigkeiten selbst zu verwalten, denn genau dafür gibt es den sogenannten Dependency Injection Container. Dieser legt nicht nur alle Objekte automatisch an, sondern \"injiziert\" auch die Abhängigkeiten automatisch, so dass ein manueller \"new\"-Aufruf nicht mehr notwendig ist. Es gibt verschiedene Arten der Injektion, wie z.B. Konstruktorinjektion, Methodeninjektion oder Eigenschaftsinjektion. So lassen sich auch komplizierte Konstruktionen mit vielen Abhängigkeiten einfach verwalten.",
        "A dependency injection container (also called DI container or IoC container) brings Deepkit in `@deepkit/injector` or already ready integrated via App modules in the Deepkit Framework. The above code would look like this using a low-level API from the `@deepkit/injector` package.": "Ein Dependency Injection Container (auch DI-Container oder IoC-Container genannt) bringt Deepkit in `@deepkit/injector` oder bereits fertig integriert über App-Module in das Deepkit Framework. Der obige Code würde unter Verwendung einer Low-Level-API aus dem Paket \"@deepkit/injector\" wie folgt aussehen.",
        "The `injector` object in this case is the dependency injection container. Instead of using \"new UserRepository\", the container returns an instance of UserRepository using `get(UserRepository)`. To statically initialize the container, a list of providers is passed to the `InjectorContext.forProviders` function (in this case, simply the classes).": "Das \"Injector\"-Objekt ist in diesem Fall der Dependency Injection Container. Anstatt \"new UserRepository\" zu verwenden, gibt der Container mit \"get(UserRepository)\" eine Instanz von UserRepository zurück. Um den Container statisch zu initialisieren, wird eine Liste von Providern an die Funktion \"InjectorContext.forProviders\" übergeben (in diesem Fall einfach die Klassen).",
        "Since DI is all about providing dependencies, the container is provided with the dependencies, hence the technical term \"provider\". There are several types of providers: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. All together, they allow very flexible architectures to be mapped with a DI container.": "Da es bei DI um die Bereitstellung von Abhängigkeiten geht, wird der Container mit den Abhängigkeiten versehen, daher der technische Begriff \"Provider\". Es gibt verschiedene Arten von Providern: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Alle zusammen erlauben es, sehr flexible Architekturen mit einem DI-Container abzubilden.",
        "All dependencies between providers are automatically resolved and as soon as an `injector.get()` call occurs, the objects and dependencies are created, cached, and correctly passed either as a constructor argument (which is known as constructor injection), set as a property (which is known as property injection), or passed to a method call (which is known as method injection).": "Alle Abhängigkeiten zwischen Anbietern werden automatisch aufgelöst, und sobald ein `injector.get()`-Aufruf erfolgt, werden die Objekte und Abhängigkeiten erstellt, zwischengespeichert und korrekt übergeben, entweder als Konstruktorargument (bekannt als Konstruktorinjektion), als Eigenschaft (bekannt als Eigenschaftsinjektion) oder an einen Methodenaufruf (bekannt als Methodeninjektion).",
        "Now to exchange the HttpClient with another one, another provider (here the ValueProvider) can be defined for HttpClient:": "Um nun den HttpClient mit einem anderen auszutauschen, kann ein weiterer Provider (hier der ValueProvider) für den HttpClient definiert werden:",
        "As soon as UserRepository is requested via `injector.get(UserRepository)`, it receives the AnotherHttpClient object. Alternatively, a ClassProvider can be used here very well, so that all dependencies of AnotherHttpClient are also managed by the DI container.": "Sobald das UserRepository über `injector.get(UserRepository)` angefordert wird, erhält es das AnotherHttpClient-Objekt. Alternativ kann hier auch sehr gut ein ClassProvider verwendet werden, so dass alle Abhängigkeiten des AnotherHttpClient ebenfalls vom DI-Container verwaltet werden.",
        "All types of providers are listed and explained in the xref:dependency-injection.adoc#di-providers[Dependency Injection Providers] section.": "Alle Arten von Providern sind im Abschnitt xref:dependency-injection.adoc#di-providers[Dependency Injection Providers] aufgeführt und erläutert.",
        "It should be mentioned here that Deepkit's DI container only works with Deepkit's runtime types. This means that any code that contains classes, types, interfaces, and functions must be compiled by the Deepkit Type Compiler in order to have the type information available at runtime. See the chapter xref:runtime-types.adoc[Runtime Types].": "An dieser Stelle sollte erwähnt werden, dass der DI-Container von Deepkit nur mit den Laufzeittypen von Deepkit funktioniert. Das bedeutet, dass jeder Code, der Klassen, Typen, Schnittstellen und Funktionen enthält, vom Deepkit Type Compiler kompiliert werden muss, damit die Typinformationen zur Laufzeit verfügbar sind. Siehe das Kapitel xref:runtime-types.adoc[Runtime Types].",
        "Dependency Inversion": "Inversion von Abhängigkeiten",
        "The example of UserRepository under Inversion of Control shows that UserRepository depends on a lower level HTTP library. In addition, a concrete implementation (class) is declared as a dependency instead of an abstraction (interface). At first glance, this may seem to be in line with the object-oriented paradigms, but it can lead to problems, especially in complex and large architectures.": "Das Beispiel von UserRepository unter Inversion of Control zeigt, dass UserRepository von einer untergeordneten HTTP-Bibliothek abhängt. Außerdem wird eine konkrete Implementierung (Klasse) als Abhängigkeit deklariert und nicht eine Abstraktion (Schnittstelle). Auf den ersten Blick scheint dies den objektorientierten Paradigmen zu entsprechen, kann aber insbesondere in komplexen und großen Architekturen zu Problemen führen.",
        "An alternative variant would be to convert the HttpClient dependency into an abstraction (interface) and thus not import code from an HTTP library into UserRepository.": "Eine alternative Variante wäre, die HttpClient-Abhängigkeit in eine Abstraktion (Schnittstelle) umzuwandeln und somit keinen Code aus einer HTTP-Bibliothek in UserRepository zu importieren.",
        "This is called the dependency inversion principle. UserRepository no longer has a dependency directly on an HTTP library and is instead based on an abstraction (interface). It thus solves two fundamental goals in this principle:": "Dies wird als Prinzip der Abhängigkeitsumkehr bezeichnet. UserRepository ist nicht mehr direkt von einer HTTP-Bibliothek abhängig und basiert stattdessen auf einer Abstraktion (Schnittstelle). Damit löst es zwei grundlegende Ziele dieses Prinzips:",
        "High-level modules should not import anything from low-level modules.": "High-Level-Module sollten keine Inhalte von Low-Level-Modulen importieren.",
        "Implementations should be based on abstractions (interfaces).": "Die Implementierungen sollten auf Abstraktionen (Schnittstellen) beruhen.",
        "Merging the two implementations (UserRepository with an HTTP library) can now be done via the DI container.": "Die Zusammenführung der beiden Implementierungen (UserRepository mit einer HTTP-Bibliothek) kann nun über den DI-Container erfolgen.",
        "Since Deepkit's DI container is capable of resolving abstract dependencies (interfaces) such as this one of HttpClientInterface, UserRepository automatically gets the implementation of HttpClient since HttpClient implemented the interface HttpClientInterface. This is done either by HttpClient specifically implementing HttpClientInterface (`class HttpClient implements HttpClientInterface`), or by HttpClient's API simply being compatible with HttpClientInterface.": "Da der DI-Container von Deepkit in der Lage ist, abstrakte Abhängigkeiten (Schnittstellen) wie die von HttpClientInterface aufzulösen, erhält UserRepository automatisch die Implementierung von HttpClient, da HttpClient die Schnittstelle HttpClientInterface implementiert. Dies geschieht entweder durch HttpClient speziell implementiert HttpClientInterface (`class HttpClient implementiert HttpClientInterface`), oder durch HttpClient's API einfach kompatibel mit HttpClientInterface ist.",
        "As soon as HttpClient modifies its API (for example, removes the `get` method) and is thus no longer compatible with HttpClientInterface, the DI container throws an error (\"the HttpClientInterface dependency was not provided\").": "Sobald HttpClient seine API ändert (z. B. die Methode `get` entfernt) und damit nicht mehr mit HttpClientInterface kompatibel ist, wirft der DI-Container einen Fehler (\"die HttpClientInterface-Abhängigkeit wurde nicht bereitgestellt\").",
        "Here the user, who wants to bring both implementations together, is in the obligation to find a solution. As an example, an adapter class could be registered here that implements HttpClientInterface and correctly forwards the method calls to HttpClient.": "Hier ist der Anwender, der beide Implementierungen zusammenbringen will, in der Pflicht, eine Lösung zu finden. Als Beispiel könnte hier eine Adapterklasse registriert werden, die das HttpClientInterface implementiert und die Methodenaufrufe korrekt an den HttpClient weiterleitet.",
        "It should be noted here that although in theory the dependency inversion principle has its advantages, in practice it also has significant disadvantages. It not only leads to more code (since more interfaces have to be written), but also to more complexity (since each implementation now has an interface for each dependency). This price to pay is only worth it when the application reaches a certain size and this flexibility is needed. Like any design pattern and principle, this one has its cost-use factor, which should be thought through before it is applied.": "An dieser Stelle sei angemerkt, dass das Prinzip der Abhängigkeitsinversion zwar in der Theorie seine Vorteile hat, in der Praxis aber auch erhebliche Nachteile mit sich bringt. Es führt nicht nur zu mehr Code (da mehr Schnittstellen geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung nun eine Schnittstelle für jede Abhängigkeit hat). Dieser Preis lohnt sich erst, wenn die Anwendung eine gewisse Größe erreicht und diese Flexibilität benötigt wird. Wie jedes Entwurfsmuster und Prinzip hat auch dieses seinen Kosten-Nutzen-Faktor, der vor seiner Anwendung durchdacht werden sollte.",
        "Design patterns should not be used blindly and across the board for even the simplest code. However, if the prerequisites such as a complex architecture, large applications, or a scaling team are given, dependency inversion and other design patterns only unfold their true strength.": "Entwurfsmuster sollten auch bei einfachstem Code nicht blind und pauschal eingesetzt werden. Wenn jedoch die Voraussetzungen wie eine komplexe Architektur, große Anwendungen oder ein skalierendes Team gegeben sind, entfalten Abhängigkeitsinversion und andere Entwurfsmuster erst ihre wahre Stärke.",
        "Since Dependency Injection in Deepkit is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Da Dependency Injection in Deepkit auf Runtime Types basiert, ist es notwendig, dass `@deepkit/type` bereits korrekt installiert ist. Siehe xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "If this is done successfully, `@deepkit/injector` can be installed by itself or the Deepkit framework which already uses the library under the hood.": "Wenn dies erfolgreich durchgeführt wurde, kann `@deepkit/injector` selbst oder das Deepkit-Framework, das die Bibliothek bereits unter der Haube verwendet, installiert werden.",
        "Once the library is installed, the API of it can be used directly.": "Sobald die Bibliothek installiert ist, kann ihre API direkt verwendet werden.",
        "To use Dependency Injection now, there are three ways.": "Um Dependency Injection jetzt zu verwenden, gibt es drei Möglichkeiten.",
        "Injector API (Low Level)": "Injektor-API (niedrige Stufe)",
        "Module API": "Modul-API",
        "App API (Deepkit Framework)": "Anwendungs-API (Deepkit-Framework)",
        "If `@deepkit/injector` is to be used without the deepkit framework, the first two variants are recommended.": "Wenn `@deepkit/injector` ohne das deepkit-Framework verwendet werden soll, werden die ersten beiden Varianten empfohlen.",
        "Injector API": "Injektor-API",
        "The Injector API has already been introduced in the introduction to Dependency Injection. It is characterized by a very simple usage by means of a single class `InjectorContext` that creates a single DI container and is particularly suitable for simpler applications without modules.": "Die Injector API wurde bereits in der Einführung zur Dependency Injection vorgestellt. Sie zeichnet sich durch eine sehr einfache Verwendung mittels einer einzigen Klasse `InjectorContext` aus, die einen einzigen DI-Container erzeugt und sich besonders für einfachere Anwendungen ohne Module eignet.",
        "The `injector` object in this case is the dependency injection container. The function `InjectorContext.forProviders` takes an array of providers. See the section xref:dependency-injection.adoc#di-providers[Dependency Injection Providers] to learn which values can be passed.": "Das Objekt \"Injector\" ist in diesem Fall der Container für die Injektion von Abhängigkeiten. Die Funktion `InjectorContext.forProviders` nimmt ein Array von Providern entgegen. Welche Werte übergeben werden können, erfahren Sie im Abschnitt xref:dependency-injection.adoc#di-providers[Dependency Injection Providers].",
        "A more complex API is the `InjectorModule` class, which allows to store the providers in different modules to create multiple encapsulated DI containers per module. Also this allows using configuration classes per module, which makes it easier to provide configuration values automatically validated to the providers. Modules can import themselves among themselves, providers export, in order to build up so a hierarchy and nicely separated architecture.": "Eine komplexere API ist die Klasse \"InjectorModule\", die es ermöglicht, die Provider in verschiedenen Modulen zu speichern, um mehrere gekapselte DI-Container pro Modul zu erstellen. Dies erlaubt auch die Verwendung von Konfigurationsklassen pro Modul, was es einfacher macht, den Providern automatisch validierte Konfigurationswerte zur Verfügung zu stellen. Module können sich untereinander importieren, Provider exportieren, um so eine hierarchische und sauber getrennte Architektur aufzubauen.",
        "This API should be used if the application is more complex and the Deepkit framework is not used.": "Diese API sollte verwendet werden, wenn die Anwendung komplexer ist und das Deepkit-Framework nicht verwendet wird.",
        "The `injector` object in this case is the dependency injection container. Providers can be split into different modules and then imported again in different places using module imports. This creates a natural hierarchy that reflects the hierarchy of the application or architecture.": "Das Objekt \"Injector\" ist in diesem Fall der Container für die Injektion von Abhängigkeiten. Anbieter können in verschiedene Module aufgeteilt und dann an verschiedenen Stellen durch Modulimporte wieder importiert werden. So entsteht eine natürliche Hierarchie, die die Hierarchie der Anwendung oder Architektur widerspiegelt.",
        "The InjectorContext should always be given the top module in the hierarchy, also called root module or app module. The InjectorContext then only has an intermediary role: calls to `injector.get()` are simply forwarded to the root module. However, it is also possible to get providers from non-root modules by passing the module as a second argument.": "Der InjectorContext sollte immer dem obersten Modul in der Hierarchie, auch Root-Modul oder App-Modul genannt, zugeordnet werden. Der InjectorContext hat dann nur eine vermittelnde Rolle: Aufrufe von `injector.get()` werden einfach an das Wurzelmodul weitergeleitet. Es ist jedoch auch möglich, Provider von Nicht-Wurzelmodulen zu erhalten, indem das Modul als zweites Argument übergeben wird.",
        "All non-root modules are encapsulated by default, so that all providers in this module are only available to itself. If a provider is to be available to other modules, this provider must be exported. By exporting, the provider moves to the parent module of the hierarchy and can be used that way.": "Alle Nicht-Wurzelmodule sind standardmäßig gekapselt, so dass alle Anbieter in diesem Modul nur für sich selbst verfügbar sind. Wenn ein Anbieter für andere Module verfügbar sein soll, muss er exportiert werden. Durch den Export wandert der Anbieter in das übergeordnete Modul der Hierarchie und kann auf diese Weise verwendet werden.",
        "To export all providers by default to the top level, the root module, the option `forRoot` can be used. This allows all providers to be used by all other modules.": "Um alle Anbieter standardmäßig auf die oberste Ebene, das Root-Modul, zu exportieren, kann die Option `forRoot` verwendet werden. Dadurch können alle Anbieter von allen anderen Modulen verwendet werden.",
        "App API": "App-API",
        "Once the Deepkit framework is used, modules are defined with the `@deepkit/app` API. This is based on the Module API, so the capabilities from there are also available. In addition, it is possible to work with powerful hooks and define configuration loaders to map even more dynamic architectures.": "Sobald das Deepkit-Framework verwendet wird, werden Module mit der API \"@deepkit/app\" definiert. Diese basiert auf der Modul-API, so dass die dortigen Möglichkeiten ebenfalls zur Verfügung stehen. Darüber hinaus ist es möglich, mit leistungsfähigen Hooks zu arbeiten und Konfigurationslader zu definieren, um noch dynamischere Architekturen abzubilden.",
        "The xref:framework.adoc#framework-modules[Framework Modules] chapter describes this in more detail.": "Das Kapitel xref:framework.adoc#framework-modules[Framework-Module] beschreibt dies ausführlicher.",
        "Providers": "Anbieter",
        "There are several ways to provide dependencies in the Dependency Injection container. The simplest variant is simply the specification of a class. This is also known as short ClassProvider.": "Es gibt mehrere Möglichkeiten, Abhängigkeiten im Dependency Injection Container bereitzustellen. Die einfachste Variante ist einfach die Angabe einer Klasse. Dies ist auch als kurzer ClassProvider bekannt.",
        "This represents a special provider, since only the class is specified. All other providers must be specified as object literals.": "Dies ist ein besonderer Anbieter, da nur die Klasse angegeben wird. Alle anderen Anbieter müssen als Objektliterale angegeben werden.",
        "By default, all providers are marked as singletons, so only one instance exists at any given time. To create a new instance each time a provider is deployed, the `transient` option can be used. This will cause classes to be recreated each time or factories to be executed each time.": "Standardmäßig sind alle Anbieter als Singletons gekennzeichnet, so dass immer nur eine Instanz existiert. Um jedes Mal, wenn ein Anbieter bereitgestellt wird, eine neue Instanz zu erstellen, kann die Option \"transient\" verwendet werden. Dies führt dazu, dass die Klassen jedes Mal neu erstellt oder die Fabriken jedes Mal ausgeführt werden.",
        "ClassProvider": "ClassProvider",
        "Besides the short ClassProvider there is also the regular ClassProvider, which is an object literal instead of a class.": "Neben dem kurzen ClassProvider gibt es auch den regulären ClassProvider, der ein Objektliteral anstelle einer Klasse ist.",
        "This is equivalent to these two:": "Dies ist gleichbedeutend mit diesen beiden:",
        "It can be used to exchange a provider with another class.": "Sie kann verwendet werden, um einen Anbieter mit einer anderen Klasse auszutauschen.",
        "In this example, the `OtherUserRepository` class is now also managed in the DI container and all its dependencies are resolved automatically.": "In diesem Beispiel wird die Klasse \"OtherUserRepository\" nun auch im DI-Container verwaltet und alle ihre Abhängigkeiten werden automatisch aufgelöst.",
        "ValueProvider": "ValueProvider",
        "Static values can be provided with this provider.": "Mit diesem Anbieter können statische Werte bereitgestellt werden.",
        "Since not only class instances can be provided as dependencies, any value can be specified as `useValue`. A symbol or a primitive (string, number, boolean) could also be used as a provider token.": "Da nicht nur Klasseninstanzen als Abhängigkeiten bereitgestellt werden können, kann jeder beliebige Wert als \"useValue\" angegeben werden. Ein Symbol oder ein Primitivum (String, Zahl, Boolean) kann ebenfalls als Provider-Token verwendet werden.",
        "Primitive provider tokens must be declared with the Inject type as a dependency.": "Primitive Anbieter-Token müssen mit dem Inject-Typ als Abhängigkeit deklariert werden.",
        "The combination of an inject alias and primitive provider tokens can also be used to provide dependencies from packages that do not contain runtime type information.": "Die Kombination aus einem Inject-Alias und primitiven Provider-Tokens kann auch verwendet werden, um Abhängigkeiten von Paketen bereitzustellen, die keine Laufzeittypinformationen enthalten.",
        "And then declared on the user side as follows:": "Und dann auf der Benutzerseite wie folgt deklariert:",
        "ExistingProvider": "ExistingProvider",
        "A forwarding to an already defined provider can be defined.": "Es kann eine Weiterleitung zu einem bereits definierten Provider definiert werden.",
        "FactoryProvider": "FactoryProvider",
        "A function can be used to provide a value for the provider. This function can also contain parameters, which in turn are provided by the DI container. Thus, other dependencies or configuration options are accessible.": "Eine Funktion kann verwendet werden, um einen Wert für den Anbieter bereitzustellen. Diese Funktion kann auch Parameter enthalten, die ihrerseits vom DI-Container bereitgestellt werden. So sind weitere Abhängigkeiten oder Konfigurationsoptionen zugänglich.",
        "InterfaceProvider": "InterfaceProvider",
        "In addition to classes and primitives, abstractions (interfaces) can also be provided. This is done via the function `provide` and is particularly useful if the value to be provided does not contain any type information.": "Zusätzlich zu Klassen und Primitiven können auch Abstraktionen (Schnittstellen) bereitgestellt werden. Dies geschieht über die Funktion `provide` und ist besonders nützlich, wenn der zu liefernde Wert keine Typinformationen enthält.",
        "If multiple providers have implemented the Connection interface, the last provider is used.": "Wenn mehrere Anbieter die Verbindungsschnittstelle implementiert haben, wird der letzte Anbieter verwendet.",
        "As argument for provide() all other providers are possible.": "Als Argument für provide() sind alle anderen Anbieter möglich.",
        "Asynchronous Providers": "Asynchrone Anbieter",
        "The design of `@deepkit/injector` precludes the use of asynchronous providers with an asynchronous Dependency Injection container. This is because requesting providers would also need to be asynchronous, necessitating the entire application to operate at the highest level asynchronously.": "Das Design von `@deepkit/injector` schließt die Verwendung von asynchronen Providern mit einem asynchronen Dependency Injection Container aus. Der Grund dafür ist, dass die anfordernden Anbieter ebenfalls asynchron sein müssten, wodurch die gesamte Anwendung auf höchster Ebene asynchron arbeiten müsste.",
        "To initialize something asynchronously, this initialization should be moved to the application server bootstrap,  because there the events can be asynchronous. Alternatively, an initialization can be triggered manually.": "Um etwas asynchron zu initialisieren, sollte diese Initialisierung in den Bootstrap des Anwendungsservers verlegt werden, da dort die Ereignisse asynchron sein können. Alternativ kann eine Initialisierung auch manuell ausgelöst werden.",
        "Constructor/Property Injection": "Konstruktor/Eigenschaftsinjektion",
        "In most cases, constructor injection is used. All dependencies are specified as constructor arguments and are automatically injected by the DI container.": "In den meisten Fällen wird die Konstruktorinjektion verwendet. Alle Abhängigkeiten werden als Konstruktorargumente angegeben und automatisch durch den DI-Container injiziert.",
        "Optional dependencies should be marked as such, otherwise an error could be triggered if no provider can be found.": "Optionale Abhängigkeiten sollten als solche gekennzeichnet werden, da sonst ein Fehler ausgelöst werden könnte, wenn kein Anbieter gefunden werden kann.",
        "An alternative to constructor injection is property injection. This is usually used when the dependency is optional or the constructor is otherwise too full. The properties are automatically assigned once the instance is created (and thus the constructor is executed).": "Eine Alternative zur Konstruktorinjektion ist die Eigenschaftsinjektion. Diese wird in der Regel verwendet, wenn die Abhängigkeit optional ist oder der Konstruktor ansonsten zu umfangreich ist. Die Eigenschaften werden automatisch zugewiesen, sobald die Instanz erstellt (und somit der Konstruktor ausgeführt) wurde.",
        "Configuration": "Konfiguration",
        "The dependency injection container also allows configuration options to be injected. This configuration injection can be received via constructor injection or property injection.": "Der Dependency Injection Container erlaubt auch die Injektion von Konfigurationsoptionen. Diese Konfigurationsinjektion kann über Konstruktorinjektion oder Eigenschaftsinjektion erfolgen.",
        "The Module API supports the definition of a configuration definition, which is a regular class. By providing such a class with properties, each property acts as a configuration option. Because of the way classes can be defined in TypeScript, this allows defining a type and default values per property.": "Die Modul-API unterstützt die Definition einer Konfigurationsdefinition, die eine reguläre Klasse ist. Wenn eine solche Klasse mit Eigenschaften versehen wird, fungiert jede Eigenschaft als eine Konfigurationsoption. Aufgrund der Art und Weise, wie Klassen in TypeScript definiert werden können, ermöglicht dies die Definition eines Typs und von Standardwerten pro Eigenschaft.",
        "The configuration options `domain` and `debug` can now be used quite conveniently type-safe in providers.": "Die Konfigurationsoptionen `domain` und `debug` können nun ganz bequem typsicher in Providern verwendet werden.",
        "The values of the options themselves can be set via `configure()`.": "Die Werte der Optionen selbst können über `configure()` gesetzt werden.",
        "Options that do not have a default value but are still necessary can be provided with a `!`. This forces the user of the module to provide the value, otherwise an error will occur.": "Optionen, die keinen Standardwert haben, aber dennoch notwendig sind, können mit einem `!` versehen werden. Dies zwingt den Benutzer des Moduls, den Wert anzugeben, andernfalls tritt ein Fehler auf.",
        "Also, all serialization and validation types from the previous chapters xref:validation.adoc[Validation] and xref:serialization.adoc[Serialization] can be used to specify in great detail what type and content restrictions an option must have.": "Außerdem können alle Serialisierungs- und Validierungstypen aus den vorangegangenen Kapiteln xref:validation.adoc[Validierung] und xref:serialization.adoc[Serialisierung] verwendet werden, um sehr detailliert anzugeben, welche Typ- und Inhaltsbeschränkungen eine Option haben muss.",
        "Injection": "Einspritzung",
        "Configuration options, like other dependencies, can be safely and easily injected through the DI container as shown earlier. The simplest method is to reference a single option using the index access operator:": "Konfigurationsoptionen können wie andere Abhängigkeiten sicher und einfach durch den DI-Container injiziert werden, wie zuvor gezeigt. Die einfachste Methode ist der Verweis auf eine einzelne Option mit Hilfe des Indexzugriffsoperators:",
        "Configuration options can be referenced not only individually, but also as a group. The TypeScript utility type `Partial` is used for this purpose:": "Konfigurationsoptionen können nicht nur einzeln, sondern auch als Gruppe referenziert werden. Zu diesem Zweck wird der TypeScript-Dienstprogrammtyp `Partial` verwendet:",
        "To get all configuration options, the configuration class can also be referenced directly:": "Um alle Konfigurationsoptionen zu erhalten, kann die Konfigurationsklasse auch direkt referenziert werden:",
        "However, it is recommended to reference only the configuration options that are actually used. This not only simplifies unit tests, but also makes it easier to see what is actually needed from the code.": "Es wird jedoch empfohlen, nur auf die Konfigurationsoptionen zu verweisen, die tatsächlich verwendet werden. Dies vereinfacht nicht nur die Unit-Tests, sondern macht es auch einfacher zu erkennen, was im Code tatsächlich benötigt wird.",
        "Scopes": "Geltungsbereiche",
        "By default, all providers of the DI container are singletons and are therefore instantiated only once. This means that in the example of UserRepository there is always only one instance of UserRepository during the entire runtime. At no time is a second instance created, unless the user does this manually with the \"new\" keyword.": "Standardmäßig sind alle Provider des DI-Containers Singletons und werden daher nur einmal instanziiert. Das bedeutet, dass es im Beispiel des UserRepository während der gesamten Laufzeit immer nur eine Instanz des UserRepository gibt. Zu keinem Zeitpunkt wird eine zweite Instanz erzeugt, es sei denn, der Benutzer tut dies manuell mit dem Schlüsselwort \"new\".",
        "However, there are various use cases where a provider should only be instantiated for a short time or only during a certain event. Such an event could be, for example, an HTTP request or an RPC call. This would mean that a new instance is created for each event and after this instance is no longer used it is automatically removed (by the garbage collector).": "Es gibt jedoch verschiedene Anwendungsfälle, in denen ein Anbieter nur für kurze Zeit oder nur während eines bestimmten Ereignisses instanziiert werden soll. Ein solches Ereignis könnte z. B. eine HTTP-Anfrage oder ein RPC-Aufruf sein. Dies würde bedeuten, dass für jedes Ereignis eine neue Instanz erstellt wird und diese Instanz, nachdem sie nicht mehr verwendet wird, automatisch (durch den Garbage Collector) entfernt wird.",
        "An HTTP request is a classic example of a scope. For example, providers such as a session, a user object, or other request-related providers can be registered to this scope. To create a scope, simply choose an arbitrary scope name and then specify it with the providers.": "Eine HTTP-Anfrage ist ein klassisches Beispiel für einen Bereich. In diesem Bereich können z. B. Anbieter wie eine Sitzung, ein Benutzerobjekt oder andere anfragebezogene Anbieter registriert werden. Um einen Bereich zu erstellen, wählen Sie einfach einen beliebigen Bereichsnamen und geben ihn dann mit den Anbietern an.",
        "Once a scope is specified, this provider cannot be obtained directly from the DI container, so the following call will fail:": "Sobald ein Bereich angegeben ist, kann dieser Anbieter nicht direkt vom DI-Container bezogen werden, so dass der folgende Aufruf fehlschlägt:",
        "Instead, a scoped DI container must be created. This would happen every time an HTTP request comes in:": "Stattdessen muss ein scoped DI-Container erstellt werden. Dies würde jedes Mal geschehen, wenn eine HTTP-Anforderung eingeht:",
        "Providers that are also registered in this scope can now be requested on this scoped DI container, as well as all providers that have not defined a scope.": "Anbieter, die ebenfalls in diesem Geltungsbereich registriert sind, können nun auf diesem DI-Container mit Geltungsbereich angefragt werden, ebenso wie alle Anbieter, die keinen Geltungsbereich definiert haben.",
        "Since all providers are singleton by default, each call to `get(UserSession)` will always return the same instance per scoped container. If you create multiple scoped containers, multiple UserSessions will be created.": "Da alle Anbieter standardmäßig Singletons sind, gibt jeder Aufruf von \"get(UserSession)\" immer dieselbe Instanz pro Container zurück. Wenn Sie mehrere \"scoped\" Container erstellen, werden auch mehrere UserSessions erstellt.",
        "Scoped DI containers have the ability to set values dynamically from the outside. For example, in an HTTP scope, it is easy to set the HttpRequest and HttpResponse objects.": "Scoped-DI-Container haben die Möglichkeit, Werte dynamisch von außen zu setzen. In einem HTTP-Bereich ist es beispielsweise einfach, die Objekte HttpRequest und HttpResponse zu setzen.",
        "Applications using the Deepkit framework have by default an `http`, an `rpc`, and a `cli` scope. See respectively the chapter xref:cli.adoc[CLI], xref:http.adoc[HTTP], or xref:rpc.adoc[RPC].": "Anwendungen, die das Deepkit-Framework verwenden, haben standardmäßig einen `http`, einen `rpc` und einen `cli`-Bereich. Siehe jeweils das Kapitel xref:cli.adoc[CLI], xref:http.adoc[HTTP] oder xref:rpc.adoc[RPC].",
        "Setup Calls": "Anrufe einrichten",
        "Setup calls allow to manipulate the result of a provider. This is useful for example to use another dependency injection variant, the method injection.": "Setup-Aufrufe ermöglichen es, das Ergebnis eines Anbieters zu manipulieren. Dies ist zum Beispiel nützlich, um eine andere Variante der Dependency Injection, die Methodeninjektion, zu verwenden.",
        "Setup calls can only be used with the module API or the app API and are registered above the module.": "Setup-Aufrufe können nur mit der Modul-API oder der App-API verwendet werden und werden oberhalb des Moduls registriert.",
        "The `setupProvider` method thereby returns a proxy object of UserRepository on which its methods can be called. It should be noted that these method calls are merely placed in a queue and are not executed at this time. Accordingly, no return value is returned.": "Die Methode `setupProvider` gibt dabei ein Proxy-Objekt von UserRepository zurück, auf dem dessen Methoden aufgerufen werden können. Es ist zu beachten, dass diese Methodenaufrufe lediglich in eine Warteschlange gestellt werden und zu diesem Zeitpunkt nicht ausgeführt werden. Dementsprechend wird auch kein Rückgabewert zurückgegeben.",
        "In addition to method calls, properties can also be set.": "Zusätzlich zu den Methodenaufrufen können auch Eigenschaften festgelegt werden.",
        "This assignment is also simply placed in a queue.": "Auch dieser Auftrag wird einfach in eine Warteschlange gestellt.",
        "The calls or the assignments in the queue are then executed on the actual result of the provider as soon as this is created. That is with a ClassProvider these are applied to the class instance, as soon as the instance is created, with a FactoryProvider on the result of the Factory, and with a ValueProvider on the Provider.": "Die Aufrufe bzw. die Zuweisungen in der Warteschlange werden dann auf das eigentliche Ergebnis des Providers ausgeführt, sobald dieses erstellt ist. D.h. bei einem ClassProvider werden diese auf die Klasseninstanz angewendet, sobald die Instanz erstellt ist, bei einem FactoryProvider auf das Ergebnis der Factory und bei einem ValueProvider auf den Provider.",
        "To reference not only static values, but also other providers, the function `injectorReference` can be used. This function returns a reference to a provider, which is also requested by the DI container when the setup calls are executed.": "Um nicht nur statische Werte, sondern auch andere Provider zu referenzieren, kann die Funktion `injectorReference` verwendet werden. Diese Funktion gibt einen Verweis auf einen Provider zurück, der auch vom DI-Container angefordert wird, wenn die Setup-Aufrufe ausgeführt werden.",
        "*Abstractions/Interfaces*": "*Abstraktionen/Schnittstellen*",
        "Setup calls can also be assigned to an interface.": "Einrichtungsanrufe können auch einer Schnittstelle zugewiesen werden.",
        "Event System": "Event System",
        "Ein Event-System ermöglicht es Anwendungskomponenten im selben Prozess miteinander zu kommunizieren, indem sie Ereignisse versenden und auf sie hören. Es hilft bei der Modularisierung des Codes, indem Nachrichten zwischen Funktionen gesendet werden, die nicht direkt voneinander wissen.": "Ein Event-System ermöglicht es Anwendungskomponenten im selben Prozess miteinander zu kommunizieren, indem sie Ereignisse versenden und auf sie hören. Es hilft bei der Modularisierung des Codes, indem Nachrichten zwischen Funktionen gesendet werden, die nicht direkt voneinander wissen.",
        "Die Anwendung oder Library eröffnet dabei die Möglichkeit an einem bestimmten Zeitpunkt der Ausführung zusätzliche Funktionen auszuführen. Diese zusätzlichen Funktionen registrieren sich dabei selbst als sogenannte Event-Listener.": "Die Anwendung oder Bibliothek eröffnet dabei die Möglichkeit, an einem bestimmten Zeitpunkt der Ausführung zusätzliche Funktionen auszuführen. Diese zusätzlichen Funktionen registrieren sich dabei selbst als sogenannte Event-Listener.",
        "Ein Event kann dabei vielfältig sein:": "Ein Event kann dabei vielfältig sein:",
        "Die Anwendung fährt hoch oder runter.": "Die Anwendung fährt hoch oder runter.",
        "Ein neuer User wurde erstellt oder gelöscht.": "Ein neuer Benutzer wurde erstellt oder gelöscht.",
        "Eine Error wurde geworfen.": "Ein Fehler wurde geworfen.",
        "Ein neuer HTTP-Request ist hereingekommen.": "Ein neuer HTTP-Request ist eingetroffen.",
        "Deepkit Framework und seine Libraries bieten bereits diverse Events an, auf die der Benutzer hören und reagieren kann. Es können jedoch auch beliebig viele eigene Events angelegt werden, um so die Anwendung modular erweiterbar zu machen.": "Deepkit Framework und seine Libraries bieten bereits diverse Events an, auf die der Benutzer hören und reagieren kann. Es können jedoch auch beliebig viele eigene Events angelegt werden, um so die Anwendung modular erweiterbar zu machen.",
        "Nachfolgend ein Beispiel der Low-Level API von `@deepkit/event`. Wenn Deepkit Framework genutzt wird, geschieht die Registrierung von Event-Listener nicht über `EventDispatcher` direkt sondern über Module.": "Nachfolgend ein Beispiel der Low-Level API von `@deepkit/event`. Wenn Deepkit Framework genutzt wird, geschieht die Registrierung von Event-Listener nicht über `EventDispatcher` direkt sondern über Module.",
        "Da das Event-System von Deepkit basiert auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Da das Event-System von Deepkit auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/event` installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "Falls dies erfolgreich geschehen ist, kann `@deepkit/event` installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.",
        "Zu beachten ist, dass `@deepkit/event` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller API verwendet wird.": "Zu beachten ist, dass `@deepkit/event` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller API verwendet wird.",
        "Sobald die Library installiert ist, kann die API davon direkt benutzt werden.": "Sobald die Bibliothek installiert ist, kann die API davon direkt benutzt werden.",
        "Event Token": "Ereignis-Token",
        "Im Mittelpunkt vom Event-System stehen die Event-Tokens. Sie sind Objekte, die die eindeutige Event-ID und den Event-Typen definieren. Über ein Event-Token kann ein Event ausgelöst und auf ein Event gehört werden. Dabei ist konzeptionell derjenige, der den Event eines Event-Tokens auslöst, auch der Besitzer dieses Event-Tokens. Das Event-Token entscheidet entsprechend darüber, welche Daten an dem Event verfügbar sind und ob asynchrone Event-Listener erlaubt werden.": "Im Mittelpunkt vom Event-System stehen die Event-Tokens. Sie sind Objekte, die die eindeutige Event-ID und den Event-Typen definieren. Über einen Event-Token kann ein Event ausgelöst und auf ein Event gehört werden. Dabei ist konzeptionell derjenige, der den Event eines Event-Tokens auslöst, auch der Besitzer dieses Event-Tokens. Das Event-Token entscheidet entsprechend darüber, welche Daten an dem Event verfügbar sind und ob asynchrone Event-Listener erlaubt werden.",
        "TODO asynchrone": "TODO asynchrone",
        "Event Types": "Ereignis-Typen",
        "Propagation": "Ausbreitung",
        "TODO. event.stop()": "TODO. event.stop()",
        "CLI": "CLI",
        "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Text-Eingabe und Text-Ausgabe interagieren. Der Vorteil in dieser Variante mit der Anwendung zu interagieren, ist, dass lediglich ein Terminal entweder lokal oder über eine SSH-Verbindung bestehen muss.": "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Text-Eingabe und Text-Ausgabe interagieren. Der Vorteil in dieser Variante mit der Anwendung zu interagieren, ist, dass lediglich ein Terminal entweder lokal oder über eine SSH-Verbindung bestehen muss.",
        "Eine CLI-Anwendung in Deepkit hat den vollen Zugriff auf den DI-Container und kann so auf alle Provider und Konfigurationsoptionen zugreifen.": "Eine CLI-Anwendung in Deepkit hat den vollen Zugriff auf den DI-Container und kann so auf alle Provider und Konfigurationsoptionen zugreifen.",
        "Die Argumente und Optionen der CLI-Anwendung werden über Methoden-Parameter via TypeScript Typen gesteuert und werden automatisch serialisiert und validiert.": "Die Argumente und Optionen der CLI-Anwendung werden über Methoden-Parameter via TypeScript Typen gesteuert und werden automatisch serialisiert und validiert.",
        "CLI ist einer von drei Einstiegspunkten zu einer Deepkit Framework Anwendung. Im Deepkit Framework wird die Anwendung immer über ein CLI-Program gestartet, das selbst vom User in TypeScript geschrieben ist. Es gibt daher keine Deepkit spezifisches globales CLI tool, um eine Deepkit Anwendung zu starten. Auf diese Weise starten Sie den HTTP/RPC-Server, führen Migrationen aus oder führen eigene Befehle aus. Das alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` benutzt wird, erhält die Anwendung zusätzliche Commands für den Application Server, Migrations, und mehr.": "CLI ist einer von drei Einstiegspunkten zu einer Deepkit Framework Anwendung. Im Deepkit Framework wird die Anwendung immer über ein CLI-Programm gestartet, das selbst vom Anwender in TypeScript geschrieben ist. Es gibt daher kein Deepkit-spezifisches globales CLI-Tool, um eine Deepkit-Anwendung zu starten. Auf diese Weise starten Sie den HTTP/RPC-Server, führen Migrationen aus oder führen eigene Befehle aus. Das alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` benutzt wird, erhält die Anwendung zusätzliche Befehle für den Application Server, Migrationen, und mehr.",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Decorators, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Decorators, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel xref:dependency-injection.adoc[Dependency Injection] für weitere Details.": "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel xref:dependency-injection.adoc[Dependency Injection] für weitere Details.",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Falls dies erfolgreich geschehen ist, kann @deepkit/app installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "Falls dies erfolgreich geschehen ist, kann @deepkit/app installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.",
        "Zu beachten ist, dass `@deepkit/app` auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss.": "Zu beachten ist, dass `@deepkit/app` auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss.",
        "Benutzung": "Benutzung",
        "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen. Dabei handelt es sich um eine einfache Klasse, die eine Methode `exeecute` hat und mit Informationen über den Befehl ausgestattet ist.": "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen. Dabei handelt es sich um eine einfache Klasse, die eine Methode `execute` hat und mit Informationen über den Befehl ausgestattet ist.",
        "_File: app.ts_": "_Datei: app.ts_",
        "In dem Decorator `@cli.controller` wird als erstes Argument der eindeutige Name der CLI-Anwendung definiert. Weitere Optionen wie eine Beschreibung können im Objekt an der zweiten Stelle optional hinzufügt werden.": "In dem Decorator `@cli.controller` wird als erstes Argument der eindeutige Name der CLI-Anwendung definiert. Weitere Optionen wie eine Beschreibung können im Objekt an der zweiten Stelle optional hinzufügt werden.",
        "Dieser Code ist bereits eine komplette CLI-Anwendung und kann so gestartet werden:": "Dieser Code ist bereits eine komplette CLI-Anwendung und kann so gestartet werden:",
        "Zu sehen ist, dass ein \"test\" Command verfügbar ist. Um dieses auszuführen, muss der Name als Argument übergeben werden:": "Zu sehen ist, dass ein \"test\"-Befehl verfügbar ist. Um dies auszuführen, muss der Name als Argument übergeben werden:",
        "Es ist auch möglich, die Datei mittels `chmod +x app.ts` ausführbar zu machen, sodass der Command `./app.ts` bereits ausreicht, um es zu starten. Zu beachten ist, dass dann ein sogenannter": "Es ist auch möglich, die Datei mittels `chmod +x app.ts` ausführbar zu machen, sodass der Befehl `./app.ts` bereits ausreicht, um es zu starten. Zu beachten ist, dass dann ein sogenannter",
        "Shebang notwendig ist. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. In dem Beispiel oben ist dies bereits vorhanden: `&#35;!/usr/bin/env ts-node-script` und nutzt den Skript-Modus von `ts-node`.": "Shebang ist notwendig. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. In dem Beispiel oben ist dies bereits vorhanden: `&#35;!/usr/bin/env ts-node-script` und nutzt den Skript-Modus von `ts-node`.",
        "Auf diese Weise können beliebig viele Commands erstellt und registriert werden. Der in `@cli.controller` angegeben eindeutige Name sollte gut gewählt werden und erlaubt das Gruppieren von Commands mit dem `:` Zeichen (z.B. `user:create`, `user:remove`, etc).": "Auf diese Weise können beliebig viele Commands erstellt und registriert werden. Der in `@cli.controller` angegebene eindeutige Name sollte gut gewählt werden und erlaubt das Gruppieren von Commands mit dem `:` Zeichen (z.B. `user:create`, `user:remove`, etc).",
        "Argumente": "Argumente",
        "Um Argumente hinzuzufügen, werden neue Parameter auf die Methode `execute` hinzugefügt und mit dem Decorator `@arg` dekoriert.": "Um Argumente hinzuzufügen, werden neue Parameter auf die Methode `execute` hinzugefügt und mit dem Decorator `@arg` dekoriert.",
        "Wenn Sie diesen Befehl jetzt ausführen, ohne einen Namen anzugeben, wird ein Fehler ausgegeben:": "Wenn Sie diesen Befehl jetzt ausführen, ohne einen Namen anzugeben, wird ein Fehler ausgegeben:",
        "Durch die Verwendung von `--help` erhalten Sie weitere Informationen über die erforderlichen Argumente:": "Durch die Verwendung von `--help` erhalten Sie weitere Informationen über die erforderlichen Argumente:",
        "Sobald der Name als Argument übergeben wird, wird die Methode `execute` in TestCommand ausgeführt und der Name korrekt übergeben.": "Sobald der Name als Argument übergeben wird, wird die Methode `execute` in TestCommand ausgeführt und der Name korrekt übergeben.",
        "Flags": "Flaggen",
        "Flags sind eine weitere Möglichkeit, Ihrem Befehl Werte zu übergeben. Meist sind diese Optional, doch müssen es nicht sein. Parameter, die mit `@flag name` dekoriert sind, können via `--name value` oder `--name=value` übergeben werden.": "Flaggen sind eine weitere Möglichkeit, Ihrem Befehl Werte zu übergeben. Meist sind diese Optional, doch müssen es nicht sein. Parameter, die mit `@flag name` dekoriert sind, können über `--name value` oder `--name=value` übergeben werden.",
        "In der Hilfe-Ansicht ist in den \"OPTIONS\" nun zu sehen, dass ein `--id` Flag notwendig ist. Gibt man dieses Korrekt an, erhält der Command diesen Wert.": "In der Hilfe-Ansicht ist in den \"OPTIONS\" nun zu sehen, dass ein `--id` Flag notwendig ist. Gibt man diesen Korrekt an, erhält der Befehl diesen Wert.",
        "Boolean Flags": "Boolesche Flaggen",
        "Flags haben den Vorteil, dass sie auch als wertlosen Flag verwendet werden können, um so zum Beispiel ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolean markiert ist, wird dieses Verhalten aktiviert.": "Flaggen haben den Vorteil, dass sie auch als wertlose Flagge verwendet werden können, um so zum Beispiel ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolean markiert ist, wird dieses Verhalten aktiviert.",
        "Multiple Flags": "Mehrere Flaggen",
        "Um mehrere Werte demselben Flag zu übergeben, kann ein Flag als Array markiert werden.": "Um mehrere Werte demselben Flag zu übergeben, kann ein Flag als Array markiert werden.",
        "Single Character Flags": "Einzelzeichen-Flags",
        "Um einem Flag zu erlauben, auch als ein einzelner Charakter übergeben zu werden, kann `@flag.char('x')` genutzt werden.": "Um einem Flag zu erlauben, auch als ein einzelner Charakter übergeben zu werden, kann `@flag.char('x')` verwendet werden.",
        "Optional / Default": "Optional / Standard",
        "Die Signatur der Methode `execute` definiert, welche Argument oder Flags optional sind. Ist der Parameter als Optional markiert, so muss er nicht angegeben werden.": "Die Signatur der Methode `execute` definiert, welche Argumente oder Flags optional sind. Ist der Parameter als Optional markiert, so muss er nicht angegeben werden.",
        "Dasselbe für Parameter mit einem Default-Wert:": "Dasselbe gilt für Parameter mit einem Standardwert:",
        "Dies gilt auch für Flags in derselben Art und Weise.": "Dies gilt auch für Flaggen in derselben Art und Weise.",
        "Serialization / Validation": "Serialisierung / Validierung",
        "Alle Argumente und Flags werden automatisch basierend auf dessen Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.": "Alle Argumente und Flaggen werden automatisch basierend auf dessen Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature xref:serialization.adoc#serialisation-loosely-convertion[Weiche Typenkonvertierung].": "So sind Argumente, die als Nummer definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung geschieht dabei automatisch mit dem Feature xref:serialization.adoc#serialisation-loosely-convertion[Weiche Typenkonvertierung].",
        "Zusätzliche Einschränkungen können mit den Typen-Decorators aus `@deepkit/type` definiert werden.": "Zusätzliche Einschränkungen können mit den Typen-Decoratoren aus `@deepkit/type` definiert werden.",
        "Der Typ `Postive` bei `id` gibt an, dass nur positive Nummern gewollt sind. Übergibt der User nun eine negative Zahl, so wird der Code in `execute` gar nicht erst ausgeführt und es wird eine Fehlermeldung präsentiert.": "Der Typ `Postive` bei `id` gibt an, dass nur positive Nummern gewollt sind. Übergibt der User nun eine negative Zahl, so wird der Code in `execute` gar nicht erst ausgeführt und es wird eine Fehlermeldung präsentiert.",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel xref:validation.adoc[Validation] für mehr Informationen.": "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel xref:validation.adoc[Validation] für mehr Informationen.",
        "Description": "Beschreibung",
        "Um einen Flag oder Argument zu beschreiben, kann `@flag.description` beziehungsweise `@arg.description` genutzt werden.": "Um ein Flag oder Argument zu beschreiben, kann `@flag.description` beziehungsweise `@arg.description` genutzt werden.",
        "In der Hilfe-Ansicht erscheint diese Beschreibung hinter dem Flag beziehungsweise Argument:": "In der Hilfe-Ansicht erscheint diese Beschreibung hinter dem Flag beziehungsweise Argument:",
        "Exit code": "Exit-Code",
        "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollten in der `exucute`-Methode eine Zahl ungleich 0 zurückgeben werden.": "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollte in der `exucute`-Methode eine Zahl ungleich 0 zurückgegeben werden.",
        "Die Klasse des Commands wird vom DI Container verwaltet, sodass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.": "Die Klasse des Commands wird vom DI Container verwaltet, sodass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.",
        "HTTP": "HTTP",
        "Processing HTTP requests is one of the most well-known tasks for a server. It converts an input (HTTP request) into an output (HTTP response) and performs a specific task. A client can send data to the server via an HTTP request in a variety of ways, which must be read and handled correctly. In addition to the HTTP body, HTTP query or HTTP header values are also possible. How data is actually processed depends on the server. It is the server that defines where and how the values are to be sent by the client.": "Die Verarbeitung von HTTP-Anfragen ist eine der bekanntesten Aufgaben eines Servers. Er wandelt eine Eingabe (HTTP-Anfrage) in eine Ausgabe (HTTP-Antwort) um und führt eine bestimmte Aufgabe aus. Ein Client kann über eine HTTP-Anfrage auf unterschiedliche Weise Daten an den Server senden, die gelesen und korrekt verarbeitet werden müssen. Neben dem HTTP-Body sind auch HTTP-Query- oder HTTP-Header-Werte möglich. Wie die Daten tatsächlich verarbeitet werden, hängt vom Server ab. Der Server legt fest, wohin und wie die Werte vom Client gesendet werden sollen.",
        "The top priority here is not only to correctly execute what the user expects, but to correctly convert (deserialize) and validate any input from the HTTP request.": "Oberste Priorität hat dabei nicht nur die korrekte Ausführung dessen, was der Benutzer erwartet, sondern auch die korrekte Konvertierung (Deserialisierung) und Validierung aller Eingaben aus der HTTP-Anfrage.",
        "The pipeline through which an HTTP request passes on the server can be varied and complex. Many simple HTTP libraries pass only the HTTP request and the HTTP response for a given route, and expect the developer to process the HTTP response directly. A middleware API allows the pipeline to be extended as needed.": "Die Pipeline, die eine HTTP-Anfrage auf dem Server durchläuft, kann vielfältig und komplex sein. Viele einfache HTTP-Bibliotheken übergeben nur die HTTP-Anfrage und die HTTP-Antwort für eine bestimmte Route und erwarten, dass der Entwickler die HTTP-Antwort direkt verarbeitet. Mit einer Middleware-API kann die Pipeline nach Bedarf erweitert werden.",
        "_Express Beispiel_": "_Express Beispiel_",
        "This is very well tailored for simple use cases, but quickly becomes confusing as the application grows, since all inputs and outputs must be manually serialized or deserialized and validated. Also, consideration must be given to how objects and services such as a database abstraction can be obtained from the application itself. It forces the developer to put an architecture on top of it that maps these mandatory functionalities.": "Dies ist für einfache Anwendungsfälle sehr gut geeignet, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert oder deserialisiert und validiert werden müssen. Außerdem muss überlegt werden, wie Objekte und Dienste, z. B. eine Datenbankabstraktion, von der Anwendung selbst bezogen werden können. Dies zwingt den Entwickler dazu, eine Architektur aufzusetzen, die diese obligatorischen Funktionalitäten abbildet.",
        "Deepkit's HTTP Library leverages the power of TypeScript and Dependency Injection. SerializationDeserialization and validation of any values happen automatically based on the defined types. It also allows defining routes either via a functional API as in the example above or via controller classes to cover the different needs of an architecture.": "Die HTTP-Bibliothek von Deepkit nutzt die Leistungsfähigkeit von TypeScript und Dependency Injection. SerialisierungDesialisierung und Validierung von Werten erfolgen automatisch auf der Grundlage der definierten Typen. Außerdem können Routen entweder über eine funktionale API wie im obigen Beispiel oder über Controller-Klassen definiert werden, um die verschiedenen Anforderungen einer Architektur abzudecken.",
        "It can be used either with an existing HTTP server like Node's `http` module or with the Deepkit framework. Both API variants have access to the dependency injection container and can thus conveniently retrieve objects such as a database abstraction and configurations from the application.": "Sie kann entweder mit einem vorhandenen HTTP-Server wie dem `http`-Modul von Node oder mit dem Deepkit-Framework verwendet werden. Beide API-Varianten haben Zugriff auf den Dependency Injection Container und können so bequem Objekte wie eine Datenbankabstraktion und Konfigurationen aus der Anwendung abrufen.",
        "_Deepkit Example_": "_Deepkit Beispiel_",
        "Since CLI programs in Deepkit are based on runtime types, it is necessary to have `@deepkit/type` already installed correctly. See for this xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Da CLI-Programme in Deepkit auf Laufzeittypen basieren, ist es notwendig, dass `@deepkit/type` bereits korrekt installiert ist. Siehe hierzu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "If this is done successfully, `@deepkit/app` can be installed or the Deepkit framework which already uses the library under the hood.": "Wenn dies erfolgreich durchgeführt wurde, kann `@deepkit/app` oder das Deepkit-Framework, das die Bibliothek bereits unter der Haube verwendet, installiert werden.",
        "Note that `@deepkit/http` for the controller API is based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators` once the controller API is used.": "Beachten Sie, dass `@deepkit/http` für die Controller-API auf TypeScript-Dekoratoren basiert und diese Funktion entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller-API verwendet wird.",
        "Functional API": "Funktionale API",
        "The functional API is based on functions and can be registered via the router registry, which can be obtained via the DI container of the app.": "Die funktionale API basiert auf Funktionen und kann über die Router-Registrierung registriert werden, die über den DI-Container der App abgerufen werden kann.",
        "The router registry can also be obtained in Event Listener or in the bootstrap, so that based on modules, configurations and other providers various routes are registered.": "Die Router-Registrierung kann auch im Event Listener oder im Bootstrap erfolgen, so dass auf der Grundlage von Modulen, Konfigurationen und anderen Anbietern verschiedene Routen registriert werden.",
        "Once modules are used, functional routes can also be provided dynamically by modules.": "Sobald Module verwendet werden, können funktionale Routen auch dynamisch durch Module bereitgestellt werden.",
        "See xref:framework.adoc#framework-modules[Framework Modules], to learn more about App Modules.": "Siehe xref:framework.adoc#framework-modules[Framework-Module], um mehr über App-Module zu erfahren.",
        "Controller API": "Controller-API",
        "The controller API is based on classes and can be registered via the App-API under the option `controllers`.": "Die Controller-API basiert auf Klassen und kann über die App-API unter der Option `controllers` registriert werden.",
        "Once modules are used, controllers can also be provided by modules.": "Sobald Module verwendet werden, können auch Steuerungen durch Module bereitgestellt werden.",
        "To provide controllers dynamically (depending on the configuration option, for example), the `process` hook can be used.": "Um Controller dynamisch bereitzustellen (z.B. abhängig von der Konfigurationsoption), kann der `process`-Hook verwendet werden.",
        "HTTP Server": "HTTP-Server",
        "If Deepkit Framework is used, an HTTP server is already built in. However, the HTTP library can also be used with its own HTTP server without using the Deepkit framework.": "Wenn das Deepkit-Framework verwendet wird, ist ein HTTP-Server bereits integriert. Die HTTP-Bibliothek kann jedoch auch mit einem eigenen HTTP-Server verwendet werden, ohne dass das Deepkit-Framework zum Einsatz kommt.",
        "HTTP Client": "HTTP-Client",
        "todo: fetch API, validation, und cast.": "todo: fetch API, Validierung, und cast.",
        "Route Names": "Routen-Namen",
        "Routes can be given a unique name that can be referenced when forwarding. Depending on the API, the way a name is defined differs.": "Routen können mit einem eindeutigen Namen versehen werden, auf den bei der Weiterleitung Bezug genommen werden kann. Je nach API ist die Art und Weise, wie ein Name definiert wird, unterschiedlich.",
        "From all routes with a name the URL can be requested by `Router.resolveUrl()`.": "Von allen Routen mit einem Namen kann die URL durch `Router.resolveUrl()` angefordert werden.",
        "The router functions as well as the controller classes and controller methods can define arbitrary dependencies, which are resolved by the dependency injection container. For example, it is possible to conveniently get to a database abstraction or logger.": "Sowohl die Router-Funktionen als auch die Controller-Klassen und Controller-Methoden können beliebige Abhängigkeiten definieren, die durch den Dependency Injection Container aufgelöst werden. So ist es zum Beispiel möglich, bequem zu einer Datenbankabstraktion oder einem Logger zu gelangen.",
        "For example, if a database has been provided as a provider, it can be injected:": "Wenn zum Beispiel eine Datenbank als Provider bereitgestellt wurde, kann sie injiziert werden:",
        "_Functional API:_": "_Funktions-API:_",
        "_Controller API:_": "_Controller API:_",
        "See xref:dependency-injection.adoc[Dependency Injection] to learn more.": "Siehe xref:dependency-injection.adoc[Dependency Injection] um mehr zu erfahren.",
        "Input": "Eingabe",
        "All of the following input variations function in the same way for both the functional and the controller API. They allow data to be read from an HTTP request in a type-safe and decoupled manner. This not only leads to significantly increased security, but also simplifies unit testing, since strictly speaking, not even an HTTP request object needs to exist to test the route.": "Alle folgenden Eingabevarianten funktionieren sowohl für die funktionale als auch für die Controller-API auf dieselbe Weise. Sie ermöglichen das typsichere und entkoppelte Lesen von Daten aus einer HTTP-Anfrage. Dies führt nicht nur zu einer deutlich erhöhten Sicherheit, sondern vereinfacht auch das Unit-Testing, da streng genommen nicht einmal ein HTTP-Request-Objekt existieren muss, um die Route zu testen.",
        "All parameters are automatically converted (deserialized) to the defined TypeScript type and validated. This is done via the `@deepkit/type` package and its xref:serialization.adoc[Serialization] and xref:validation.adoc[Validation] features.": "Alle Parameter werden automatisch in den definierten TypeScript-Typ konvertiert (deserialisiert) und validiert. Dies geschieht über das Paket `@deepkit/type` und seine Funktionen xref:serialization.adoc[Serialisierung] und xref:validation.adoc[Validierung].",
        "For simplicity, all examples with the functional API are shown below.": "Der Einfachheit halber werden im Folgenden alle Beispiele mit der funktionalen API gezeigt.",
        "Path Parameters": "Pfad-Parameter",
        "Path parameters are values extracted from the URL of the route. The type of the value depends on the type at the associated parameter of the function or method. The conversion is done automatically with the feature xref:serialization.adoc#serialisation-loosely-convertion[Soft Type Conversion].": "Pfadparameter sind Werte, die aus der URL der Route extrahiert werden. Der Typ des Wertes hängt von dem Typ des zugehörigen Parameters der Funktion oder Methode ab. Die Konvertierung erfolgt automatisch mit der Funktion xref:serialization.adoc#serialisation-loosely-convertion[Soft Type Conversion].",
        "If a Path parameter is defined as a type other than string, it will be converted correctly.": "Wenn ein Pfadparameter als ein anderer Typ als String definiert ist, wird er korrekt konvertiert.",
        "Additional validation constraints can also be applied to the types.": "Auf die Typen können auch zusätzliche Validierungsbeschränkungen angewendet werden.",
        "All validation types from `@deepkit/type` can be applied. For more on this, see xref:http.adoc#http-validation[HTTP Validation]].": "Alle Validierungstypen aus `@deepkit/type` können angewendet werden. Mehr dazu finden Sie unter xref:http.adoc#http-validation[HTTP-Validierung]].",
        "The Path parameters have `[^]+` set as a regular expression by default in the URL matching. The RegExp for this can be customized as follows:": "Für die Path-Parameter ist standardmäßig `[^]+` als regulärer Ausdruck für den URL-Abgleich festgelegt. Der RegExp dafür kann wie folgt angepasst werden:",
        "This is only necessary in exceptional cases, because often the types in combination with validation types themselves already correctly restrict possible values.": "Dies ist nur in Ausnahmefällen notwendig, denn oft schränken die Typen in Kombination mit den Validierungstypen selbst die möglichen Werte bereits korrekt ein.",
        "Query Parameters": "Abfrage-Parameter",
        "Query parameters are values from the URL after the `?` character and can be read with the `HttpQuery<T>` type. The name of the parameter corresponds to the name of the query parameter.": "Abfrageparameter sind Werte aus der URL nach dem `?` Zeichen und können mit dem Typ `HttpQuery<T>` gelesen werden. Der Name des Parameters entspricht dem Namen des Abfrageparameters.",
        "Query parameters are also automatically deserialized and validated.": "Auch die Abfrageparameter werden automatisch deserialisiert und validiert.",
        "All validation types from `@deepkit/type` can be applied. For more on this, see xref:http.adoc#http-validation[HTTP Validation].": "Alle Validierungstypen aus `@deepkit/type` können angewendet werden. Mehr dazu finden Sie unter xref:http.adoc#http-validation[HTTP-Validierung].",
        "Warning: Parameter values are not escaped/sanitized. Their direct return in a string in a route as HTML opens a security hole (XSS). Make sure that external input is never trusted and filtere/sanitize/convert data where necessary.": "Warnung: Parameterwerte werden nicht escaped/sanitized. Ihre direkte Rückgabe in einem String in einer Route als HTML öffnet eine Sicherheitslücke (XSS). Stellen Sie sicher, dass externen Eingaben niemals vertraut wird und filtern/sanieren/konvertieren Sie Daten, wo nötig.",
        "Query Model": "Abfrage-Modell",
        "With a large number of query parameters, it can quickly become confusing. To bring order back in here, a model (class or interface) can be used, which summarizes all possible query parameters.": "Bei einer großen Anzahl von Abfrageparametern kann es schnell unübersichtlich werden. Um hier wieder Ordnung hineinzubringen, kann ein Modell (Klasse oder Schnittstelle) verwendet werden, das alle möglichen Abfrageparameter zusammenfasst.",
        "The properties in the specified model can contain all TypeScript types and validation types that `@deepkit/type` supports. See the chapter xref:serialization.adoc[Serialization] and xref:validation.adoc[Validation].": "Die Eigenschaften im angegebenen Modell können alle TypeScript-Typen und Validierungstypen enthalten, die `@deepkit/type` unterstützt. Siehe das Kapitel xref:serialization.adoc[Serialisierung] und xref:validation.adoc[Validierung].",
        "Body": "Körper",
        "For HTTP methods that allow an HTTP body, a body model can also be specified. The body content type of the HTTP request must be either `application/x-www-form-urlencoded`, `multipart/form-data` or `application/json` so that Deepkit can automatically convert this to JavaScript objects.": "Für HTTP-Methoden, die einen HTTP-Body zulassen, kann auch ein Body-Modell angegeben werden. Der Body-Inhaltstyp der HTTP-Anforderung muss entweder \"application/x-www-form-urlencoded\", \"multipart/form-data\" oder \"application/json\" sein, damit Deepkit diesen automatisch in JavaScript-Objekte umwandeln kann.",
        "Header": "Kopfzeile",
        "Stream": "Stream",
        "Manual Validation Handling": "Manuelle Handhabung der Validierung",
        "To manually take over the validation of the body model, a special type `HttpBodyValidation<T>` can be used. It allows to receive also invalid body data and to react very specifically to error messages.": "Um die Validierung des Body-Modells manuell zu übernehmen, kann ein spezieller Typ `HttpBodyValidation<T>` verwendet werden. Er erlaubt es, auch ungültige Body-Daten zu empfangen und sehr gezielt auf Fehlermeldungen zu reagieren.",
        "As soon as `valid()` returns `false`, the values in the specified model may be in a faulty state. This means that the validation has failed. If `HttpBodyValidation` is not used and an incorrect HTTP request is received, the request would be directly aborted and the code in the function would never be executed. Use `HttpBodyValidation` only if, for example, error messages regarding the body should be manually processed in the same route.": "Sobald `valid()` den Wert `false` zurückgibt, können sich die Werte im angegebenen Modell in einem fehlerhaften Zustand befinden. Dies bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Anfrage empfangen wird, würde die Anfrage direkt abgebrochen und der Code in der Funktion nie ausgeführt werden. Verwenden Sie `HttpBodyValidation` nur, wenn z.B. Fehlermeldungen bezüglich des Bodys in der gleichen Route manuell verarbeitet werden sollen.",
        "File Upload": "Hochladen von Dateien",
        "A special property type on the body model can be used to allow the client to upload files. Any number of `UploadedFile` can be used.": "Ein spezieller Eigenschaftstyp des Body-Modells kann verwendet werden, um dem Kunden das Hochladen von Dateien zu ermöglichen. Es kann eine beliebige Anzahl von \"UploadedFile\" verwendet werden.",
        "By default, Router saves all uploaded files to a temp folder and removes them once the code in the route has been executed. It is therefore necessary to read the file in the specified path in `path` and save it to a permanent location (local disk, cloud storage, database).": "Standardmäßig speichert der Router alle hochgeladenen Dateien in einem temporären Ordner und löscht sie, sobald der Code in der Route ausgeführt worden ist. Es ist daher notwendig, die Datei im angegebenen Pfad in `path` zu lesen und sie an einem dauerhaften Ort zu speichern (lokale Festplatte, Cloud-Speicher, Datenbank).",
        "Validation in an HTTP server is a mandatory functionality, because almost always work with data that is not trustworthy. The more places data is validated, the more stable the server is. Validation in HTTP routes can be conveniently used via types and validation constraints and is checked with a highly optimized validator from `@deepkit/type`, so there are no performance problems in this regard. It is therefore highly recommended to use these validation capabilities as well. Better one time too much, than one time too little.": "Die Validierung in einem HTTP-Server ist eine obligatorische Funktion, da fast immer mit Daten gearbeitet wird, die nicht vertrauenswürdig sind. Je mehr Stellen Daten validiert werden, desto stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierungseinschränkungen genutzt werden und wird mit einem hochoptimierten Validator aus `@deepkit/type` überprüft, so dass es in dieser Hinsicht keine Leistungsprobleme gibt. Es ist daher sehr zu empfehlen, diese Validierungsmöglichkeiten auch zu nutzen. Lieber einmal zu viel, als einmal zu wenig.",
        "All inputs such as path parameters, query parameters, and body parameters are automatically validated for the specified TypeScript type. If additional constraints are specified via types of `@deepkit/type`, these are also checked.": "Alle Eingaben wie Pfadparameter, Abfrageparameter und Body-Parameter werden automatisch auf den angegebenen TypeScript-Typ geprüft. Wenn zusätzliche Einschränkungen über Typen von `@deepkit/type` angegeben sind, werden diese ebenfalls überprüft.",
        "See xref:validation.adoc[Validation] for more information on this.": "Weitere Informationen hierzu finden Sie in xref:validation.adoc[Validation].",
        "Output": "Ausgabe",
        "A route can return various data structures. Some of them are handled in a special way, such as redirects and templates, and others, such as simple objects, are simply sent as JSON.": "Eine Route kann verschiedene Datenstrukturen zurückgeben. Einige von ihnen werden auf besondere Weise behandelt, z. B. Umleitungen und Vorlagen, und andere, wie einfache Objekte, werden einfach als JSON gesendet.",
        "JSON": "JSON",
        "By default, normal JavaScript values are returned to the client as JSON with the header `applicationjson; charset=utf-8`.": "Standardmäßig werden normale JavaScript-Werte als JSON mit dem Header `applicationjson; charset=utf-8` an den Client zurückgegeben.",
        "If an explicit return type is specified for the function or method, the data is serialized to JSON with the Deepkit JSON Serializer according to this type.": "Wenn für die Funktion oder Methode ein expliziter Rückgabetyp angegeben ist, werden die Daten mit dem Deepkit JSON Serializer entsprechend diesem Typ in JSON serialisiert.",
        "HTML": "HTML",
        "To send HTML there are two possibilities. Either the object `HtmlResponse` or Template Engine with TSX is used.": "Um HTML zu senden, gibt es zwei Möglichkeiten. Entweder wird das Objekt `HtmlResponse` oder Template Engine mit TSX verwendet.",
        "The template engine variant with TSX has the advantage that used variables are automatically HTML-escaped. See also xref:template.adoc[Template].": "Die Template-Engine-Variante mit TSX hat den Vorteil, dass verwendete Variablen automatisch HTML-escaped werden. Siehe auch xref:template.adoc[Template].",
        "Custom Content": "Benutzerdefinierter Inhalt",
        "Besides HTML and JSON it is also possible to send text or binary data with a specific content type. This is done via the object `Response`.": "Neben HTML und JSON ist es auch möglich, Text- oder Binärdaten mit einem bestimmten Inhaltstyp zu senden. Dies geschieht über das Objekt `Response`.",
        "HTTP Errors": "HTTP-Fehler",
        "By throwing various HTTP errors, it is possible to immediately interrupt the processing of an HTTP request and output the corresponding HTTP status of the error.": "Durch das Auslösen verschiedener HTTP-Fehler ist es möglich, die Bearbeitung einer HTTP-Anfrage sofort zu unterbrechen und den entsprechenden HTTP-Status des Fehlers auszugeben.",
        "By default, all errors are returned to the client as JSON. This behavior can be customized in the event system under the event `httpWorkflow.onControllerError`. See the section xref:http.adoc#http-events[HTTP Events].": "Standardmäßig werden alle Fehler als JSON an den Client zurückgegeben. Dieses Verhalten kann im Event-System unter dem Ereignis `httpWorkflow.onControllerError` angepasst werden. Siehe den Abschnitt xref:http.adoc#http-events[HTTP Events].",
        "The error `HttpAccessDeniedError` is a special case. As soon as it is thrown, the HTTP workflow (see xref:http.adoc#http-events[HTTP Events]) does not jump to `controllerError` but to `accessDenied`.": "Der Fehler `HttpAccessDeniedError` ist ein Sonderfall. Sobald er ausgelöst wird, springt der HTTP-Workflow (siehe xref:http.adoc#http-events[HTTP Events]) nicht zu `controllerError` sondern zu `accessDenied`.",
        "Custom HTTP errors can be created and thrown with `createHttpError`.": "Benutzerdefinierte HTTP-Fehler können mit `createHttpError` erstellt und ausgelöst werden.",
        "Additional headers": "Zusätzliche Überschriften",
        "To modify the header of an HTTP response, additional methods can be called on the `Response`, `JSONResponse`, and `HTMLResponse` objects.": "Um die Kopfzeile einer HTTP-Antwort zu ändern, können zusätzliche Methoden für die Objekte `Response`, `JSONResponse` und `HTMLResponse` aufgerufen werden.",
        "Redirect": "Umleitung",
        "To return a 301 or 302 redirect as a response, `Redirect.toRoute` or `Redirect.toUrl` can be used.": "Um eine 301- oder 302-Weiterleitung als Antwort zurückzugeben, kann `Redirect.toRoute` oder `Redirect.toUrl` verwendet werden.",
        "The `Redirect.toRoute` method uses the route name here. How to set a route name can be seen in the section xref:http.adoc#http-route-name[HTTP Route Name]. If this referenced route (query or path) contains parameters, they can be specified via the second argument:": "Die Methode `Redirect.toRoute` verwendet hier den Routennamen. Wie man einen Routennamen festlegt, ist im Abschnitt xref:http.adoc#http-route-name[HTTP Route Name] beschrieben. Wenn diese referenzierte Route (Query oder Path) Parameter enthält, können diese über das zweite Argument angegeben werden:",
        "Alternatively, you can redirect to a URL with `Redirect.toUrl`.": "Alternativ können Sie mit `Redirect.toUrl` auf eine URL umleiten.",
        "By default, both use a 302 forwarding. This can be customized via the `statusCode` argument.": "Standardmäßig verwenden beide eine 302-Weiterleitung. Dies kann über das Argument \"StatusCode\" angepasst werden.",
        "Scope": "Umfang",
        "All HTTP controllers and functional routes are managed within the `http` dependency injection scope. HTTP controllers are instantiated accordingly for each HTTP request. This also means that both can access providers registered for the `http` scope. So additionally `HttpRequest` and `HttpResponse` from `@deepkit/http` are usable as dependencies. If deepkit framework is used, `SessionHandler` from `@deepkit/framework` is also available.": "Alle HTTP-Controller und funktionalen Routen werden innerhalb des `http`-Abhängigkeitsinjektionsbereichs verwaltet. HTTP-Controller werden für jede HTTP-Anfrage entsprechend instanziiert. Das bedeutet auch, dass beide auf Provider zugreifen können, die für den `http`-Bereich registriert sind. So sind zusätzlich `HttpRequest` und `HttpResponse` aus `@deepkit/http` als Abhängigkeiten nutzbar. Wenn das Deepkit-Framework verwendet wird, ist auch `SessionHandler` aus `@deepkit/framework` verfügbar.",
        "It can be useful to place providers in the `http` scope, for example to instantiate services for each HTTP request. Once the HTTP request has been processed, the `http` scoped DI container is deleted, thus cleaning up all its provider instances from the garbage collector (GC).": "Es kann sinnvoll sein, Provider in den `http'-Bereich zu stellen, um beispielsweise Dienste für jede HTTP-Anfrage zu instanziieren. Sobald die HTTP-Anfrage verarbeitet wurde, wird der DI-Container mit dem Gültigkeitsbereich `http` gelöscht, wodurch alle Anbieterinstanzen vom Garbage Collector (GC) bereinigt werden.",
        "See xref:dependency-injection.adoc#di-scopes[Dependency Injection Scopes] to learn how to place providers in the `http` scope.": "Siehe xref:dependency-injection.adoc#di-scopes[Dependency Injection Scopes], um zu erfahren, wie man Provider in den `http'-Bereich platziert.",
        "Events": "Veranstaltungen",
        "The HTTP module is based on a workflow engine that provides various event tokens that can be used to hook into the entire process of processing an HTTP request.": "Das HTTP-Modul basiert auf einer Workflow-Engine, die verschiedene Ereignis-Token zur Verfügung stellt, mit denen man sich in den gesamten Prozess der Verarbeitung einer HTTP-Anfrage einklinken kann.",
        "The workflow engine is a finite state machine that creates a new state machine instance for each HTTP request and then jumps from position to position. The first position is the `start` and the last the `response`. Additional code can be executed in each position.": "Die Workflow-Engine ist ein endlicher Zustandsautomat, der für jede HTTP-Anfrage eine neue Instanz des Zustandsautomaten erstellt und dann von Position zu Position springt. Die erste Position ist der `Start` und die letzte die `Antwort`. An jeder Position kann zusätzlicher Code ausgeführt werden.",
        "Each event token has its own event type with additional information.": "Jedes Ereignis-Token hat seinen eigenen Ereignistyp mit zusätzlichen Informationen.",
        "Since all HTTP events are based on the workflow engine, its behavior can be modified by using the specified event and jumping there with the `event.next()` method.": "Da alle HTTP-Ereignisse auf der Workflow-Engine basieren, kann ihr Verhalten geändert werden, indem man das angegebene Ereignis verwendet und mit der Methode `event.next()` dorthin springt.",
        "The HTTP module uses its own event listeners on these event tokens to implement HTTP request processing. All these event listeners have a priority of 100, which means that when you listen for an event, your listener is executed first by default (since the default priority is 0). Add a priority above 100 to run after the HTTP module's event listeners.": "Das HTTP-Modul verwendet seine eigenen Ereignis-Listener für diese Ereignis-Token, um die Verarbeitung von HTTP-Anfragen zu implementieren. Alle diese Ereignis-Listener haben eine Priorität von 100, d. h., wenn Sie auf ein Ereignis warten, wird Ihr Listener standardmäßig zuerst ausgeführt (da die Standardpriorität 0 ist). Fügen Sie eine Priorität über 100 hinzu, um nach den Ereignis-Listenern des HTTP-Moduls ausgeführt zu werden.",
        "For example, suppose you want to catch the event when a controller is invoked. If a particular controller is to be invoked, we check if the user has access to it. If the user has access, we continue. But if not, we jump to the next workflow item `accessDenied`. There, the procedure of an access-denied is then automatically processed further.": "Nehmen wir zum Beispiel an, Sie wollen das Ereignis abfangen, wenn ein Controller aufgerufen wird. Wenn ein bestimmter Controller aufgerufen werden soll, prüfen wir, ob der Benutzer Zugriff auf ihn hat. Wenn der Benutzer Zugriff hat, fahren wir fort. Wenn nicht, springen wir zum nächsten Workflow-Element `accessDenied`. Dort wird dann der Vorgang eines access-denied automatisch weiterverarbeitet.",
        "Security": "Sicherheit",
        "Sessions": "Sitzungen",
        "Middleware": "Middleware",
        "HTTP middlewares allow you to hook into the request/response cycle as an alternative to HTTP events. Its API allows you to use all middlewares from the Express/Connect framework.": "HTTP-Middlewares ermöglichen es Ihnen, sich in den Anfrage/Antwort-Zyklus als Alternative zu HTTP-Ereignissen einzuklinken. Mit seiner API können Sie alle Middlewares des Express/Connect-Frameworks verwenden.",
        "A middleware can either be a class (which is instantiated by the dependency injection container) or a simple function.": "Eine Middleware kann entweder eine Klasse (die vom Dependency Injection Container instanziiert wird) oder eine einfache Funktion sein.",
        "Global": "Global",
        "By using httpMiddleware.for(MyMiddleware) a middleware is registered for all routes, globally.": "Durch die Verwendung von httpMiddleware.for(MyMiddleware) wird eine Middleware für alle Routen global registriert.",
        "Per Controller": "Pro Controller",
        "You can limit middlewares to one or multiple controllers in two ways. Either by using the `@http.controller` or `httpMiddleware.for(T).forControllers()`. `excludeControllers` allow you to exclude controllers.": "Sie können Middlewares auf zwei Arten auf einen oder mehrere Controller beschränken. Entweder durch die Verwendung von `@http.controller` oder `httpMiddleware.for(T).forControllers()`. Mit `excludeControllers` können Sie Controller ausschließen.",
        "Per Route Name": "Pro Route Name",
        "`forRouteNames` along with its counterpart `excludeRouteNames` allow you to filter the execution of a middleware per route names.": "Mit `forRouteNames` und seinem Gegenstück `excludeRouteNames` können Sie die Ausführung einer Middleware nach Routennamen filtern.",
        "Per Action/Route": "Pro Aktion/Route",
        "To execute a middleware only for a certain route, you can either use `@http.GET().middleware()` or": "Um eine Middleware nur für eine bestimmte Route auszuführen, können Sie entweder `@http.GET().middleware()` verwenden oder",
        "`httpMiddleware.for(T).forRoute()` where forRoute has multiple options to filter routes.": "`httpMiddleware.for(T).forRoute()`, wobei forRoute mehrere Optionen zum Filtern von Routen hat.",
        "`forRoutes()` allows as first argument several way to filter for routes.": "forRoutes()` erlaubt als erstes Argument mehrere Möglichkeiten, nach Routen zu filtern.",
        "Path Pattern": "Pfad-Muster",
        "`path` supports wildcard *.": "Pfad\" unterstützt Platzhalter *.",
        "RegExp": "RegExp",
        "HTTP Method": "HTTP-Methode",
        "Filter all routes by a HTTP method.": "Alle Routen nach einer HTTP-Methode filtern.",
        "Category": "Kategorie",
        "`category` along with its counterpart `excludeCategory` allow you to filter per route category.": "Kategorie\" und sein Gegenstück \"ExcludeCategory\" ermöglichen es Ihnen, nach Routenkategorien zu filtern.",
        "`group` along with its counterpart `excludeGroup` allow you to filter per route group.": "Mit `group` und seinem Gegenstück `excludeGroup` können Sie nach Routengruppen filtern.",
        "Per Modules": "Pro Modul",
        "You can limit the execution of a module for a whole module.": "Sie können die Ausführung eines Moduls für ein ganzes Modul einschränken.",
        "Per Self Modules": "Pro-Selbst-Module",
        "To execute a middleware for all controllers/routes of a module where the middleware was registered use `forSelfModules()`.": "Um eine Middleware für alle Controller/Routen eines Moduls auszuführen, in dem die Middleware registriert wurde, verwenden Sie \"forSelfModules()\".",
        "Timeout": "Zeitüberschreitung",
        "All middleware needs to execute `next()` sooner or later. If a middleware does not execute `next()` withing a timeout, a warning is logged and the next middleware executed. To change the default of 4seconds to something else use timeout(milliseconds).": "Alle Middlewares müssen früher oder später `next()` ausführen. Wenn eine Middleware `next()` nicht innerhalb eines Timeouts ausführt, wird eine Warnung protokolliert und die nächste Middleware ausgeführt. Um den Standardwert von 4 Sekunden in etwas anderes zu ändern, verwenden Sie timeout(milliseconds).",
        "Multiple Rules": "Mehrere Regeln",
        "To combine multiple filters, you can chain method calls.": "Um mehrere Filter zu kombinieren, können Sie Methodenaufrufe verketten.",
        "Express Middleware": "Express-Middleware",
        "Almost all express middlewares are supported. Those who access certain request methods of express are not yet supported.": "Fast alle Express-Middlewares werden unterstützt. Diejenigen, die auf bestimmte Anfragemethoden von Express zugreifen, werden noch nicht unterstützt.",
        "Resolver": "Auflöser",
        "Router supports a way to resolve complex parameter types. For example, given a route such as `/user/:id`, this `id` can be resolved to a `user` object outside the route using a resolver. This further decouples HTTP abstraction and route code, further simplifying testing and modularity.": "Der Router unterstützt eine Möglichkeit zur Auflösung komplexer Parametertypen. Bei einer Route wie `/user/:id` kann diese `id` beispielsweise mit Hilfe eines Resolvers in ein `user` Objekt außerhalb der Route aufgelöst werden. Dies entkoppelt die HTTP-Abstraktion und den Routencode weiter, was das Testen und die Modularität weiter vereinfacht.",
        "The decorator in `@http.resolveParameter` specifies which class is to be resolved with the `UserResolver`. As soon as the specified class `User` is specified as a parameter in the function or method, the resolver is used to provide it.": "Der Dekorator in `@http.resolveParameter` gibt an, welche Klasse mit dem `UserResolver` aufgelöst werden soll. Sobald die angegebene Klasse `User` als Parameter in der Funktion oder Methode angegeben wird, wird der Resolver verwendet, um sie bereitzustellen.",
        "If `@http.resolveParameter` is specified at the class, all methods of this class get this resolver. The decorator can also be applied per method:": "Wenn `@http.resolveParameter` bei der Klasse angegeben ist, erhalten alle Methoden dieser Klasse diesen Resolver. Der Dekorator kann auch pro Methode angewendet werden:",
        "Also, the functional API can be used:": "Außerdem kann die funktionale API verwendet werden:",
        "The `User` object does not necessarily have to depend on a parameter. It could just as well depend on a session or an HTTP header, and only be provided when the user is logged in. In `RouteParameterResolverContext` a lot of information about the HTTP request is available, so that many use cases can be mapped.": "Das Objekt \"User\" muss nicht unbedingt von einem Parameter abhängen. Es könnte genauso gut von einer Sitzung oder einem HTTP-Header abhängen und nur bereitgestellt werden, wenn der Benutzer angemeldet ist. In `RouteParameterResolverContext` sind viele Informationen über die HTTP-Anfrage verfügbar, so dass viele Anwendungsfälle abgebildet werden können.",
        "In principle, it is also possible to have complex parameter types provided via the Dependency Injection container from the `http` scope, since these are also available in the route function or method. However, this has the disadvantage that no asynchronous function calls can be used, since the DI container is synchronous throughout.": "Prinzipiell ist es auch möglich, komplexe Parametertypen über den Dependency Injection Container aus dem `http`-Scope bereitzustellen, da diese auch in der Routenfunktion bzw. -methode zur Verfügung stehen. Dies hat jedoch den Nachteil, dass keine asynchronen Funktionsaufrufe verwendet werden können, da der DI-Container durchgehend synchron ist.",
        "RPC": "RPC",
        "RPC, which stands for Remote Procedure Call, allows functions on a remote server to be called as if they were local functions. Unlike HTTP client-server communication, which uses HTTP methods and a URL for mapping, RPC uses the function name for mapping. The data to be sent is passed as normal function arguments, and the result of the function call on the server is sent back to the client.": "RPC, die Abkürzung für Remote Procedure Call, ermöglicht es, Funktionen auf einem entfernten Server so aufzurufen, als wären es lokale Funktionen. Im Gegensatz zur HTTP-Client-Server-Kommunikation, bei der HTTP-Methoden und eine URL für die Zuordnung verwendet werden, verwendet RPC den Funktionsnamen für die Zuordnung. Die zu sendenden Daten werden als normale Funktionsargumente übergeben, und das Ergebnis des Funktionsaufrufs auf dem Server wird an den Client zurückgesendet.",
        "The advantage of RPC is that the client-server abstraction is lightweight because it does not work with headers, URLs, query strings, or similar. The disadvantage is that functions on a server via RPC cannot be easily called by a browser and often require a specific client.": "Der Vorteil von RPC ist, dass die Client-Server-Abstraktion leichtgewichtig ist, da sie nicht mit Kopfzeilen, URLs, Abfragezeichenfolgen oder Ähnlichem arbeitet. Der Nachteil ist, dass Funktionen auf einem Server über RPC nicht einfach von einem Browser aufgerufen werden können und oft einen speziellen Client erfordern.",
        "One key feature of RPC is that the data between the client and server is automatically serialized and deserialized. Therefore, type-safe RPC clients are usually possible. Some RPC frameworks force users to provide types (parameter types and return types) in a specific format. This can be in the form of a DSL such as Protocol Buffers for gRPC and GraphQL or a JavaScript schema builder. Additional data validation can also be provided by the RPC framework but is not supported by all.": "Ein wesentliches Merkmal von RPC ist, dass die Daten zwischen Client und Server automatisch serialisiert und deserialisiert werden. Daher sind typsichere RPC-Clients in der Regel möglich. Einige RPC-Frameworks zwingen die Benutzer, Typen (Parametertypen und Rückgabetypen) in einem bestimmten Format bereitzustellen. Dies kann in Form einer DSL wie Protocol Buffers für gRPC und GraphQL oder eines JavaScript-Schema-Builders erfolgen. Zusätzliche Datenvalidierung kann auch vom RPC-Framework bereitgestellt werden, wird aber nicht von allen unterstützt.",
        "Deepkit RPC extracts types from the TypeScript code itself, so it is not necessary to use a code generator or define them manually. Deepkit supports automatic serialization and deserialization of parameters and results. Once additional restrictions are defined in Validation, they are automatically validated. This makes communication via RPC extremely type-safe and efficient. The support for streaming via `rxjs` in Deepkit RPC makes this RPC framework a suitable tool for real-time communication.": "Deepkit RPC extrahiert Typen aus dem TypeScript-Code selbst, so dass es nicht notwendig ist, einen Codegenerator zu verwenden oder sie manuell zu definieren. Deepkit unterstützt die automatische Serialisierung und Deserialisierung von Parametern und Ergebnissen. Sobald zusätzliche Einschränkungen in Validation definiert sind, werden sie automatisch validiert. Dies macht die Kommunikation über RPC extrem typsicher und effizient. Die Unterstützung von Streaming über `rxjs` in Deepkit RPC macht dieses RPC-Framework zu einem geeigneten Werkzeug für die Echtzeitkommunikation.",
        "To illustrate the concept behind RPC, consider the following code:": "Zur Veranschaulichung des Konzepts von RPC dient der folgende Code:",
        "A method like hello is implemented just like a normal function within a class on the server and can be called by a remote client.": "Eine Methode wie hello ist wie eine normale Funktion innerhalb einer Klasse auf dem Server implementiert und kann von einem entfernten Client aufgerufen werden.",
        "Because RPC is fundamentally based on asynchronous communication, communication is usually over HTTP but can also be over TCP or WebSockets. This means that all function calls in TypeScript are converted to a `Promise` themselves. The result can be received asynchronously with a corresponding `await`.": "Da RPC grundsätzlich auf asynchroner Kommunikation basiert, erfolgt die Kommunikation normalerweise über HTTP, kann aber auch über TCP oder WebSockets erfolgen. Das bedeutet, dass alle Funktionsaufrufe in TypeScript selbst in ein `Promise` umgewandelt werden. Das Ergebnis kann asynchron mit einem entsprechenden `await` empfangen werden.",
        "When a project uses TypeScript on both the client (usually frontend) and server (backend), it is called Isomorphic TypeScript. A type-safe RPC framework based on TypeScript's types is particularly beneficial for such a project because types can be shared between the client and server.": "Wenn ein Projekt TypeScript sowohl auf dem Client (in der Regel Frontend) als auch auf dem Server (Backend) verwendet, wird es als Isomorphic TypeScript bezeichnet. Ein typsicheres RPC-Framework, das auf TypeScript-Typen basiert, ist für ein solches Projekt besonders vorteilhaft, da die Typen von Client und Server gemeinsam genutzt werden können.",
        "To take advantage of this, types that are used on both sides should be outsourced to their own file or package. Importing on the respective side then puts them back together.": "Um dies zu nutzen, sollten Typen, die auf beiden Seiten verwendet werden, in eine eigene Datei oder ein eigenes Paket ausgelagert werden. Beim Importieren auf der jeweiligen Seite werden sie dann wieder zusammengefügt.",
        "Backward compatibility can be implemented in the same way as with a normal local API: either new parameters are marked as optional or a new method is added.": "Die Abwärtskompatibilität kann auf die gleiche Weise wie bei einer normalen lokalen API implementiert werden: entweder werden neue Parameter als optional gekennzeichnet oder eine neue Methode wird hinzugefügt.",
        "To use Deepkit RPC, it is necessary to have `@deepkit/type` correctly installed because it is based on Runtime Types. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Um Deepkit RPC zu verwenden, muss `@deepkit/type` korrekt installiert sein, da es auf Runtime Types basiert. Siehe xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Once this is successfully done, `@deepkit/rpc` or the Deepkit Framework, which already uses the library under the hood, can be installed.": "Sobald dies erfolgreich durchgeführt wurde, kann `@deepkit/rpc` oder das Deepkit Framework, das die Bibliothek bereits unter der Haube verwendet, installiert werden.",
        "Note that controller classes in `@deepkit/rpc` are based on TypeScript decorators, and this feature must be enabled with experimentalDecorators.": "Beachten Sie, dass die Controller-Klassen in `@deepkit/rpc` auf TypeScript-Dekoratoren basieren und diese Funktion mit experimentalDecorators aktiviert werden muss.",
        "The `@deepkit/rpc` package must be installed on the server and client if they have their own package.json.": "Das Paket `@deepkit/rpc` muss auf dem Server und dem Client installiert sein, wenn sie ihre eigene package.json haben.",
        "To communicate over TCP with the server, the `@deepkit/rpc-tcp` package must be installed on the client and server.": "Um über TCP mit dem Server zu kommunizieren, muss das Paket `@deepkit/rpc-tcp` auf dem Client und dem Server installiert sein.",
        "For WebSocket communication, the package is also required on the server. The client in the browser, on the other hand, uses WebSocket from the official standard.": "Für die WebSocket-Kommunikation wird das Paket auch auf dem Server benötigt. Der Client im Browser hingegen verwendet WebSocket aus dem offiziellen Standard.",
        "If the client is also to be used in an environment where WebSocket is not available (for example, NodeJS), the package ws is required in the client.": "Wenn der Client auch in einer Umgebung verwendet werden soll, in der WebSocket nicht verfügbar ist (z. B. NodeJS), wird das Paket ws im Client benötigt.",
        "Below is a fully functional example based on WebSockets and the low-level API of @deepkit/rpc. When using the Deepkit Framework, controllers are provided via app modules, and an RpcKernel is not instantiated manually.": "Nachfolgend finden Sie ein voll funktionsfähiges Beispiel auf der Grundlage von WebSockets und der Low-Level-API von @deepkit/rpc. Bei Verwendung des Deepkit-Frameworks werden die Controller über App-Module bereitgestellt, und ein RpcKernel wird nicht manuell instanziiert.",
        "_File: server.ts_": "_Datei: server.ts_",
        "_File: client.ts_": "_Datei: client.ts_",
        "Server Controller": "Server-Controller",
        "The term \"Procedure\" in Remote Procedure Call is also commonly referred to as an \"Action\". An Action is a method defined in a class and marked with the `@rpc.action` decorator. The class itself is marked as a Controller with the `@rpc.controller` decorator and given a unique name. This name is then referenced in the client to address the correct controller. Multiple controllers can be defined and registered as needed.": "Der Begriff \"Prozedur\" in Remote Procedure Call wird im Allgemeinen auch als \"Aktion\" bezeichnet. Eine Aktion ist eine Methode, die in einer Klasse definiert und mit dem Dekorator `@rpc.action` gekennzeichnet ist. Die Klasse selbst wird mit dem Dekorator \"@@rpc.controller\" als Controller gekennzeichnet und erhält einen eindeutigen Namen. Dieser Name wird dann im Client referenziert, um den richtigen Controller anzusprechen. Bei Bedarf können mehrere Controller definiert und registriert werden.",
        "Only methods marked as `@rpc.action()` can be called by a client.": "Nur Methoden, die als `@rpc.action()` gekennzeichnet sind, können von einem Client aufgerufen werden.",
        "Types must be explicitly specified and cannot be inferred. This is important because the serializer needs to know exactly what the types look like in order to convert them into binary data (BSON) or JSON which is then sent over the wire.": "Die Typen müssen explizit angegeben werden und können nicht abgeleitet werden. Dies ist wichtig, da der Serialisierer genau wissen muss, wie die Typen aussehen, um sie in binäre Daten (BSON) oder JSON zu konvertieren, die dann über die Leitung gesendet werden.",
        "Client Controller": "Kunden-Controller",
        "The normal flow in RPC is that the client can execute functions on the server. However, in Deepkit RPC, it is also possible for the server to execute functions on the client. To allow this, the client can also register a controller.": "Der normale Ablauf bei RPC ist, dass der Client Funktionen auf dem Server ausführen kann. In Deepkit RPC ist es jedoch auch möglich, dass der Server Funktionen auf dem Client ausführt. Um dies zu ermöglichen, kann der Client auch einen Controller registrieren.",
        "Controller classes are managed by the Dependency Injection Container from `@deepkit/injector`. When using the Deepkit Framework, these controllers automatically have access to the providers of the modules that provide the controller.": "Controller-Klassen werden durch den Dependency Injection Container von `@deepkit/injector` verwaltet. Bei Verwendung des Deepkit-Frameworks haben diese Controller automatisch Zugriff auf die Anbieter der Module, die den Controller bereitstellen.",
        "In the Deepkit Framework, controllers are instantiated in the Dependency Injection Scope `rpc`, allowing all controllers to automatically access various providers from this scope. These additional providers are `HttpRequest` (optional), `RpcInjectorContext`, `SessionState`, `RpcKernelConnection`, and `ConnectionWriter`.": "Im Deepkit Framework werden Controller im Dependency Injection Scope `rpc` instanziiert, so dass alle Controller automatisch auf verschiedene Provider aus diesem Scope zugreifen können. Diese zusätzlichen Anbieter sind `HttpRequest` (optional), `RpcInjectorContext`, `SessionState`, `RpcKernelConnection` und `ConnectionWriter`.",
        "However, when an `RpcKernel` is manually instantiated, a DI Container can also be passed. The RPC Controller will then be instantiated through this DI Container. This is useful if you want to use `@deepkit/rpc` in a non-Deepkit Framework environment, like Express.js.": "Wenn jedoch ein `RpcKernel` manuell instanziiert wird, kann auch ein DI Container übergeben werden. Der RPC-Controller wird dann über diesen DI-Container instanziiert. Dies ist nützlich, wenn Sie `@deepkit/rpc` in einer Nicht-Deepkit-Framework-Umgebung, wie Express.js, verwenden möchten.",
        "See [Dependency Injection](xref:dependency-injection.adoc) to learn more.": "Siehe [Dependency Injection](xref:dependency-injection.adoc) um mehr zu erfahren.",
        "Nominal Types": "Nominale Typen",
        "When the client receives data from a function call, it has first been serialized on the server and then deserialized on the client. If the function's return type includes classes, these classes will be reconstructed on the client side, but they will lose their nominal identity and associated methods. To address this issue, register the classes as nominal types with unique IDs/names. This approach should be applied to all classes used within an RPC-API.": "Wenn der Client Daten aus einem Funktionsaufruf erhält, wurden diese zunächst auf dem Server serialisiert und dann auf dem Client deserialisiert. Wenn der Rückgabetyp der Funktion Klassen enthält, werden diese Klassen auf der Client-Seite rekonstruiert, aber sie verlieren ihre nominale Identität und die zugehörigen Methoden. Um dieses Problem zu lösen, registrieren Sie die Klassen als Nominaltypen mit eindeutigen IDs/Namen. Dieser Ansatz sollte auf alle Klassen angewandt werden, die innerhalb einer RPC-API verwendet werden.",
        "To register a class, use the decorator `@entity.name('id')`.": "Um eine Klasse zu registrieren, verwenden Sie den Dekorator `@entity.name('id')`.",
        "Once this class is used as the result of a function, its identity will be preserved.": "Sobald diese Klasse als Ergebnis einer Funktion verwendet wird, bleibt ihre Identität erhalten.",
        "Error Forwarding": "Fehlerweiterleitung",
        "RPC functions can throw errors. By default, these errors are forwarded to the client and thrown again. If you are using custom error classes, you should enable their nominal type. See [RPC Nominal Types](xref:rpc.adoc#rpc-nominal-types) for more information": "RPC-Funktionen können Fehler auslösen. Standardmäßig werden diese Fehler an den Client weitergeleitet und erneut ausgelöst. Wenn Sie eigene Fehlerklassen verwenden, sollten Sie deren Nominaltyp aktivieren. Siehe [RPC-Nominaltypen](xref:rpc.adoc#rpc-nominal-types) für weitere Informationen",
        "By default, all RPC functions can be called from any client, and the peer-to-peer communication feature is enabled. To precisely control which client is allowed to do what, you can override the `RpcKernelSecurity` class.": "Standardmäßig können alle RPC-Funktionen von jedem Client aufgerufen werden, und die Peer-to-Peer-Kommunikation ist aktiviert. Um genau zu steuern, welcher Client was tun darf, können Sie die Klasse `RpcKernelSecurity` überschreiben.",
        "To use this, pass the provider to the `RpcKernel`:": "Um diesen zu verwenden, übergeben Sie den Provider an den `RpcKernel`:",
        "Or, in the case of a Deepkit Framework application, override the `RpcKernelSecurity` class with a provider in the app:": "Oder, im Falle einer Deepkit-Framework-Anwendung, überschreiben Sie die Klasse \"RpcKernelSecurity\" mit einem Anbieter in der Anwendung:",
        "Authentication / Session": "Authentifizierung / Sitzung",
        "By default, the `Session` object is an anonymous session, meaning the client has not authenticated. When the client wants to authenticate, the `authenticate` method is called. The token received by the `authenticate` method comes from the client and can have any value.": "Standardmäßig ist das Objekt \"Session\" eine anonyme Sitzung, d. h. der Client hat sich nicht authentifiziert. Wenn der Client sich authentifizieren will, wird die Methode `authenticate` aufgerufen. Das von der Methode `authenticate` empfangene Token kommt vom Client und kann einen beliebigen Wert haben.",
        "Once the client sets a token, the authentication is executed when the first RPC function is called or when `client.connect()` is manually invoked.": "Sobald der Client ein Token setzt, wird die Authentifizierung ausgeführt, wenn die erste RPC-Funktion aufgerufen wird oder wenn `client.connect()` manuell aufgerufen wird.",
        "In this case, `RpcKernelSecurity.authenticate` receives the token `123456789` and can return a different session accordingly. The returned session is then passed to all other methods like `hasControllerAccess`.": "In diesem Fall erhält \"RpcKernelSecurity.authenticate\" das Token \"123456789\" und kann dementsprechend eine andere Sitzung zurückgeben. Die zurückgegebene Sitzung wird dann an alle anderen Methoden wie `hasControllerAccess` weitergegeben.",
        "Controller Access": "Controller-Zugang",
        "The `hasControllerAccess` method determines whether a client is allowed to execute a specific RPC function. This method is called for every RPC function invocation. If it returns `false`, access is denied, and an error is thrown on the client.": "Die Methode `hasControllerAccess` bestimmt, ob ein Client eine bestimmte RPC-Funktion ausführen darf. Diese Methode wird für jeden RPC-Funktionsaufruf aufgerufen. Gibt sie den Wert \"False\" zurück, wird der Zugriff verweigert und der Client mit einem Fehler konfrontiert.",
        "The `RpcControllerAccess` contains valuable information about the RPC function:": "Der \"RpcControllerAccess\" enthält wertvolle Informationen über die RPC-Funktion:",
        "Groups and additional data can be changed via the decorator `@rpc.action()`:": "Gruppen und zusätzliche Daten können über den Dekorator `@rpc.action()` geändert werden:",
        "Transform Error": "Transformationsfehler",
        "Since thrown errors are automatically forwarded to the client with all its information like the error message and also the stacktrace, this could unwantedly publish sensitive information. To change this, in the method `transformError` the thrown error can be modified.": "Da ausgelöste Fehler automatisch an den Client mit all seinen Informationen wie der Fehlermeldung und auch dem Stacktrace weitergeleitet werden, könnte dies ungewollt sensible Informationen veröffentlichen. Um dies zu ändern, kann in der Methode `transformError` der ausgelöste Fehler geändert werden.",
        "Note that once the error is converted to a generic `error`, the complete stack trace and the identity of the error are lost. Accordingly, no `instanceof` checks can be used on the error in the client.": "Beachten Sie, dass nach der Umwandlung des Fehlers in einen generischen `Fehler` der komplette Stack-Trace und die Identität des Fehlers verloren gehen. Dementsprechend können keine `instanceof`-Prüfungen für den Fehler im Client verwendet werden.",
        "If Deepkit RPC is used between two microservices, and thus the client and server are under complete control of the developer, then transforming the error is rarely necessary. If, on the other hand, the client is running in a browser with an unknown, then care should be taken in `transformError` as to what information is to be disclosed. If in doubt, each error should be transformed with a generic `Error` to ensure that no internal details are leaked. Logging the error would then be a good idea at this point.": "Wenn Deepkit RPC zwischen zwei Microservices verwendet wird und somit der Client und der Server unter der vollständigen Kontrolle des Entwicklers stehen, dann ist eine Transformation des Fehlers nur selten notwendig. Läuft der Client hingegen in einem Browser mit einem Unbekannten, dann sollte in `transformError` darauf geachtet werden, welche Informationen offengelegt werden sollen. Im Zweifelsfall sollte jeder Fehler mit einem generischen `Error` umgewandelt werden, um sicherzustellen, dass keine internen Details durchgesickert sind. Die Protokollierung des Fehlers wäre an dieser Stelle eine gute Idee.",
        "When the Deepkit framework is used, the class is instantiated by the Dependency Injection container and thus automatically has access to all other providers in the application.": "Bei Verwendung des Deepkit-Frameworks wird die Klasse vom Dependency Injection-Container instanziiert und hat damit automatisch Zugriff auf alle anderen Anbieter in der Anwendung.",
        "See also xref:dependency-injection.adoc[Dependency Injection].": "Siehe auch xref:dependency-injection.adoc[Dependency Injection].",
        "Streaming RxJS": "RxJS-Streaming",
        "Transport Protocol": "Transport-Protokoll",
        "Deepkit RPC supports several transport protocols. WebSockets is the protocol that has the best compatibility (since browsers support it) while supporting all features like streaming. TCP is usually faster and is great for communication between servers (microservices) or non-browser clients. But WebSockets work well for server to server communication as well.": "Deepkit RPC unterstützt mehrere Transportprotokolle. WebSockets ist das Protokoll, das die beste Kompatibilität aufweist (da es von Browsern unterstützt wird) und gleichzeitig alle Funktionen wie Streaming unterstützt. TCP ist in der Regel schneller und eignet sich hervorragend für die Kommunikation zwischen Servern (Microservices) oder Nicht-Browser-Clients. WebSockets eignen sich aber auch für die Kommunikation zwischen Servern.",
        "Deepkit's RPC HTTP protocol is a variant that is particularly easy to debug in the browser, as each function call is an HTTP request, but has its limitations such as no support for RxJS streaming.": "Das RPC-HTTP-Protokoll von Deepkit ist eine Variante, die im Browser besonders einfach zu debuggen ist, da jeder Funktionsaufruf eine HTTP-Anfrage ist, die aber auch ihre Grenzen hat, z. B. keine Unterstützung für RxJS-Streaming.",
        "TODO: Not implemented yet.": "TODO: Noch nicht implementiert.",
        "WebSockets": "WebSockets",
        "@deepkit/rpc-tcp `RpcWebSocketServer` and Browser WebSocket or Node `ws` package.": "@deepkit/rpc-tcp `RpcWebSocketServer` und Browser WebSocket oder Node `ws` Paket.",
        "TCP": "TCP",
        "@deepkit/rpc-tcp `RpcNetTcpServer` and `RpcNetTcpClientAdapter`": "@deepkit/rpc-tcp `RpcNetTcpServer` und `RpcNetTcpClientAdapter`",
        "Peer To Peer": "Peer-to-Peer",
        "Deepkit provides an ORM that allows databases to be accessed in a modern way.": "Deepkit bietet ein ORM, das den Zugriff auf Datenbanken auf moderne Weise ermöglicht.",
        "Entities are simply defined using TypeScript types:": "Entitäten werden einfach mit TypeScript-Typen definiert:",
        "Any TypeScript types and validation decorators from Deepkit can be used to fully define the entity.": "Alle TypeScript-Typen und Validierungsdekoratoren aus Deepkit können zur vollständigen Definition der Entität verwendet werden.",
        "The entity type system is designed in such a way that these types or classes can also be used in other areas such as HTTP routes, RPC actions or frontend. This prevents, for example, that one has defined a user several times distributed in the entire application.": "Das Entity-Type-System ist so konzipiert, dass diese Typen oder Klassen auch in anderen Bereichen wie HTTP-Routen, RPC-Aktionen oder Frontend verwendet werden können. Dies verhindert, dass man z.B. einen Benutzer mehrfach in der gesamten Anwendung verteilt definiert hat.",
        "Since Deepkit ORM is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Da Deepkit ORM auf Runtime Types basiert, ist es notwendig, dass `@deepkit/type` bereits korrekt installiert ist. Siehe xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "If this is done successfully, `@deepkit/orm` itself and a database adapter can be installed.": "Wenn dies erfolgreich durchgeführt wurde, können `@deepkit/orm` selbst und ein Datenbankadapter installiert werden.",
        "If classes are to be used as entities, `experimentalDecorators` must be enabled in tsconfig.json:": "Wenn Klassen als Entitäten verwendet werden sollen, muss \"ExperimentalDecorators\" in tsconfig.json aktiviert werden:",
        "Once the library is installed, a database adapter can be installed and the API of it can be used directly.": "Sobald die Bibliothek installiert ist, kann ein Datenbankadapter installiert werden, dessen API direkt verwendet werden kann.",
        "SQLite": "SQLite",
        "MySQL": "MySQL",
        "Postgres": "Postgres",
        "MongoDB": "MongoDB",
        "Primarily the `Database` object is used. Once instantiated, it can be used throughout the application to query or manipulate data. The connection to the database is initialized lazy.": "In erster Linie wird das Objekt `Database` verwendet. Sobald es instanziiert ist, kann es in der gesamten Anwendung verwendet werden, um Daten abzufragen oder zu manipulieren. Die Verbindung zur Datenbank wird träge initialisiert.",
        "The `Database` object is passed an adapter, which comes from the database adapters libraries.": "Dem `Database`-Objekt wird ein Adapter übergeben, der aus den Bibliotheken der Datenbankadapter stammt.",
        "Connection": "Verbindung",
        "Read Replica": "Replik lesen",
        "An entity is either a class or an object literal (interface) and always has a primary key.": "Eine Entität ist entweder eine Klasse oder ein Objektliteral (Schnittstelle) und hat immer einen Primärschlüssel.",
        "The entity is decorated with all necessary information using type decorators from `@deepkit/type`. For example, a primary key is defined as well as various fields and their validation constraints. These fields reflect the database structure, usually a table or a collection.": "Die Entität wird mit allen erforderlichen Informationen unter Verwendung von Typdekoratoren aus `@deepkit/type` dekoriert. Zum Beispiel wird ein Primärschlüssel definiert sowie verschiedene Felder und ihre Validierungsbeschränkungen. Diese Felder spiegeln die Datenbankstruktur wider, in der Regel eine Tabelle oder eine Sammlung.",
        "Through special type decorators like `Mapped<'name'>` a field name can also be mapped to another name in the database.": "Durch spezielle Typdekoratoren wie `Mapped<'name'>` kann ein Feldname auch auf einen anderen Namen in der Datenbank abgebildet werden.",
        "Klasse": "Klasse",
        "Interface": "Schnittstelle",
        "Primitives": "Primitive",
        "Primitive data types like String, Number (bigint), and Boolean are mapped to common database types. Only the TypeScript type is used.": "Primitive Datentypen wie String, Number (bigint) und Boolean werden auf gängige Datenbanktypen abgebildet. Es wird nur der TypeScript-Typ verwendet.",
        "Primary Key": "Primärschlüssel",
        "Each entity needs exactly one primary key. Multiple primary keys are not supported.": "Jede Entität benötigt genau einen Primärschlüssel. Mehrere Primärschlüssel werden nicht unterstützt.",
        "The base type of a primary key can be arbitrary. Often a number or UUID is used.": "Der Basistyp eines Primärschlüssels kann beliebig sein. Häufig wird eine Zahl oder eine UUID verwendet.",
        "For MongoDB the MongoId or ObjectID is often used.": "Für MongoDB wird häufig die MongoId oder ObjectID verwendet.",
        "For numbers `AutoIncrement` can be used.": "Für Zahlen kann `AutoIncrement` verwendet werden.",
        "Auto Increment": "Automatisches Inkrement",
        "Fields that should be automatically incremented during insertion are annotated with the `AutoIncrement` decorator. All adapters support auto-increment values. The MongoDB adapter uses an additional collection to keep track of the counter.": "Felder die während des Einfügens automatisch inkrementiert werden sollen, werden mit dem `AutoIncrement` Dekorator annotiert. Alle Adapter unterstützen auto-increment Werte. Der MongoDB Adapter verwendet eine zusätzliche Sammlung um den Zähler zu verfolgen.",
        "An auto-increment field is an automatic counter and can only be applied to a primary key. The database automatically ensures that an ID is used only once.": "Ein Auto-Inkrement-Feld ist ein automatischer Zähler und kann nur auf einen Primärschlüssel angewendet werden. Die Datenbank stellt automatisch sicher, dass eine ID nur einmal verwendet wird.",
        "Fields that should be of type UUID (v4) are annotated with the decorator UUID. The runtime type is `string` and mostly binary in the database itself. Use the `uuid()` function to create a new UUID v4.": "Felder, die vom Typ UUID (v4) sein sollten, werden mit dem Dekorator UUID kommentiert. Der Laufzeittyp ist `string` und meist binär in der Datenbank selbst. Verwenden Sie die Funktion `uuid()`, um eine neue UUID v4 zu erstellen.",
        "MongoDB ObjectID": "MongoDB-ObjektID",
        "Fields that should be of type ObjectID in MongoDB are annotated with the decorator `MongoId`. The runtime type is `string` and in the database itself `ObjectId` (binary).": "Felder, die in MongoDB vom Typ ObjectID sein sollten, werden mit dem Dekorator `MongoId` annotiert. Der Laufzeittyp ist `string` und in der Datenbank selbst `ObjectId` (binär).",
        "MongoID fields automatically get a new value when inserted. It is not mandatory to use the field name `_id`. It can have any name.": "MongoID-Felder erhalten beim Einfügen automatisch einen neuen Wert. Es ist nicht zwingend erforderlich, den Feldnamen \"ID\" zu verwenden. Er kann einen beliebigen Namen haben.",
        "Optional / Nullable": "Optional / Nullbar",
        "Optional fields are declared as TypeScript type with `title?: string` or `title: string | null`. You should use only one variant of this, usually the optional `?` syntax, which works with `undefined`.": "Optionale Felder werden als TypeScript-Typ mit `title?: string` oder `title: string | null` deklariert. Sie sollten nur eine Variante davon verwenden, normalerweise die optionale `?`-Syntax, die mit `undefined` funktioniert.",
        "Both variants result in the database type being `NULLABLE` for all SQL adapters. So the only difference between these decorators is that they represent different values at runtime.": "Beide Varianten führen dazu, dass der Datenbanktyp für alle SQL-Adapter `NULLABLE` ist. Der einzige Unterschied zwischen diesen Dekoratoren ist also, dass sie zur Laufzeit unterschiedliche Werte darstellen.",
        "In the following example, the changed field is optional and can therefore be undefined at runtime, although it is always represented as NULL in the database.": "Im folgenden Beispiel ist das geänderte Feld optional und kann daher zur Laufzeit undefiniert sein, obwohl es in der Datenbank immer als NULL dargestellt wird.",
        "This example shows how the nullable type works. NULL is used both in the database and in the javascript runtime. This is more verbose than `modified?: Date` and is not commonly used.": "Dieses Beispiel zeigt, wie der Typ nullable funktioniert. NULL wird sowohl in der Datenbank als auch in der Javascript-Laufzeit verwendet. Dies ist ausführlicher als `modified? Date` und wird nicht häufig verwendet.",
        "Database Type Mapping": "Datenbank-Typ-Zuordnung",
        "With `DatabaseField` it is possible to map a field to any database type. The type must be a valid SQL statement that is passed unchanged to the migration system.": "Mit `DatabaseField` ist es möglich, ein Feld auf einen beliebigen Datenbanktyp abzubilden. Der Typ muss eine gültige SQL-Anweisung sein, die unverändert an das Migrationssystem übergeben wird.",
        "To map a field for a specific database, either `SQLite`, `MySQL`, or `Postgres` can be used.": "Um ein Feld für eine bestimmte Datenbank zuzuordnen, kann entweder `SQLite`, `MySQL` oder `Postgres` verwendet werden.",
        "Embedded Types": "Eingebettete Typen",
        "Default Values": "Standardwerte",
        "Default Expressions": "Standardausdrücke",
        "Complex Types": "Komplexe Typen",
        "Exclude": "Ausgeschlossen sind",
        "Database Specific Column Types": "Datenbankspezifische Spaltentypen",
        "Session / Unit Of Work": "Sitzung/Arbeitseinheit",
        "A session is something like a unit of work. It keeps track of everything you do and automatically records the changes whenever `commit()` is called. It is the preferred way to execute changes in the database because it bundles statements in a way that makes it very fast. A session is very lightweight and can easily be created in a request-response lifecycle, for example.": "Eine Sitzung ist so etwas wie eine Arbeitseinheit. Sie protokolliert alles, was Sie tun, und zeichnet die Änderungen automatisch auf, wenn `commit()` aufgerufen wird. Sie ist der bevorzugte Weg, um Änderungen in der Datenbank auszuführen, da sie Anweisungen auf eine Weise bündelt, die sie sehr schnell macht. Eine Session ist sehr leichtgewichtig und kann z.B. leicht in einem Anfrage-Antwort-Lebenszyklus erstellt werden.",
        "Add new instance to the session with `session.add(T)` or remove existing instances with `session.remove(T)`. Once you are done with the Session object, simply dereference it everywhere so that the garbage collector can remove it.": "Fügen Sie neue Instanzen zur Session mit `session.add(T)` hinzu oder entfernen Sie bestehende Instanzen mit `session.remove(T)`. Sobald Sie mit dem Session-Objekt fertig sind, dereferenzieren Sie es einfach überall, damit der Garbage Collector es entfernen kann.",
        "Changes are automatically detected for entity instances fetched via the Session object.": "Änderungen werden bei Entitätsinstanzen, die über das Session-Objekt abgerufen werden, automatisch erkannt.",
        "Identity Map": "Identitätskarte",
        "Sessions provide an identity map that ensures there is only ever one javascript object per database entry. For example, if you run `session.query(User).find()` twice within the same session, you get two different arrays, but with the same entity instances in them.": "Sitzungen bieten eine Identitätskarte, die sicherstellt, dass es immer nur ein Javascript-Objekt pro Datenbankeintrag gibt. Wenn Sie zum Beispiel `session.query(User).find()` zweimal innerhalb derselben Sitzung ausführen, erhalten Sie zwei verschiedene Arrays, aber mit denselben Entitätsinstanzen darin.",
        "If you add a new entity with `session.add(entity1)` and retrieve it again, you get exactly the same entity instance `entity1`.": "Wenn Sie eine neue Entität mit `session.add(entity1)` hinzufügen und sie wieder abrufen, erhalten Sie genau die gleiche Entitätsinstanz `entity1`.",
        "Important: Once you start using sessions, you should use their `session.query` method instead of `database.query`. Only session queries have the identity mapping feature enabled.": "Wichtig! Sobald Sie anfangen, Sitzungen zu verwenden, sollten Sie deren Methode `session.query` anstelle von `database.query` verwenden. Nur bei Sitzungsabfragen ist die Funktion der Identitätszuordnung aktiviert.",
        "Change Detection": "Erkennung von Änderungen",
        "Request/Response": "Anfrage/Antwort",
        "Query": "Abfrage",
        "A query is an object that describes how to retrieve or modify data from the database. It has several methods to describe the query and termination methods that execute them. The database adapter can extend the query API in many ways to support database specific features.": "Eine Abfrage ist ein Objekt, das beschreibt, wie Daten aus der Datenbank abgerufen oder geändert werden können. Es hat mehrere Methoden, um die Abfrage zu beschreiben und Abbruchmethoden, die sie ausführen. Der Datenbankadapter kann die Abfrage-API auf viele Arten erweitern, um datenbankspezifische Funktionen zu unterstützen.",
        "You can create a query using `Database.query(T)` or `Session.query(T)`. We recommend Sessions as it improves performance.": "Sie können eine Abfrage mit `Database.query(T)` oder `Session.query(T)` erstellen. Wir empfehlen Sessions, da dies die Leistung verbessert.",
        "Filter": "Filter",
        "A filter can be applied to limit the result set.": "Ein Filter kann angewendet werden, um die Ergebnismenge einzuschränken.",
        "Equal": "Gleichberechtigt",
        "Greater / Smaller": "Größer / Kleiner",
        "Grouping AND/OR": "Gruppierung AND/OR",
        "In": "Unter",
        "Select": "Wählen Sie",
        "To narrow down the fields to be received from the database, `select('field1')` can be used.": "Um die aus der Datenbank zu empfangenden Felder einzugrenzen, kann `select('field1')` verwendet werden.",
        "It is important to note that as soon as the fields are narrowed down using `select`, the results are no longer instances of the entity, but only object literals.": "Es ist wichtig zu beachten, dass die Ergebnisse nicht mehr Instanzen der Entität, sondern nur noch Objektliterale sind, sobald die Felder mit `select` eingegrenzt werden.",
        "Order": "Bestellung",
        "With `orderBy(field, order)` the order of the entries can be changed.": "Mit `orderBy(field, order)` kann die Reihenfolge der Einträge geändert werden.",
        "Several times `orderBy` can be executed to refine the order more and more.": "Mehrere Male kann `orderBy` ausgeführt werden, um die Reihenfolge immer weiter zu verfeinern.",
        "Pagination": "Paginierung",
        "The `itemsPerPage()` and `page()` methods can be used to paginate the results. Page starts at 1.": "Die Methoden `itemsPerPage()` und `page()` können zum Paginieren der Ergebnisse verwendet werden. Seite beginnt bei 1.",
        "With the alternative methods `limit` and `skip` you can paginate manually.": "Mit den alternativen Methoden `limit` und `skip` können Sie manuell paginieren.",
        "Join": "Beitreten",
        "By default, references from the entity are neither included in queries nor loaded. To include a join in the query without loading the reference, use `join()` (left join) or `innerJoin()`. To include a join in the query and load the reference, use `joinWith()` or `innerJoinWith()`.": "Standardmäßig werden Referenzen von der Entität weder in Abfragen einbezogen noch geladen. Um eine Verknüpfung in die Abfrage aufzunehmen, ohne die Referenz zu laden, verwenden Sie `join()` (linke Verknüpfung) oder `innerJoin()`. Um eine Verknüpfung in die Abfrage aufzunehmen und die Referenz zu laden, verwenden Sie `joinWith()` oder `innerJoinWith()`.",
        "All the following examples assume these model schemas:": "Alle folgenden Beispiele gehen von diesen Modellschemata aus:",
        "To modify join queries, use the same methods, but with the `use` prefix: `useJoin`, `useInnerJoin`, `useJoinWith` or `useInnerJoinWith`. To end the join query modification, use `end()` to get back the parent query.": "Um Join-Abfragen zu ändern, verwenden Sie dieselben Methoden, jedoch mit dem Präfix `use`: `useJoin`, `useInnerJoin`, `useJoinWith` oder `useInnerJoinWith`. Um die Änderung der Join-Abfrage zu beenden, verwenden Sie `end()`, um die übergeordnete Abfrage zurückzubekommen.",
        "Aggregation": "Aggregation",
        "Aggregation methods allow you to count records and aggregate fields.": "Mit Aggregationsmethoden können Sie Datensätze zählen und Felder aggregieren.",
        "The following examples assume this model scheme:": "Die folgenden Beispiele gehen von diesem Modellschema aus:",
        "`groupBy` allows to group the result by the specified field.": "Mit \"GroupBy\" kann das Ergebnis nach dem angegebenen Feld gruppiert werden.",
        "There are several aggregation methods: `withSum`, `withAverage`, `withCount`, `withMin`, `withMax`, `withGroupConcat`. Each requires a field name as the first argument and an optional second argument to change the alias.": "Es gibt mehrere Aggregationsmethoden: `withSum`, `withAverage`, `withCount`, `withMin`, `withMax`, `withGroupConcat`. Jede erfordert einen Feldnamen als erstes Argument und ein optionales zweites Argument, um den Alias zu ändern.",
        "Returning": "Rücksendung",
        "With `returning` additional fields can be requested in case of changes via `patch` and `delete`.": "Mit `returning` können zusätzliche Felder bei Änderungen über `patch` und `delete` abgefragt werden.",
        "Caution: Not all database adapters return fields atomically. Use transactions to ensure data consistency.": "Vorsicht! Nicht alle Datenbankadapter geben Felder atomar zurück. Verwenden Sie Transaktionen, um die Datenkonsistenz zu gewährleisten.",
        "Find": "finden.",
        "Returns an array of entries matching the specified filter.": "Gibt ein Array von Einträgen zurück, die dem angegebenen Filter entsprechen.",
        "FindOne": "FindOne",
        "Returns an item that matches the specified filter.": "Gibt ein Element zurück, das mit dem angegebenen Filter übereinstimmt.",
        "If no item is found, an `ItemNotFound` error is thrown.": "Wenn kein Element gefunden wird, wird ein Fehler \"ItemNotFound\" ausgelöst.",
        "FindOneOrUndefined": "FindOneOrUndefined",
        "Returns an entry that matches the specified filter.": "Gibt einen Eintrag zurück, der mit dem angegebenen Filter übereinstimmt.",
        "If no entry is found, undefined is returned.": "Wenn kein Eintrag gefunden wird, wird undefiniert zurückgegeben.",
        "FindField": "SucheFeld",
        "Returns a list of a field that match the specified filter.": "Gibt eine Liste der Felder zurück, die dem angegebenen Filter entsprechen.",
        "FindOneField": "FindOneField",
        "If no entry is found, an `ItemNotFound` error is thrown.": "Wenn kein Eintrag gefunden wird, wird ein Fehler \"ItemNotFound\" ausgegeben.",
        "Patch": "Aufnäher",
        "Patch is a change query that patches the records described in the query. The methods": "Patch ist eine Änderungsabfrage, die die in der Abfrage beschriebenen Datensätze korrigiert. Die Methoden",
        "`patchOne` and `patchMany` finish the query and execute the patch.": "`patchOne` und `patchMany` beenden die Abfrage und führen den Patch aus.",
        "`patchMany` changes all records in the database that match the specified filter. If no filter is set, the whole table will be changed. Use `patchOne` to change only one entry at a time.": "`patchMany` ändert alle Datensätze in der Datenbank, die dem angegebenen Filter entsprechen. Wenn kein Filter gesetzt ist, wird die gesamte Tabelle geändert. Verwenden Sie `patchOne`, um jeweils nur einen Eintrag zu ändern.",
        "Delete": "Löschen",
        "`deleteMany` deletes all entries in the database that match the specified filter.": "`deleteMany` löscht alle Einträge in der Datenbank, die dem angegebenen Filter entsprechen.",
        "If no filter is set, the whole table will be deleted. Use `deleteOne` to delete only one entry at a time.": "Wenn kein Filter gesetzt ist, wird die gesamte Tabelle gelöscht. Verwenden Sie `deleteOne`, um jeweils nur einen Eintrag zu löschen.",
        "Has": "Hat",
        "Returns whether at least one entry exists in the database.": "Gibt zurück, ob mindestens ein Eintrag in der Datenbank existiert.",
        "Count": "Zählen Sie",
        "Returns the number of entries.": "Gibt die Anzahl der Einträge zurück.",
        "Lift": "Aufzug",
        "Lifting a query means adding new functionality to it. This is usually used either by plugins or complex architectures to split larger query classes into several convenient, reusable classes.": "Das Lifting einer Abfrage bedeutet, dass ihr neue Funktionen hinzugefügt werden. Dies wird in der Regel entweder von Plugins oder komplexen Architekturen verwendet, um größere Abfrageklassen in mehrere praktische, wiederverwendbare Klassen aufzuteilen.",
        "Repository": "Repository",
        "Relations": "Beziehungen",
        "Relationships allow you to connect two entities in a certain way. This is usually done in databases using the concept of foreign keys. Deepkit ORM supports relations for all official database adapters.": "Beziehungen ermöglichen es Ihnen, zwei Entitäten auf eine bestimmte Art und Weise zu verbinden. Dies geschieht in Datenbanken in der Regel über das Konzept der Fremdschlüssel. Deepkit ORM unterstützt Beziehungen für alle offiziellen Datenbankadapter.",
        "A relation is annotated with the `reference` decorator. Usually a relation also has a reverse relation, which is annotated with the `BackReference` type, but is only needed if the reverse relation is to be used in a database query. Back references are only virtual.": "Eine Beziehung wird mit dem Dekorator `reference` kommentiert. Normalerweise hat eine Beziehung auch eine umgekehrte Beziehung, die mit dem Typ `BackReference` annotiert ist, aber nur benötigt wird, wenn die umgekehrte Beziehung in einer Datenbankabfrage verwendet werden soll. Rückreferenzen sind nur virtuell.",
        "One To Many": "Einer zu vielen",
        "The entity that stores a reference is usually referred to as the `owning page` or the one that `owns` the reference. The following code shows two entities with a one-to-many relationship between `User` and `Post`. This means that one `User` can have multiple `Post`. The `post` entity has the `post->user` relationship. In the database itself there is now a field `Post. \"author\"` that contains the primary key of `User`.": "Die Entität, die einen Verweis speichert, wird in der Regel als die \"besitzende Seite\" oder diejenige, die den Verweis \"besitzt\", bezeichnet. Der folgende Code zeigt zwei Entitäten mit einer Eins-zu-Viel-Beziehung zwischen \"User\" und \"Post\". Das bedeutet, dass ein `User` mehrere `Post` haben kann. Die Entität \"Post\" hat die Beziehung \"Post->User\". In der Datenbank selbst gibt es nun ein Feld `Post. author\", das den Primärschlüssel von \"User\" enthält.",
        "References are not selected in queries by default. See <<database-join>> for details.": "Referenzen werden in Abfragen standardmäßig nicht ausgewählt. Siehe <<database-join>> für Details.",
        "Many To One": "Viele zu Eins",
        "A reference usually has a reverse reference called many-to-one. It is only a virtual reference, since it is not reflected in the database itself. A back reference is annotated `BackReference` and is mainly used for reflection and query joins. If you add a `BackReference` from `User` to `Post`, you can join `Post` directly from `User` queries.": "Eine Referenz hat in der Regel eine umgekehrte Referenz, die many-to-one genannt wird. Es handelt sich nur um eine virtuelle Referenz, da sie nicht in der Datenbank selbst reflektiert wird. Ein Rückverweis wird als `BackReference` bezeichnet und wird hauptsächlich für Reflection und Query Joins verwendet. Wenn Sie eine `BackReference` von `User` zu `Post` hinzufügen, können Sie `Post` direkt aus `User`-Abfragen verbinden.",
        "Many To Many": "Viele an Viele",
        "A many-to-many relationship allows you to associate many records with many others. For example, it can be used for users in groups. A user can be in none, one or many groups. Consequently, a group can contain 0, one or many users.": "Eine Many-to-many-Beziehung ermöglicht es Ihnen, viele Datensätze mit vielen anderen zu verknüpfen. Sie kann zum Beispiel für Benutzer in Gruppen verwendet werden. Ein Benutzer kann in keiner, einer oder vielen Gruppen sein. Folglich kann eine Gruppe 0, einen oder viele Benutzer enthalten.",
        "Many-to-many relationships are usually implemented using a pivot entity. The pivot entity contains the actual own references to two other entities, and these two entities have back references to the pivot entity.": "Many-to-many-Beziehungen werden in der Regel mit einer Pivot-Entität implementiert. Die Pivot-Entität enthält die eigentlichen eigenen Referenzen auf zwei andere Entitäten, und diese beiden Entitäten haben Rückreferenzen auf die Pivot-Entität.",
        "With these entities, you can now create users and groups and connect them to the pivot entity. By using a back reference in User, we can retrieve the groups directly with a User query.": "Mit diesen Entitäten können Sie nun Benutzer und Gruppen erstellen und sie mit der Pivot-Entität verbinden. Durch die Verwendung eines Rückverweises in User können wir die Gruppen direkt mit einer User-Abfrage abrufen.",
        "To unlink a user from a group, the UserGroup record is deleted:": "Um die Verknüpfung eines Benutzers mit einer Gruppe aufzuheben, wird der UserGroup-Datensatz gelöscht:",
        "One To One": "Eins zu Eins",
        "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT": "Bei Löschen/Aktualisieren: EINSCHRÄNKEN | KASKADIEREN | NULL SETZEN | KEINE AKTION | STANDARD SETZEN",
        "Inheritance": "Vererbung",
        "Table Per Class": "Tabelle pro Klasse",
        "Single Table Inheritance": "Einzelne Tabellenvererbung",
        "Index": "Index",
        "Case Sensitivity": "Sensibilität für Groß- und Kleinschreibung",
        "Character Sets": "Zeichensätze",
        "Collations": "Zusammenstellungen",
        "Batching": "Dosierung",
        "Caching": "Caching",
        "Multitenancy": "Mehrmandantenfähigkeit",
        "Events are a way to hook into Deepkit ORM and allow you to write powerful plugins. There are two categories of events: Query events and Unit-of-Work events. Plugin authors typically use both to support both ways of manipulating data.": "Ereignisse sind eine Möglichkeit, sich in Deepkit ORM einzuklinken und ermöglichen es Ihnen, leistungsfähige Plugins zu schreiben. Es gibt zwei Kategorien von Ereignissen: Abfrageereignisse und Unit-of-Work-Ereignisse. Plugin-Autoren verwenden in der Regel beide, um beide Arten der Datenmanipulation zu unterstützen.",
        "Events are registered via `Database.listen` un an event token. Short-lived event listeners can also be registered on sessions.": "Ereignisse werden über `Database.listen` un ein Ereignis-Token registriert. Kurzlebige Ereignis-Listener können auch für Sitzungen registriert werden.",
        "Query Events": "Ereignisse abfragen",
        "Query events are triggered when a query is executed via `Database.query()` or `Session.query()`.": "Abfrageereignisse werden ausgelöst, wenn eine Abfrage über `Database.query()` oder `Session.query()` ausgeführt wird.",
        "Each event has its own additional properties such as the type of entity, the query itself and the database session. You can override the query by setting a new query to `Event.query`.": "Jedes Ereignis hat seine eigenen zusätzlichen Eigenschaften wie die Art der Entität, die Abfrage selbst und die Datenbanksitzung. Sie können die Abfrage außer Kraft setzen, indem Sie eine neue Abfrage auf \"Event.query\" setzen.",
        "\"Query\" has several event tokens:": "\"Abfrage\" hat mehrere Ereignis-Token:",
        "Unit Of Work Events": "Unit of Work Ereignisse",
        "Unit-of-work events are triggered when a new session submits changes.": "Unit-of-Work-Ereignisse werden ausgelöst, wenn eine neue Sitzung Änderungen einreicht.",
        "Transactions": "Transaktionen",
        "A transaction is a sequential group of statements, queries, or operations such as select, insert, update, or delete that are executed as a single unit of work that can be committed or rolled back.": "Eine Transaktion ist eine sequentielle Gruppe von Anweisungen, Abfragen oder Operationen wie Select, Insert, Update oder Delete, die als eine einzige Arbeitseinheit ausgeführt werden, die bestätigt oder rückgängig gemacht werden kann.",
        "Deepkit supports transactions for all officially supported databases. By default, no transactions are used for any query or database session. To enable transactions, there are two main methods: sessions and callback.": "Deepkit unterstützt Transaktionen für alle offiziell unterstützten Datenbanken. Standardmäßig werden keine Transaktionen für eine Abfrage oder Datenbanksitzung verwendet. Um Transaktionen zu aktivieren, gibt es zwei Hauptmethoden: Sitzungen und Callback.",
        "Session Transactions": "Sitzungstransaktionen",
        "You can start and assign a new transaction for each session you create. This is the preferred way of interacting with the database, as you can easily pass on the Session object and all queries instantiated by this session will be automatically assigned to its transaction.": "Sie können für jede Sitzung, die Sie erstellen, eine neue Transaktion starten und zuweisen. Dies ist die bevorzugte Art der Interaktion mit der Datenbank, da Sie das Session-Objekt einfach weitergeben können und alle Abfragen, die von dieser Session instanziiert werden, automatisch ihrer Transaktion zugewiesen werden.",
        "A typical pattern is to wrap all operations in a try-catch block and execute `commit()` on the very last line (which is only executed if all previous commands succeeded) and `rollback()` in the catch block to roll back all changes as soon as an error occurs.": "Ein typisches Muster ist, alle Operationen in einen try-catch-Block zu verpacken und `commit()` in der allerletzten Zeile auszuführen (das nur ausgeführt wird, wenn alle vorherigen Befehle erfolgreich waren) und `rollback()` im catch-Block, um alle Änderungen zurückzunehmen, sobald ein Fehler auftritt.",
        "Although there is an alternative API (see below), all transactions work only with database session objects. To commit open changes from the unit-of-work in a database session to the database, `commit()` is normally called. In a transactional session, `commit()` not only commits all pending changes to the database, but also completes (\"commits\") the transaction, thus closing the transaction. Alternatively, you can call `session.flush()` to commit all pending changes without `commit` and thus without closing the transaction. To commit a transaction without flushing the unit-of-work, use `session.commitTransaction()`.": "Obwohl es eine alternative API gibt (siehe unten), funktionieren alle Transaktionen nur mit Datenbanksitzungsobjekten. Um offene Änderungen aus der Unit-of-Work in einer Datenbanksitzung an die Datenbank zu übertragen, wird normalerweise `commit()` aufgerufen. In einer transaktionalen Sitzung überträgt `commit()` nicht nur alle anstehenden Änderungen an die Datenbank, sondern schließt auch die Transaktion ab (\"commits\") und schließt damit die Transaktion. Alternativ können Sie `session.flush()` aufrufen, um alle anstehenden Änderungen ohne `commit` und damit ohne Abschluss der Transaktion zu übertragen. Um eine Transaktion ohne Flush der Unit-of-Work zu committen, verwenden Sie `session.commitTransaction()`.",
        "Once `commit()` or `rollback()` is executed in a session, the transaction is released. You must then call `useTransaction()` again if you want to continue in a new transaction.": "Sobald `commit()` oder `rollback()` in einer Sitzung ausgeführt wurde, wird die Transaktion freigegeben. Sie müssen dann `useTransaction()` erneut aufrufen, wenn Sie in einer neuen Transaktion fortfahren wollen.",
        "Please note that once the first database operation is executed in a transactional session, the assigned database connection becomes fixed and exclusive to the current session object (sticky). Thus, all subsequent operations will be performed on the same connection (and thus, in most databases, on the same database server). Only when either the transactional session is terminated (commit or rollback), the database connection is released again. It is therefore recommended to keep a transaction only as short as necessary.": "Bitte beachten Sie, dass, sobald die erste Datenbankoperation in einer transaktionalen Sitzung ausgeführt wird, die zugewiesene Datenbankverbindung fest und exklusiv für das aktuelle Sitzungsobjekt wird (sticky). Somit werden alle nachfolgenden Operationen auf derselben Verbindung (und damit in den meisten Datenbanken auf demselben Datenbankserver) ausgeführt. Erst wenn entweder die transaktionale Sitzung beendet wird (Commit oder Rollback), wird die Datenbankverbindung wieder freigegeben. Es ist daher empfehlenswert, eine Transaktion nur so kurz wie nötig zu halten.",
        "If a session is already connected to a transaction, a call to `session.useTransaction()` always returns the same object. Use `session.isTransaction()` to check if a transaction is associated with the session.": "Wenn eine Sitzung bereits mit einer Transaktion verbunden ist, gibt ein Aufruf von `session.useTransaction()` immer das gleiche Objekt zurück. Verwenden Sie `session.isTransaction()`, um zu prüfen, ob eine Transaktion mit der Sitzung verbunden ist.",
        "Nested transactions are not supported.": "Verschachtelte Transaktionen werden nicht unterstützt.",
        "Transaktion Callback": "Transaktion Callback",
        "An alternative to transactional sessions is `database.transaction(callback)`.": "Eine Alternative zu Transaktionssitzungen ist `database.transaction(callback)`.",
        "The `database.transaction(callback)` method performs an asynchronous callback within a new transactional session. If the callback succeeds (that is, no error is thrown), the session is automatically committed (and thus its transaction committed and all changes flushed). If the callback fails, the session automatically executes `rollback()` and the error is propagated.": "Die Methode `database.transaction(callback)` führt einen asynchronen Callback innerhalb einer neuen transaktionalen Sitzung durch. Wenn der Callback erfolgreich ist (d.h. kein Fehler ausgelöst wird), wird die Sitzung automatisch committed (und damit die Transaktion committed und alle Änderungen geleert). Schlägt der Callback fehl, führt die Sitzung automatisch `rollback()` aus und der Fehler wird weitergegeben.",
        "Isolations": "Isolierungen",
        "Many databases support different types of transactions. To change the transaction behavior, you can call different methods for the returned transaction object from `useTransaction()`. The interface of this transaction object depends on the database adapter used. For example, the transaction object returned from a MySQL database has different options than the one returned from a MongoDB database. Use code completion or view the database adapter's interface to get a list of possible options.": "Viele Datenbanken unterstützen verschiedene Arten von Transaktionen. Um das Transaktionsverhalten zu ändern, können Sie verschiedene Methoden für das zurückgegebene Transaktionsobjekt von `useTransaction()` aufrufen. Die Schnittstelle dieses Transaktionsobjekts hängt von dem verwendeten Datenbankadapter ab. Zum Beispiel hat das Transaktionsobjekt, das von einer MySQL-Datenbank zurückgegeben wird, andere Optionen als das, das von einer MongoDB-Datenbank zurückgegeben wird. Verwenden Sie die Codevervollständigung oder sehen Sie sich die Schnittstelle des Datenbankadapters an, um eine Liste der möglichen Optionen zu erhalten.",
        "While transactions for MySQL, PostgreSQL, and SQLite work by default, you must first set up MongoDB as a \"replica set\".": "Während Transaktionen für MySQL, PostgreSQL und SQLite standardmäßig funktionieren, müssen Sie MongoDB zunächst als \"Replikatsatz\" einrichten.",
        "To convert a standard MongoDB instance to a replica set, please refer to the official documentation link:https://docs.mongodb.com/manual/tutorial/convert-standalone-to-replica-set/[Convert a Standalone to a Replica Set].": "Um eine Standard-MongoDB-Instanz in ein Replikatset zu konvertieren, lesen Sie bitte den offiziellen Dokumentationslink:https://docs.mongodb.com/manual/tutorial/convert-standalone-to-replica-set/[Convert a Standalone to a Replica Set].",
        "Locking": "Verriegelung",
        "Optimistic Locking": "Optimistische Verriegelung",
        "Pessimistic Locking": "Pessimistische Sperrung",
        "Custom Types": "Benutzerdefinierte Typen",
        "Logging": "Protokollierung",
        "Migration": "Migration",
        "Seeding": "Aussaat",
        "Raw Database Access": "Roher Datenbankzugriff",
        "SQL": "SQL",
        "App Configuration": "App-Konfiguration",
        "Composite Primary Key": "Zusammengesetzter Primärschlüssel",
        "Composite Primary-Key means, an entity has several primary keys, which are automatically combined to a \"composite primary key\". This way of modeling the database has advantages and disadvantages. We believe that composite primary keys have huge practical disadvantages that do not justify their advantages, so they should be considered bad practice and therefore avoided. Deepkit ORM does not support composite primary keys. In this chapter we explain why and show (better) alternatives.": "Composite Primary-Key bedeutet, dass eine Entität mehrere Primärschlüssel hat, die automatisch zu einem \"Composite Primary Key\" zusammengefasst werden. Diese Art der Modellierung der Datenbank hat Vor- und Nachteile. Wir glauben, dass zusammengesetzte Primärschlüssel enorme praktische Nachteile haben, die ihre Vorteile nicht rechtfertigen, so dass sie als schlechte Praxis betrachtet und daher vermieden werden sollten. Deepkit ORM unterstützt keine zusammengesetzten Primärschlüssel. In diesem Kapitel erklären wir warum und zeigen (bessere) Alternativen auf.",
        "Disadvantages": "Benachteiligungen",
        "Joins are not trivial. Although they are highly optimized in RDBMS, they represent a constant complexity in applications that can easily get out of hand and lead to performance problems. Performance not only in terms of query execution time, but also in terms of development time.": "Joins sind nicht trivial. Obwohl sie in RDBMS hochgradig optimiert sind, stellen sie eine konstante Komplexität in Anwendungen dar, die leicht aus dem Ruder laufen und zu Leistungsproblemen führen kann. Leistung nicht nur in Bezug auf die Ausführungszeit der Abfrage, sondern auch in Bezug auf die Entwicklungszeit.",
        "Joins": "Beitritt zu",
        "Each individual join becomes more complicated as more fields are involved. While many databases have implemented optimizations to make joins with multiple fields not slower per se, it requires the developer to constantly think through these joins in detail, since forgetting keys, for example, can lead to subtle errors (since the join will work even without specifying all keys) and the developer therefore needs to know the full composite primary key structure.": "Jede einzelne Verknüpfung wird komplizierter, je mehr Felder beteiligt sind. Zwar haben viele Datenbanken Optimierungen implementiert, um Joins mit mehreren Feldern nicht per se langsamer zu machen, doch muss der Entwickler diese Joins ständig im Detail durchdenken, da z. B. das Vergessen von Schlüsseln zu subtilen Fehlern führen kann (da der Join auch ohne Angabe aller Schlüssel funktioniert) und der Entwickler daher die vollständige zusammengesetzte Primärschlüsselstruktur kennen muss.",
        "Indizes": "Zeigt  an.",
        "Indexes with multiple fields (which are composite primary keys) suffer from the problem of field ordering in queries. While database systems can optimize certain queries, complex structures make it difficult to write efficient operations that correctly use all defined indexes. For an index with multiple fields (such as a composite primary key), it is usually necessary to define the fields in the correct order for the database to actually use the index. If the order is not specified correctly (for example, in a WHERE clause), this can easily result in the database not using the index at all and instead performing a full table scan. Knowing which database query optimizes in which way is advanced knowledge that new developers don't usually have, but is necessary once you start working with composite primary keys so that you get the most out of your database and don't waste resources.": "Indizes mit mehreren Feldern (die zusammengesetzte Primärschlüssel sind) leiden unter dem Problem der Feldreihenfolge in Abfragen. Während Datenbanksysteme bestimmte Abfragen optimieren können, erschweren komplexe Strukturen das Schreiben effizienter Operationen, die alle definierten Indizes korrekt verwenden. Bei einem Index mit mehreren Feldern (z. B. einem zusammengesetzten Primärschlüssel) ist es in der Regel erforderlich, die Felder in der richtigen Reihenfolge zu definieren, damit die Datenbank den Index tatsächlich verwenden kann. Wenn die Reihenfolge nicht korrekt angegeben ist (z. B. in einer WHERE-Klausel), kann dies leicht dazu führen, dass die Datenbank den Index überhaupt nicht verwendet und stattdessen eine vollständige Tabellendurchsuchung durchführt. Zu wissen, welche Datenbankabfrage auf welche Weise optimiert wird, ist ein fortgeschrittenes Wissen, über das neue Entwickler in der Regel nicht verfügen, das aber notwendig ist, sobald Sie anfangen, mit zusammengesetzten Primärschlüsseln zu arbeiten, damit Sie das Beste aus Ihrer Datenbank herausholen und keine Ressourcen verschwenden.",
        "Migrationen": "Migrationen",
        "Once you decide that a particular entity needs an additional field to uniquely identify it (and thus become the Composite Primary Key), this will result in the adjustment of all entities in your database that have relationships to that entity.": "Sobald Sie entscheiden, dass eine bestimmte Entität ein zusätzliches Feld benötigt, um sie eindeutig zu identifizieren (und somit zum zusammengesetzten Primärschlüssel zu werden), führt dies zur Anpassung aller Entitäten in Ihrer Datenbank, die Beziehungen zu dieser Entität haben.",
        "For example, suppose you have an entity `user` with composite primary key and decide to use a foreign key to this `user` in different tables, e.g. in a pivot table `audit_log`, `groups` and `posts`. Once you change the primary key of `user`, all these tables need to be adjusted in a migration as well.": "Angenommen, Sie haben eine Entität \"user\" mit einem zusammengesetzten Primärschlüssel und möchten einen Fremdschlüssel zu diesem \"user\" in verschiedenen Tabellen verwenden, z. B. in einer Pivot-Tabelle \"audit_log\", \"groups\" und \"posts\". Sobald Sie den Primärschlüssel von \"user\" ändern, müssen alle diese Tabellen bei einer Migration ebenfalls angepasst werden.",
        "Not only does this make migration files much more complex, but it can also cause major downtime when running migration files, since schema changes usually require either a full database lock or at least a table lock. The more tables affected by a large change like an index change, the longer the migration will take. And the larger a table is, the longer the migration takes.": "Dies macht Migrationsdateien nicht nur viel komplexer, sondern kann auch zu erheblichen Ausfallzeiten bei der Ausführung von Migrationsdateien führen, da Schemaänderungen normalerweise entweder eine vollständige Datenbanksperre oder zumindest eine Tabellensperre erfordern. Je mehr Tabellen von einer großen Änderung wie einer Indexänderung betroffen sind, desto länger wird die Migration dauern. Und je größer eine Tabelle ist, desto länger dauert die Migration.",
        "Consider the `audit_log` table. Such tables usually have many records (millions or so), and you have to touch them during a schema change only because you decided to use a composite primary key and add an extra field to the primary key of `user`. Depending on the size of all these tables, this either makes migration changes unnecessarily more expensive or, in some cases, so expensive that changing the primary key of `User` is no longer financially justifiable. This usually leads to workarounds (e.g. adding a unique index to the user table) that result in technical debt and sooner or later end up on the legacy list.": "Nehmen wir die Tabelle `audit_log`. Solche Tabellen haben in der Regel viele Datensätze (Millionen oder so), und Sie müssen sie bei einer Schemaänderung nur deshalb anfassen, weil Sie beschlossen haben, einen zusammengesetzten Primärschlüssel zu verwenden und dem Primärschlüssel von \"user\" ein zusätzliches Feld hinzuzufügen. Je nach Größe all dieser Tabellen macht dies Migrationsänderungen entweder unnötig teurer oder in einigen Fällen so teuer, dass eine Änderung des Primärschlüssels von \"user\" finanziell nicht mehr vertretbar ist. Dies führt in der Regel zu Umgehungslösungen (z. B. Hinzufügen eines eindeutigen Index zur Benutzertabelle), die zu technischen Schulden führen und früher oder später auf der Altlastenliste landen.",
        "For large projects, this can lead to huge downtime (from minutes to hours) and sometimes even the introduction of an entirely new migration abstraction system that essentially copies tables, inserts records into ghost tables, and moves tables back and forth after migration. This added complexity is in turn imposed on any entity that has a relationship to another entity with a composite primary key, and becomes greater the larger your database structure becomes. The problem gets worse with no way to solve it (except by removing the composite primary key entirely).": "Bei großen Projekten kann dies zu enormen Ausfallzeiten (von Minuten bis Stunden) und manchmal sogar zur Einführung eines völlig neuen Migrationsabstraktionssystems führen, das im Wesentlichen Tabellen kopiert, Datensätze in Geistertabellen einfügt und Tabellen nach der Migration hin und her verschiebt. Diese zusätzliche Komplexität wird wiederum jeder Entität auferlegt, die eine Beziehung zu einer anderen Entität mit einem zusammengesetzten Primärschlüssel hat, und wird umso größer, je größer Ihre Datenbankstruktur wird. Das Problem verschlimmert sich, und es gibt keine Möglichkeit, es zu lösen (es sei denn, man entfernt den zusammengesetzten Primärschlüssel ganz).",
        "Findability": "Auffindbarkeit",
        "If you are a database administrator or Data EngineerScientist, you usually work directly on the database and explore the data when you need it. With composite primary keys, any user writing SQL directly must know the correct primary key of all tables involved (and the column order to get correct index optimizations). This added overhead not only complicates data exploration, report generation, etc., but can also lead to errors in older SQL if a composite primary key is suddenly changed. The old SQL is probably still valid and running fine, but suddenly returns incorrect results because the new field in the composite primary key is missing from the join. It is much easier here to have only one primary key. This makes it easier to find data and ensures that old SQL queries will still work correctly if you decide to change the way a user object is uniquely identified, for example.": "Als Datenbankadministrator oder Data EngineerScientist arbeiten Sie in der Regel direkt an der Datenbank und untersuchen die Daten, wenn Sie sie benötigen. Bei zusammengesetzten Primärschlüsseln muss jeder Benutzer, der SQL direkt schreibt, den korrekten Primärschlüssel aller beteiligten Tabellen kennen (und die Spaltenreihenfolge, um korrekte Indexoptimierungen zu erhalten). Dieser zusätzliche Overhead erschwert nicht nur die Datenexploration, die Erstellung von Berichten usw., sondern kann auch zu Fehlern in älterem SQL führen, wenn ein zusammengesetzter Primärschlüssel plötzlich geändert wird. Das alte SQL ist wahrscheinlich immer noch gültig und läuft einwandfrei, liefert aber plötzlich falsche Ergebnisse, weil das neue Feld im zusammengesetzten Primärschlüssel in der Verknüpfung fehlt. Hier ist es viel einfacher, nur einen Primärschlüssel zu haben. Dies erleichtert das Auffinden von Daten und stellt sicher, dass alte SQL-Abfragen weiterhin korrekt funktionieren, wenn Sie z. B. die Art und Weise ändern, wie ein Benutzerobjekt eindeutig identifiziert wird.",
        "Revision": "Revision",
        "Once a composite primary key is used in an entity, refactoring the key can result in significant additional refactoring. Because an entity with a composite primary key typically does not have a single unique field, all filters and links must contain all values of the composite key. This usually means that the code relies on knowing the composite primary key, so all fields must be retrieved (e.g., for URLs like user:key1:key2). Once this key is changed, all places where this knowledge is explicitly used, such as URLs, custom SQL queries, and other places, must be rewritten.": "Sobald ein zusammengesetzter Primärschlüssel in einer Entität verwendet wird, kann das Refactoring des Schlüssels zu einem erheblichen zusätzlichen Refactoring führen. Da eine Entität mit einem zusammengesetzten Primärschlüssel normalerweise kein einziges eindeutiges Feld hat, müssen alle Filter und Verknüpfungen alle Werte des zusammengesetzten Schlüssels enthalten. Dies bedeutet in der Regel, dass der Code auf die Kenntnis des zusammengesetzten Primärschlüssels angewiesen ist, so dass alle Felder abgerufen werden müssen (z. B. für URLs wie user:key1:key2). Sobald dieser Schlüssel geändert wird, müssen alle Stellen, an denen dieses Wissen explizit verwendet wird, wie URLs, benutzerdefinierte SQL-Abfragen und andere Stellen, neu geschrieben werden.",
        "While ORMs typically create joins automatically without manually specifying the values, they cannot automatically cover refactoring for all other use cases such as URL structures or custom SQL queries, and especially not for places where the ORM is not used at all, such as in reporting systems and all external systems.": "Während ORMs Joins in der Regel automatisch erstellen, ohne dass die Werte manuell angegeben werden müssen, können sie das Refactoring für alle anderen Anwendungsfälle wie URL-Strukturen oder benutzerdefinierte SQL-Abfragen nicht automatisch abdecken, und vor allem nicht für Bereiche, in denen das ORM überhaupt nicht verwendet wird, wie z. B. in Berichtssystemen und allen externen Systemen.",
        "ORM complexity": "ORM-Komplexität",
        "With the support of composite primary keys, the complexity of the code of a powerful ORM like Deepkit ORM increases tremendously. Not only will the code and maintenance become more complex and therefore more expensive, but there will be more edge cases from users that need to be fixed and maintained. The complexity of the query layer, change detection, migration system, internal relationship tracking, etc. increases significantly. The overall cost associated with building and supporting an ORM with composite primary keys is too high, all things considered, and cannot be justified, which is why Deepkit does not support it.": "Mit der Unterstützung von zusammengesetzten Primärschlüsseln steigt die Komplexität des Codes eines leistungsstarken ORM wie Deepkit ORM enorm. Nicht nur der Code und die Wartung werden komplexer und damit teurer, sondern es gibt auch mehr Randfälle von Benutzern, die behoben und gewartet werden müssen. Die Komplexität der Abfrageschicht, der Änderungserkennung, des Migrationssystems, der Verfolgung interner Beziehungen usw. nimmt erheblich zu. Die Gesamtkosten, die mit dem Aufbau und der Unterstützung eines ORM mit zusammengesetzten Primärschlüsseln verbunden sind, sind alles in allem zu hoch und nicht zu rechtfertigen, weshalb Deepkit sie nicht unterstützt.",
        "Advantages": "Vorteile",
        "Apart from this, composite primary keys also have advantages, albeit very superficial ones. By using as few indexes as possible for each table, writing (inserting/updating) data becomes more efficient, since fewer indexes need to be maintained. It also makes the structure of the model a bit cleaner (since it usually has one less column). However, the difference between a sequentially ordered, automatically incrementing primary key and a non-incrementing primary key is completely negligible these days, since disk space is cheap and the operation is usually just an \"append-only\" operation, which is very fast.": "Abgesehen davon haben zusammengesetzte Primärschlüssel auch Vorteile, wenn auch sehr oberflächliche. Durch die Verwendung möglichst weniger Indizes für jede Tabelle wird das Schreiben (Einfügen/Aktualisieren) von Daten effizienter, da weniger Indizes gepflegt werden müssen. Auch die Struktur des Modells wird dadurch etwas übersichtlicher (da es in der Regel eine Spalte weniger hat). Der Unterschied zwischen einem sequentiell geordneten, automatisch inkrementierenden Primärschlüssel und einem nicht inkrementierenden Primärschlüssel ist heutzutage jedoch völlig vernachlässigbar, da der Speicherplatz auf der Festplatte billig ist und die Operation in der Regel nur eine \"Append-only\"-Operation ist, die sehr schnell ist.",
        "There may certainly be a few edge cases (and for a few very specific database systems) where it is initially better to work with composite primary keys. But even in these systems, it might make more sense overall (considering all the costs) not to use them and to switch to another strategy.": "Es mag sicherlich einige Grenzfälle geben (und für einige sehr spezifische Datenbanksysteme), in denen es zunächst besser ist, mit zusammengesetzten Primärschlüsseln zu arbeiten. Aber selbst in diesen Systemen könnte es insgesamt (unter Berücksichtigung aller Kosten) sinnvoller sein, sie nicht zu verwenden und zu einer anderen Strategie zu wechseln.",
        "Alternative": "Alternative",
        "An alternative to composite primary keys is to use a single automatically incrementing numeric primary key, usually called \"id\", and move the composite primary key to a unique index with multiple fields. Depending on the primary key used (depending on the expected number of rows), the \"id\" uses either 4 or 8 bytes per record.": "Eine Alternative zu zusammengesetzten Primärschlüsseln ist die Verwendung eines einzigen, automatisch inkrementierenden numerischen Primärschlüssels, in der Regel \"id\" genannt, und die Verlagerung des zusammengesetzten Primärschlüssels in einen eindeutigen Index mit mehreren Feldern. Je nach verwendetem Primärschlüssel (abhängig von der erwarteten Anzahl der Zeilen) verwendet \"id\" entweder 4 oder 8 Bytes pro Datensatz.",
        "By using this strategy, you are no longer forced to think about the problems described above and find a solution, which enormously reduces the cost of ever-growing projects.": "Mit dieser Strategie sind Sie nicht mehr gezwungen, über die oben beschriebenen Probleme nachzudenken und eine Lösung zu finden, was die Kosten für immer größer werdende Projekte enorm reduziert.",
        "The strategy specifically means that each entity has an \"id\" field, usually at the very beginning, and this field is then used to identify unique rows by default and in joins.": "Die Strategie bedeutet konkret, dass jede Entität ein \"id\"-Feld hat, normalerweise ganz am Anfang, und dieses Feld wird dann verwendet, um eindeutige Zeilen standardmäßig und in Joins zu identifizieren.",
        "As an alternative to a composite primary key, you would use a unique multi-field index instead.": "Als Alternative zu einem zusammengesetzten Primärschlüssel können Sie stattdessen einen eindeutigen Mehrfeldindex verwenden.",
        "Deepkit ORM automatically supports incremental primary keys, including for MongoDB. This is the preferred method for identifying records in your database. However, for MongoDB you can use the ObjectId (`_id: MongoId & PrimaryKey = ''`) as a simple primary key. An alternative to the numeric, auto-incrementing primary key is a UUID, which works just as well (but has slightly different performance characteristics, since indexing is more expensive).": "Deepkit ORM unterstützt automatisch inkrementelle Primärschlüssel, auch für MongoDB. Dies ist die bevorzugte Methode zur Identifizierung von Datensätzen in Ihrer Datenbank. Für MongoDB können Sie jedoch die ObjectId (`_id: MongoId & PrimaryKey = ''`) als einfachen Primärschlüssel verwenden. Eine Alternative zum numerischen, automatisch inkrementierenden Primärschlüssel ist eine UUID, die genauso gut funktioniert (aber etwas andere Leistungsmerkmale hat, da die Indizierung teurer ist).",
        "Summary": "Zusammenfassung",
        "Composite primary keys essentially mean that once they are in place, all future changes and practical use come at a much higher cost. While it looks like a clean architecture at the beginning (because you have one less column), it leads to significant practical costs once the project is actually developed, and the costs continue to increase as the project gets larger.": "Zusammengesetzte Primärschlüssel bedeuten im Wesentlichen, dass alle zukünftigen Änderungen und die praktische Verwendung mit viel höheren Kosten verbunden sind. Während es zu Beginn wie eine saubere Architektur aussieht (weil Sie eine Spalte weniger haben), führt es zu erheblichen praktischen Kosten, sobald das Projekt tatsächlich entwickelt ist, und die Kosten steigen weiter, wenn das Projekt größer wird.",
        "Looking at the asymmetries between benefits and drawbacks, it is clear that composite primary keys cannot be justified in most cases. The costs are much greater than the benefits. Not only for you as a user, but also for us as the author and maintainer of the ORM code. For this reason, Deepkit ORM does not support composite primary keys.": "Betrachtet man die Asymmetrien zwischen Vor- und Nachteilen, so wird deutlich, dass zusammengesetzte Primärschlüssel in den meisten Fällen nicht zu rechtfertigen sind. Die Kosten sind viel größer als der Nutzen. Nicht nur für Sie als Benutzer, sondern auch für uns als Autor und Betreuer des ORM-Codes. Aus diesem Grund unterstützt der Deepkit ORM keine zusammengesetzten Primärschlüssel.",
        "Plugins": "Plugins",
        "Soft-Delete": "Soft-Delete",
        "The Soft-Delete plugin allows to keep database records hidden without actually deleting them. When a record is deleted, it is only marked as deleted and not actually deleted. All queries automatically filter for this deleted property, so it feels to the user as if it is actually deleted.": "Das Soft-Delete-Plugin ermöglicht es, Datenbankeinträge verborgen zu halten, ohne sie tatsächlich zu löschen. Wenn ein Datensatz gelöscht wird, wird er nur als gelöscht markiert und nicht tatsächlich gelöscht. Alle Abfragen filtern automatisch nach dieser gelöschten Eigenschaft, so dass es sich für den Benutzer so anfühlt, als ob er tatsächlich gelöscht wäre.",
        "To use the plugin, you must instantiate the SoftDelete class and enable it for each entity.": "Um das Plugin zu verwenden, müssen Sie die SoftDelete-Klasse instanziieren und sie für jede Entität aktivieren.",
        "To soft-delete records, use the usual methods: `deleteOne` or `deleteMany` in a query, or use the session to delete them. The soft-delete plugin will do the rest automatically in the background.": "Um Datensätze sanft zu löschen, verwenden Sie die üblichen Methoden: `deleteOne` oder `deleteMany` in einer Abfrage, oder verwenden Sie die Sitzung, um sie zu löschen. Das Soft-Delete-Plugin erledigt den Rest automatisch im Hintergrund.",
        "Restore": "Wiederherstellen",
        "Deleted records can be restored using a cancelled query via `SoftDeleteQuery`. It has `restoreOne` and `restoreMany`.": "Gelöschte Datensätze können mit einer abgebrochenen Abfrage über `SoftDeleteQuery` wiederhergestellt werden. Es gibt `restoreOne` und `restoreMany`.",
        "The session also supports element recovery.": "Die Sitzung unterstützt auch die Wiederherstellung von Elementen.",
        "Hard Delete": "Hartes Löschen",
        "To hard delete records, use a lifted query via SoftDeleteQuery. This essentially restores the old behavior without the single query plugin.": "Um Datensätze hart zu löschen, verwenden Sie eine gehobene Abfrage über SoftDeleteQuery. Dies stellt im Wesentlichen das alte Verhalten ohne das Einzelabfrage-Plugin wieder her.",
        "Query deleted.": "Abfrage gelöscht.",
        "With a \"lifted\" query via `SoftDeleteQuery` you can also include deleted records.": "Mit einer \"gehobenen\" Abfrage über `SoftDeleteQuery` können Sie auch gelöschte Datensätze einbeziehen.",
        "Deleted by": "Gelöscht von",
        "`deletedBy` can be set via query and sessions.": "`deletedBy` kann über Abfrage und Sitzungen festgelegt werden.",
        "Template": "Template",
        "The template engine allows to write type-safe, fast and secure HTML templates. It is based on TSX and is ready to use as soon as you use the `.tsx` file extension and adjust the `tsconfig.json` accordingly.": "Die Template-Engine erlaubt es, typsichere, schnelle und sichere HTML-Templates zu schreiben. Sie basiert auf TSX und ist sofort einsatzbereit, sobald Sie die Dateierweiterung `.tsx` verwenden und die `tsconfig.json` entsprechend anpassen.",
        "The important thing is: it is not compatible with React. As soon as React is to be used, `@deepkit/template` is incompatible. Deepkit's template engine is only intended for SSR (server-side rendering).": "Das Wichtigste ist: es ist nicht kompatibel mit React. Sobald React verwendet werden soll, ist `@deepkit/template` inkompatibel. Die Template-Engine von Deepkit ist nur für SSR (server-side rendering) gedacht.",
        "In your tsconfig you have to adjust following settings: `jsx` and `jsxImportSource`": "In Ihrer tsconfig müssen Sie folgende Einstellungen vornehmen: `jsx` und `jsxImportSource`",
        "Now you can use TSX directly in your controller.": "Jetzt können Sie TSX direkt in Ihrem Controller verwenden.",
        "When you return such a TSX in your route method, the HTTP content type is automatically set to `texthtml; charset=utf-8`.": "Wenn Sie einen solchen TSX in Ihrer Routenmethode zurückgeben, wird der HTTP-Inhaltstyp automatisch auf `texthtml; charset=utf-8` gesetzt.",
        "Components": "Komponenten",
        "You can structure your templates the way you are used to in React. Either modularize your layout into multiple function or class components.": "Sie können Ihre Vorlagen so strukturieren, wie Sie es in React gewohnt sind. Entweder modularisieren Sie Ihr Layout in mehrere Funktions- oder Klassenkomponenten.",
        "Function Components": "Funktion Komponenten",
        "The easiest way is to use a function that returns TSX.": "Am einfachsten ist es, eine Funktion zu verwenden, die TSX zurückgibt.",
        "Function components can be asynchronous (unlike in React). This is an important difference from other template engines you may be familiar with, like React.": "Funktionskomponenten können asynchron sein (anders als in React). Dies ist ein wichtiger Unterschied zu anderen Template-Engines, mit denen Sie vielleicht vertraut sind, wie React.",
        "All functions have access to the dependency injection container and can reference any dependencies starting with the third parameter.": "Alle Funktionen haben Zugriff auf den Dependency Injection Container und können ab dem dritten Parameter auf alle Abhängigkeiten verweisen.",
        "Class Components": "Komponenten der Klasse",
        "An alternative way to write a component is a class component. They are handled and instantiated in the Dependency Injection container and thus have access to all services registered in the container. This makes it possible to directly access a data source such as a database in your components, for example.": "Eine alternative Möglichkeit, eine Komponente zu schreiben, ist eine Klassenkomponente. Sie werden im Dependency Injection Container behandelt und instanziiert und haben somit Zugriff auf alle im Container registrierten Dienste. Dadurch ist es möglich, in Ihren Komponenten direkt auf eine Datenquelle wie z. B. eine Datenbank zuzugreifen.",
        "For class components the first constructor arguments are reserved. `props` can be defined arbitrarily, `children` is always \"any\", and then optional dependencies follow, which you can choose arbitrarily. Since class components are instantiated in the Dependency Injection container, you have access to all your services.": "Für Klassenkomponenten sind die ersten Konstruktorargumente reserviert. Props\" können beliebig definiert werden, \"Children\" ist immer \"any\", und dann folgen optionale Abhängigkeiten, die Sie beliebig wählen können. Da Klassenkomponenten im Dependency Injection Container instanziiert werden, haben Sie Zugriff auf alle Ihre Dienste.",
        "Dynamic HTML": "Dynamisches HTML",
        "The template engine has automatically cleaned up all the variables used, so you can safely use user input directly in the template. To render dynamic HTML, you can use the html function.": "Die Template-Engine hat alle verwendeten Variablen automatisch bereinigt, so dass Sie die Benutzereingaben direkt in der Vorlage verwenden können. Um dynamisches HTML zu rendern, können Sie die Funktion html verwenden.",
        "Optimization": "Optimierung",
        "The template engine tries to optimize the generated JSX code so that it is much easier for NodeJSV8 to generate the HTML string. For this to work correctly, you should move all your components from the main app.tsx file to separate files. A structure might look like this:": "Die Template-Engine versucht, den generierten JSX-Code zu optimieren, so dass es für NodeJSV8 viel einfacher ist, den HTML-String zu generieren. Damit dies korrekt funktioniert, sollten Sie alle Ihre Komponenten aus der Hauptdatei app.tsx in separate Dateien verschieben. Eine Struktur könnte wie folgt aussehen:",
        "Framework": "Framework",
        "Deepkit Framework is based on runtime types in Deepkit Type. Make sure that `@deepkit/type` is installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Deepkit Framework basiert auf Laufzeittypen in Deepkit Type. Stellen Sie sicher, dass `@deepkit/type` korrekt installiert ist. Siehe xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Make sure that all peer dependencies are installed. By default, NPM 7+ installs them automatically.": "Stellen Sie sicher, dass alle Peer-Abhängigkeiten installiert sind. Standardmäßig werden sie von NPM 7+ automatisch installiert.",
        "To compile your application, we need the TypeScript compiler and recommend `ts-node` to easily run the app.": "Um Ihre Anwendung zu kompilieren, benötigen wir den TypeScript-Compiler und empfehlen `ts-node`, um die Anwendung einfach auszuführen.",
        "An alternative to using `ts-node` is to compile the source code with the TypeScript compiler and execute the JavaScript source code directly. This has the advantage of dramatically increasing execution speed for short commands. However, it also creates additional workflow overhead by either manually running the compiler or setting up a watcher. For this reason, `ts-node` is used in all examples in this documentation.": "Eine Alternative zur Verwendung von `ts-node` besteht darin, den Quellcode mit dem TypeScript-Compiler zu kompilieren und den JavaScript-Quellcode direkt auszuführen. Dies hat den Vorteil, dass sich die Ausführungsgeschwindigkeit für kurze Befehle drastisch erhöht. Allerdings entsteht dabei auch zusätzlicher Arbeitsablauf-Overhead, da entweder der Compiler manuell ausgeführt oder ein Watcher eingerichtet werden muss. Aus diesem Grund wird in allen Beispielen in dieser Dokumentation `ts-node` verwendet.",
        "Erste Applikation": "Erste Anwendung",
        "Since the Deepkit framework does not use configuration files or a special folder structure, you can structure your project however you want. The only two files you need to get started are the TypeScript app.ts file and the TypeScript configuration tsconfig.json.": "Da das Deepkit-Framework keine Konfigurationsdateien oder eine spezielle Ordnerstruktur verwendet, können Sie Ihr Projekt nach Belieben strukturieren. Die einzigen beiden Dateien, die Sie für den Einstieg benötigen, sind die TypeScript-Datei app.ts und die TypeScript-Konfiguration tsconfig.json.",
        "Our goal is to have the following files in our project folder:": "Unser Ziel ist es, die folgenden Dateien in unserem Projektordner zu haben:",
        "In this code, you can see that we have defined a test command using the `TestCommand` class and created a new app that we run directly using `run()`. By running this script, we start the app.": "In diesem Code sehen Sie, dass wir einen Testbefehl mit der Klasse `TestCommand` definiert und eine neue Anwendung erstellt haben, die wir direkt mit `run()` ausführen. Wenn wir dieses Skript ausführen, starten wir die Anwendung.",
        "With the shebang in the first line (`#!...`) we can make our script executable with the following command.": "Mit dem Shebang in der ersten Zeile (`#!...`) können wir unser Skript mit dem folgenden Befehl ausführbar machen.",
        "Und dann ausführen:": "Und dann ausführen:",
        "Now, to execute our test command, we run the following command.": "Um unseren Testbefehl auszuführen, führen wir den folgenden Befehl aus.",
        "In Deepkit Framework everything is now done via this `app.ts`. You can rename the file as you like or create more. Custom CLI commands, HTTP/RPC server, migration commands, and so on are all started from this entry point.": "Im Deepkit Framework wird nun alles über diese `app.ts` erledigt. Sie können die Datei nach Belieben umbenennen oder weitere Dateien erstellen. Benutzerdefinierte CLI-Befehle, HTTP/RPC-Server, Migrationsbefehle usw. werden alle von diesem Einstiegspunkt aus gestartet.",
        "To start the HTTP/RPC server, run the following:": "Um den HTTP/RPC-Server zu starten, führen Sie Folgendes aus:",
        "To serve requests please read chapter xref:http.adoc[HTTP] or xref:rpc.adoc[RPC]. In chapter xref:cli.adoc[CLI] you can learn more about CLI commands.": "Um Anfragen zu bedienen, lesen Sie bitte das Kapitel xref:http.adoc[HTTP] oder xref:rpc.adoc[RPC]. Im Kapitel xref:cli.adoc[CLI] können Sie mehr über CLI-Befehle erfahren.",
        "App": "App",
        "Via the `App` object starts like application.": "Über das `App`-Objekt wird eine Anwendung gestartet.",
        "The `run()` method lists the arguments and executes the corresponding CLI controller. Since `FrameworkModule` provides its own CLI controllers, which are responsible for starting the HTTP server, for example, these can be called via it.": "Die Methode `run()` listet die Argumente auf und führt den entsprechenden CLI-Controller aus. Da das `FrameworkModule` eigene CLI-Controller zur Verfügung stellt, die z.B. für den Start des HTTP-Servers zuständig sind, können diese über sie aufgerufen werden.",
        "The `App` object can also be used to access the Dependency Injection container without running a CLI controller.": "Das \"App\"-Objekt kann auch verwendet werden, um auf den Dependency Injection-Container zuzugreifen, ohne einen CLI-Controller auszuführen.",
        "Module": "Modul",
        "Deepkit framework is highly modular and allows you to split your application into several handy modules. Each module has its own dependency injection sub-container, configuration, commands and much more. In the chapter \"First application\" you have already created one module - the root module. `new App` takes almost the same arguments as a module, because it creates the root module for you automatically in the background.": "Das Deepkit-Framework ist hochgradig modular und ermöglicht es Ihnen, Ihre Anwendung in mehrere praktische Module zu unterteilen. Jedes Modul hat seinen eigenen Sub-Container für die Injektion von Abhängigkeiten, Konfiguration, Befehle und vieles mehr. Im Kapitel \"Erste Anwendung\" haben Sie bereits ein Modul erstellt - das Root-Modul. Die Funktion `neue App` benötigt fast die gleichen Argumente wie ein Modul, da sie das Root-Modul automatisch im Hintergrund erstellt.",
        "You can skip this chapter if you do not plan to split your application into submodules, or if you do not plan to make a module available as a package to others.": "Sie können dieses Kapitel überspringen, wenn Sie nicht vorhaben, Ihre Anwendung in Untermodule aufzuteilen, oder wenn Sie nicht vorhaben, ein Modul als Paket für andere zur Verfügung zu stellen.",
        "A module is a simple class:": "Ein Modul ist eine einfache Klasse:",
        "It basically has no functionality at this point because its module definition is an empty object and it has no methods, but this demonstrates the relationship between modules and your application (your root module). This MyModule module can then be imported into your application or other modules.": "Es hat zu diesem Zeitpunkt im Grunde keine Funktionalität, da seine Moduldefinition ein leeres Objekt ist und es keine Methoden hat, aber dies demonstriert die Beziehung zwischen Modulen und Ihrer Anwendung (Ihrem Stammmodul). Dieses MyModule-Modul kann dann in Ihre Anwendung oder andere Module importiert werden.",
        "You can now add features to this module as you would with `App`. The arguments are the same, except that imports are not available in a module definition. Add HTTPRPCCLI controllers, services, a configuration, event listeners, and various module hooks to make modules more dynamic.": "Sie können nun diesem Modul Funktionen hinzufügen, wie Sie es mit `App` tun würden. Die Argumente sind die gleichen, nur dass Importe in einer Moduldefinition nicht verfügbar sind. Fügen Sie HTTPRPCCLI-Controller, Dienste, eine Konfiguration, Ereignis-Listener und verschiedene Modul-Hooks hinzu, um die Module dynamischer zu machen.",
        "Controllers": "Steuerungen",
        "Modules can define controllers that are processed by other modules. For example, if you add a controller with decorators from the `@deepkit/http` package, its `HttpModule` module will pick this up and register the found routes in its router. A single controller may contain several such decorators. It is up to the module author who gives you these decorators how he processes the controllers.": "Module können Steuerungen definieren, die von anderen Modulen verarbeitet werden. Wenn Sie zum Beispiel einen Controller mit Dekoratoren aus dem `@deepkit/http`-Paket hinzufügen, wird sein `HttpModule`-Modul dies aufgreifen und die gefundenen Routen in seinem Router registrieren. Ein einzelner Controller kann mehrere solcher Dekoratoren enthalten. Es liegt an dem Modulautor, der Ihnen diese Dekoratoren gibt, wie er die Controller verarbeitet.",
        "In Deepkit there are three packages that handles such controllers: HTTP, RPC, and CLI. See their respective chapters to learn more. Below is an example of an HTTP controller:": "In Deepkit gibt es drei Pakete, die solche Steuerungen verwalten: HTTP, RPC und CLI. In den jeweiligen Kapiteln erfahren Sie mehr darüber. Nachfolgend finden Sie ein Beispiel für einen HTTP-Controller:",
        "Provider": "Anbieter",
        "When you define a provider in the `providers` section of your application, it is accessible throughout your application. For modules, however, these providers are automatically encapsulated in that module's dependency injection subcontainer. You must manually export each provider to make it available to another module or your application.": "Wenn Sie einen Anbieter im Abschnitt \"Anbieter\" Ihrer Anwendung definieren, ist er in Ihrer gesamten Anwendung zugänglich. Bei Modulen werden diese Anbieter jedoch automatisch in den Subcontainer für die Injektion von Abhängigkeiten des Moduls gekapselt. Sie müssen jeden Anbieter manuell exportieren, um ihn für ein anderes Modul oder Ihre Anwendung verfügbar zu machen.",
        "To learn more about how providers work, see the xref:dependency-injection.adoc[Dependency Injection] chapter.": "Weitere Informationen über die Funktionsweise von Anbietern finden Sie im Kapitel xref:dependency-injection.adoc[Dependency Injection].",
        "When a user imports this module, he has no access to `HelloWorldService` because it is encapsulated in the sub-dependency injection container of `MyModule`.": "Wenn ein Benutzer dieses Modul importiert, hat er keinen Zugriff auf `HelloWorldService`, weil es im Subdependency Injection Container von `MyModule` gekapselt ist.",
        "Exports": "Ausfuhren",
        "To make providers available in the importer's module, you can include the provider's token in `exports`. This essentially moves the provider up one level into the dependency injection container of the parent module - the importer.": "Um Anbieter im Modul des Importeurs verfügbar zu machen, können Sie das Token des Anbieters in `exports` aufnehmen. Dadurch wird der Anbieter im Wesentlichen eine Ebene höher in den Dependency Injection Container des übergeordneten Moduls - des Importeurs - verschoben.",
        "If you have other providers like `FactoryProvider`, `UseClassProvider` etc., you should still use only the class type in the exports.": "Wenn Sie andere Anbieter wie `FactoryProvider`, `UseClassProvider` usw. haben, sollten Sie trotzdem nur den Klassentyp in den Exporten verwenden.",
        "We can now import that module and use its exported service in our application code.": "Jetzt können wir dieses Modul importieren und seinen exportierten Dienst in unserem Anwendungscode verwenden.",
        "Read the xref:dependency-injection.adoc[Dependency Injection] chapter to learn more.": "Lesen Sie das Kapitel xref:dependency-injection.adoc[Dependency Injection], um mehr zu erfahren.",
        "Konfiguration": "Konfiguration",
        "In Deepkit framework, modules and your application can have configuration options. For example, a configuration can consist of database URLs, passwords, IPs, and so on. Services, HTTPRPCCLI controllers, and template functions can read these configuration options via dependency injection.": "Im Deepkit-Framework können die Module und Ihre Anwendung über Konfigurationsoptionen verfügen. Eine Konfiguration kann zum Beispiel aus Datenbank-URLs, Passwörtern, IPs usw. bestehen. Dienste, HTTPRPCCLI-Controller und Vorlagenfunktionen können diese Konfigurationsoptionen über Dependency Injection lesen.",
        "A configuration can be defined by defining a class with properties. This is a type-safe way to define a configuration for your entire application, and its values are automatically serialized and validated.": "Eine Konfiguration kann durch die Definition einer Klasse mit Eigenschaften definiert werden. Dies ist ein typsicherer Weg, um eine Konfiguration für Ihre gesamte Anwendung zu definieren, und ihre Werte werden automatisch serialisiert und validiert.",
        "Beispiel": "Beispiel",
        "Configuration class": "Konfiguration Klasse",
        "Die Werte für die Konfigurationsoptionen können entweder im Konstruktor des Moduls, mit der Methode `.configure()` oder über Konfigurationslader (z.B. Umgebungsvariablenlader) bereitgestellt werden.": "Die Werte für die Konfigurationsoptionen können entweder im Konstruktor des Moduls, mit der Methode `.configure()` oder über Konfigurationslader (z.B. Umgebungsvariablenlader) bereitgestellt werden.",
        "To dynamically change the configuration options of an imported module, you can use the `process` hook. This is a good place to either redirect configuration options or set up an imported module depending on the current module configuration or other module instance information.": "Um die Konfigurationsoptionen eines importierten Moduls dynamisch zu ändern, können Sie den `process`-Haken verwenden. Dies ist ein guter Ort, um entweder Konfigurationsoptionen umzuleiten oder ein importiertes Modul abhängig von der aktuellen Modulkonfiguration oder anderen Modulinstanzinformationen einzurichten.",
        "At the application level, it works a little differently:": "Auf der Anwendungsebene funktioniert es ein wenig anders:",
        "When the root application module is created from a regular module, it works similarly to regular modules.": "Wenn das Root-Anwendungsmodul aus einem regulären Modul erstellt wird, funktioniert es ähnlich wie reguläre Module.",
        "Read configuration values": "Konfigurationswerte lesen",
        "To use a configuration option in a service, you can use normal dependency injection. It is possible to inject either the entire configuration object, a single value, or a portion of the configuration.": "Um eine Konfigurationsoption in einem Dienst zu verwenden, können Sie die normale Dependency Injection verwenden. Es ist möglich, entweder das gesamte Konfigurationsobjekt, einen einzelnen Wert oder einen Teil der Konfiguration zu injizieren.",
        "Partial": "Teilweise",
        "To inject only a subset of the configuration values, use the `Pick` type.": "Um nur eine Teilmenge der Konfigurationswerte zu injizieren, verwenden Sie den Typ `Pick`.",
        "Single value": "Einzelner Wert",
        "To inject only a single value, use the index access operator.": "Um nur einen einzigen Wert zu injizieren, verwenden Sie den Indexzugriffsoperator.",
        "All": "Alle",
        "To inject all config values, use the class as dependency.": "Um alle Konfigurationswerte zu injizieren, verwenden Sie die Klasse als Abhängigkeit.",
        "Debugger": "Debugger",
        "The configuration values of your application and all modules can be displayed in the debugger. Enable the debug option in `FrameworkModule` and open `http://localhost:8080/_debug/configuration`.": "Die Konfigurationswerte Ihrer Anwendung und aller Module können im Debugger angezeigt werden. Aktivieren Sie die Debug-Option in `FrameworkModule` und öffnen Sie `http://localhost:8080/_debug/configuration`.",
        "You can also use `ts-node app.ts app:config` to display all available configuration options, the active value, their default value, description and data type.": "Sie können auch `ts-node app.ts app:config` verwenden, um alle verfügbaren Konfigurationsoptionen, den aktiven Wert, ihren Standardwert, die Beschreibung und den Datentyp anzuzeigen.",
        "Set configuration values": "Konfigurationswerte einstellen",
        "By default, no values are overwritten, so default values are used. There are several ways to set configuration values.": "Standardmäßig werden keine Werte überschrieben, es werden also Standardwerte verwendet. Es gibt mehrere Möglichkeiten, Konfigurationswerte festzulegen.",
        "Environment variables for each option": "Umgebungsvariablen für jede Option",
        "Environment variable via JSON": "Umgebungsvariable über JSON",
        "dotenv-Files": "dotenv-Dateien",
        "You can use several methods to load the configuration at the same time. The order in which they are called is important.": "Sie können mehrere Methoden zum gleichzeitigen Laden der Konfiguration verwenden. Die Reihenfolge, in der sie aufgerufen werden, ist wichtig.",
        "Environment variables": "Umgebungsvariablen",
        "To allow setting each configuration option via its own environment variable, use `loadConfigFromEnv`. The default prefix is `APP_`, but you can change it. It also automatically loads `.env` files. By default, it uses an uppercase naming strategy, but you can change that too.": "Um die Einstellung jeder Konfigurationsoption über eine eigene Umgebungsvariable zu ermöglichen, verwenden Sie `loadConfigFromEnv`. Der Standardpräfix ist `APP_`, aber Sie können ihn ändern. Es lädt auch automatisch `.env`-Dateien. Standardmäßig werden die Dateien in Großbuchstaben benannt, aber auch das können Sie ändern.",
        "For configuration options like `pageTitle` above, you can use `APP_PAGE_TITLE=\"Other Title\"` to change the value.": "Für Konfigurationsoptionen wie `pageTitle` oben, können Sie `APP_PAGE_TITLE=\"Other Title\"` verwenden, um den Wert zu ändern.",
        "JSON environment variable": "JSON-Umgebungsvariable",
        "To change multiple configuration options via a single environment variable, use `loadConfigFromEnvVariable`. The first argument is the name of the environment variable.": "Um mehrere Konfigurationsoptionen über eine einzige Umgebungsvariable zu ändern, verwenden Sie `loadConfigFromEnvVariable`. Das erste Argument ist der Name der Umgebungsvariablen.",
        "DotEnv Files": "DotEnv-Dateien",
        "To change multiple configuration options via a dotenv file, use `loadConfigFromEnv`. The first argument is either a path to a dotenv (relative to `cwd`) or multiple paths. If it is an array, each path is tried until an existing file is found.": "Um mehrere Konfigurationsoptionen über eine Dotenv-Datei zu ändern, verwenden Sie `loadConfigFromEnv`. Das erste Argument ist entweder ein Pfad zu einer dotenv (relativ zu `cwd`) oder mehrere Pfade. Wenn es ein Array ist, wird jeder Pfad versucht, bis eine existierende Datei gefunden wird.",
        "Module Configuration": "Modul-Konfiguration",
        "Each imported module can have a module name. This name is used for the configuration paths used above.": "Jedes importierte Modul kann einen Modulnamen haben. Dieser Name wird für die oben verwendeten Konfigurationspfade verwendet.",
        "For example, for configuring environment variables, the path for the `FrameworkModule` option port is `FRAMEWORK_PORT`. All names are written in uppercase by default. If a prefix of `APP_` is used, the port can be changed via the following:": "Für die Konfiguration von Umgebungsvariablen lautet der Pfad für die Option `FrameworkModule` zum Beispiel `FRAMEWORK_PORT`. Alle Namen werden standardmäßig in Großbuchstaben geschrieben. Wenn ein Präfix von `APP_` verwendet wird, kann der Port wie folgt geändert werden:",
        "In dotenv files it would also be `APP_FRAMEWORK_PORT=9999`.": "In dotenv-Dateien würde es auch `APP_FRAMEWORK_PORT=9999` heißen.",
        "In JSON environment variables via `loadConfigFromEnvVariable('APP_CONFIG')` on the other hand, it is the structure of the actual configuration class. `framework` becomes an object.": "Bei JSON-Umgebungsvariablen über `loadConfigFromEnvVariable('APP_CONFIG')` hingegen ist es die Struktur der eigentlichen Konfigurationsklasse. Das `Framework` wird zu einem Objekt.",
        "This works the same for all modules. No module prefix is required for your application configuration option (`new App`).": "Dies funktioniert für alle Module gleich. Für Ihre Anwendungskonfigurationsoption (`neue App`) ist kein Modulpräfix erforderlich.",
        "Application Server": "Anwendungsserver",
        "Public Directory": "Öffentliches Verzeichnis",
        "The FrameworkModule provides a way to serve static files such as images, PDFs, binaries, etc. over HTTP. The `publicDir` configuration option lets you specify which folder to use as the default entry point for requests that do not lead to an HTTP controller route. By default, this behavior is disabled (empty value).": "Das FrameworkModule bietet eine Möglichkeit, statische Dateien wie Bilder, PDFs, Binärdateien usw. über HTTP bereitzustellen. Mit der Konfigurationsoption `publicDir` können Sie angeben, welcher Ordner als Standard-Einstiegspunkt für Anfragen verwendet werden soll, die nicht zu einer HTTP-Controller-Route führen. Standardmäßig ist dieses Verhalten deaktiviert (leerer Wert).",
        "To enable the provision of public files, set `publicDir` to a folder of your choice. Normally you would choose a name like `publicDir` to make things obvious.": "Um die Bereitstellung von öffentlichen Dateien zu ermöglichen, setzen Sie `publicDir` auf einen Ordner Ihrer Wahl. Normalerweise würden Sie einen Namen wie `publicDir` wählen, um die Dinge offensichtlich zu machen.",
        "To change the `publicDir` option, you can change the first argument of `FrameworkModule`.": "Um die Option `publicDir` zu ändern, können Sie das erste Argument von `FrameworkModule` ändern.",
        "All files within this configured folder are now accessible via HTTP. For example, if you open `http:localhost:8080logo.jpg`, you will see the image `logo.jpg` in the `publicDir` directory.": "Alle Dateien innerhalb dieses konfigurierten Ordners sind nun über HTTP zugänglich. Wenn Sie zum Beispiel `http:localhost:8080logo.jpg` öffnen, sehen Sie das Bild `logo.jpg` im Verzeichnis `publicDir`.",
        "File Structure": "Dateistruktur",
        "Deepkit has its own powerful database abstraction library called Deepkit ORM. It is an Object-Relational Mapping (ORM) library that facilitates work with SQL databases and MongoDB.": "Deepkit hat eine eigene leistungsstarke Datenbankabstraktionsbibliothek namens Deepkit ORM. Es handelt sich um eine ORM-Bibliothek (Object-Relational Mapping), die die Arbeit mit SQL-Datenbanken und MongoDB erleichtert.",
        "Although you can use any database library, we recommend Deepkit ORM as it is the fastest TypeScript database abstraction library that is perfectly integrated with the Deepkit framework and has many features that will improve your workflow and efficiency.": "Obwohl Sie jede beliebige Datenbankbibliothek verwenden können, empfehlen wir Deepkit ORM, da es die schnellste TypeScript-Datenbankabstraktionsbibliothek ist, die perfekt in das Deepkit-Framework integriert ist und über viele Funktionen verfügt, die Ihren Arbeitsablauf und Ihre Effizienz verbessern werden.",
        "To get all the information about Deepkit ORM, see the xref:database.adoc[Database] chapter.": "Alle Informationen über Deepkit ORM finden Sie im Kapitel xref:database.adoc[Database].",
        "Database Classes": "Datenbank-Klassen",
        "The simplest way to use the `Database` object of Deepkit ORM within the application is to register a class that derives from it.": "Der einfachste Weg, das Objekt \"Database\" des Deepkit ORM in der Anwendung zu verwenden, besteht darin, eine Klasse zu registrieren, die von ihm abgeleitet ist.",
        "Create a new class and in its constructor specify the adapter with its parameters and add to the second parameter all entity models that should be connected to this database.": "Erstellen Sie eine neue Klasse und geben Sie in ihrem Konstruktor den Adapter mit seinen Parametern an und fügen Sie dem zweiten Parameter alle Entitätsmodelle hinzu, die mit dieser Datenbank verbunden werden sollen.",
        "You can now register this database class as a provider. We also enable `migrateOnStartup` which will automatically create all tables in your database at bootstrap. This is ideal for rapid prototyping, but is not recommended for a serious project or production setup. Normal database migrations should then be used here.": "Sie können nun diese Datenbankklasse als Anbieter registrieren. Wir aktivieren auch `migrateOnStartup`, was automatisch alle Tabellen in Ihrer Datenbank bei Bootstrap erstellen wird. Dies ist ideal für Rapid Prototyping, wird aber nicht für ein ernsthaftes Projekt oder eine Produktionseinrichtung empfohlen. Hier sollten dann normale Datenbankmigrationen verwendet werden.",
        "We also enable `debug`, which allows us to open the debugger when the application's server is started and manage your database models directly in its built-in ORM browser.": "Wir aktivieren auch `debug`, was uns erlaubt, den Debugger zu öffnen, wenn der Server der Anwendung gestartet wird, und Ihre Datenbankmodelle direkt in seinem integrierten ORM-Browser zu verwalten.",
        "You can now access `SQLiteDatabase` anywhere using Dependency Injection:": "Sie können jetzt überall mit Dependency Injection auf `SQLiteDatabase` zugreifen:",
        "Multiple Databases": "Mehrere Datenbanken",
        "You can add as many database classes as you like and name them as you like. Be sure to change the name of each database so that it doesn't conflict with others when you use the ORM browser.": "Sie können so viele Datenbankklassen hinzufügen, wie Sie möchten, und sie nach Belieben benennen. Achten Sie darauf, den Namen jeder Datenbank zu ändern, damit er nicht mit anderen in Konflikt gerät, wenn Sie den ORM-Browser verwenden.",
        "Manage Data": "Daten verwalten",
        "You now have everything set up to manage your database data with the Deepkit ORM Browser. To open the ORM Browser and manage the content, write all the steps from above in the `app.ts` file and start the server.": "Sie haben nun alles für die Verwaltung Ihrer Datenbankdaten mit dem Deepkit ORM Browser eingerichtet. Um den ORM-Browser zu öffnen und den Inhalt zu verwalten, schreiben Sie alle Schritte von oben in die Datei \"app.ts\" und starten Sie den Server.",
        "You can now open http://localhost:8080/_debug/database/default.": "Sie können jetzt http://localhost:8080/_debug/database/default öffnen.",
        "You can see the ER (entity relationship) diagram. At the moment only one entity is available. If you add more with relationships, you will see all the information at a glance.": "Sie können das ER-Diagramm (Entity Relationship) sehen. Im Moment ist nur eine Entität verfügbar. Wenn Sie weitere Entitäten mit Beziehungen hinzufügen, werden Sie alle Informationen auf einen Blick sehen.",
        "If you click on `User` in the left sidebar, you can manage its content. Click the `+` icon and change the title of the new record. After you have changed the required values (such as the user name), click `Confirm`. This will commit all changes to the database and make them permanent. The auto increment ID will be assigned automatically.": "Wenn Sie in der linken Seitenleiste auf `Benutzer` klicken, können Sie den Inhalt verwalten. Klicken Sie auf das Symbol \"+\" und ändern Sie den Titel des neuen Datensatzes. Nachdem Sie die erforderlichen Werte (z. B. den Benutzernamen) geändert haben, klicken Sie auf \"Bestätigen\". Damit werden alle Änderungen in die Datenbank übernommen und sind dauerhaft. Die Autoinkrement-ID wird automatisch zugewiesen.",
        "Learn More": "Mehr erfahren",
        "To learn more about how `SQLiteDatabase` works, please read the chapter xref:database.adoc[Database] and its subchapters, such as querying data, manipulating data via sessions, defining relations and much more.": "Um mehr über die Funktionsweise von `SQLiteDatabase` zu erfahren, lesen Sie bitte das Kapitel xref:database.adoc[Database] und seine Unterkapitel, wie z.B. die Abfrage von Daten, die Manipulation von Daten über Sitzungen, die Definition von Beziehungen und vieles mehr.",
        "Please note that the chapters there refer to the standalone library `@deepkit/orm` and do not include documentation about the part of the deepkit framework you read above in this chapter. In the standalone library, you instantiate your database class manually, for example via `new SQLiteDatabase()`. However, in your Deepkit framework application, this is done automatically using the Dependency Injection container.": "Bitte beachten Sie, dass sich die Kapitel dort auf die eigenständige Bibliothek `@deepkit/orm` beziehen und keine Dokumentation über den Teil des Deepkit-Frameworks enthalten, den Sie oben in diesem Kapitel gelesen haben. In der eigenständigen Bibliothek instanziieren Sie Ihre Datenbankklasse manuell, zum Beispiel über `new SQLiteDatabase()`. In Ihrer Deepkit-Framework-Anwendung wird dies jedoch automatisch mithilfe des Dependency Injection-Containers durchgeführt.",
        "Logger": "Logger",
        "Deepkit Logger is a standalone library with a primary Logger class that you can use to log information. This class is automatically deployed in the Dependency Injection container of your Deepkit Framework application.": "Deepkit Logger ist eine eigenständige Bibliothek mit einer primären Logger-Klasse, die Sie zur Protokollierung von Informationen verwenden können. Diese Klasse wird automatisch im Dependency Injection-Container Ihrer Deepkit Framework-Anwendung bereitgestellt.",
        "The `Logger` class has several methods, each of which behaves like `console.log`.": "Die Klasse \"Logger\" hat mehrere Methoden, von denen sich jede wie \"console.log\" verhält.",
        "By default, a logger has `info` level, i.e. it processes only info messages and more (i.e. log, warning, error, but not debug). To change the log level call for example `logger.level = 5`.": "Standardmäßig hat ein Logger die Stufe `info`, d.h. er verarbeitet nur Info-Meldungen und mehr (d.h. log, warning, error, aber nicht debug). Um den Log-Level zu ändern, rufen Sie zum Beispiel `logger.level = 5` auf.",
        "Use in the application": "Verwendung in der Anwendung",
        "To use the logger in your Deepkit framework application, you can simply inject `Logger` into your services or controllers.": "Um den Logger in Ihrer Deepkit-Framework-Anwendung zu verwenden, können Sie einfach \"Logger\" in Ihre Dienste oder Controller einfügen.",
        "Colors": "Farben",
        "The logger supports colored log messages. You can provide colors by using XML tags that surround the text you want to appear in color.": "Der Logger unterstützt farbige Protokollmeldungen. Sie können Farben bereitstellen, indem Sie XML-Tags verwenden, die den Text umgeben, der in Farbe erscheinen soll.",
        "For transporters that do not support colors, the color information is automatically removed. In the default transporter (`ConsoleTransport`) the color is displayed. The following colors are available: `black`, `red`, `green`, `blue`, `cyan`, `magenta`, `white` and `grey`/`gray`.": "Bei Transportern, die keine Farben unterstützen, werden die Farbinformationen automatisch entfernt. Im Standardtransporter (`ConsoleTransport`) wird die Farbe angezeigt. Die folgenden Farben sind verfügbar: `Schwarz`, `Rot`, `Grün`, `Blau`, `Cyan`, `Magenta`, `Weiß` und `Grau`/`Grau`.",
        "Transporter": "Transporter",
        "You can configure a single transporter or multiple transporters. In a Deepkit Framework application, the `ConsoleTransport` transporter is configured automatically. To configure additional transporters, you can use xref:dependency-injection.adoc#di-setup-calls[Setup Calls]:": "Sie können einen einzelnen Transporter oder mehrere Transporter konfigurieren. In einer Deepkit-Framework-Anwendung wird der Transporter `ConsoleTransport` automatisch konfiguriert. Um zusätzliche Transporter zu konfigurieren, können Sie xref:dependency-injection.adoc#di-setup-calls[Setup Calls] verwenden:",
        "To replace all transporters with a new set of transporters, use `setTransport`:": "Um alle Transporter durch einen neuen Satz von Transportern zu ersetzen, verwenden Sie `setTransport`:",
        "Formatter": "Formatierer",
        "With formatters you can change the message format, e.g. add the timestamp. When an application is started via `server:start`, a `DefaultFormatter` is automatically added (which adds timestamp, range and log level) if no other formatter is available.": "Mit Formatierern kann man das Nachrichtenformat ändern, z.B. den Zeitstempel hinzufügen. Wenn eine Anwendung über `server:start` gestartet wird, wird automatisch ein `DefaultFormatter` hinzugefügt (der Zeitstempel, Bereich und Loglevel hinzufügt), wenn kein anderer Formatter verfügbar ist.",
        "Scoped Logger": "Abgestimmter Logger",
        "Scoped loggers add an arbitrary area name to each log entry, which can be helpful in determining which subarea of your application the log entry originated from.": "Scoped Logger fügen jedem Protokolleintrag einen beliebigen Bereichsnamen hinzu, der hilfreich sein kann, um festzustellen, aus welchem Teilbereich Ihrer Anwendung der Protokolleintrag stammt.",
        "JSON Transporter": "JSON-Transporter",
        "To change the output to JSON protocols, you can use the supplied `JSONTransport`.": "Um die Ausgabe in JSON-Protokolle zu ändern, können Sie den mitgelieferten `JSONTransport` verwenden.",
        "Context Data": "Kontext Daten",
        "To add contextual data to a log entry, add a simple object literal as the last argument. Only log calls with at least two arguments can contain contextual data.": "Um einem Protokolleintrag kontextbezogene Daten hinzuzufügen, fügen Sie ein einfaches Objektliteral als letztes Argument hinzu. Nur Protokollaufrufe mit mindestens zwei Argumenten können kontextbezogene Daten enthalten.",
        "Auto-CRUD": "Auto-CRUD",
        "Deepkit framework comes with various event tokens on which event listeners can be registered.": "Das Deepkit-Framework verfügt über verschiedene Ereignis-Token, für die Ereignis-Listener registriert werden können.",
        "See the xref:events.adoc[Events] chapter to learn more about how events work.": "Im Kapitel xref:events.adoc[Events] erfahren Sie mehr über die Funktionsweise von Ereignissen.",
        "Dispatch Events": "Versenden von Ereignissen",
        "Events are sent via the `EventDispatcher` class. In a Deepkit Framework application, this can be provided via dependency injection.": "Ereignisse werden über die Klasse `EventDispatcher` gesendet. In einer Deepkit-Framework-Anwendung kann dies über Dependency Injection bereitgestellt werden.",
        "Event Listener": "Ereignis-Listener",
        "There are two ways to react to events. Either via controller classes or regular functions.": "Es gibt zwei Möglichkeiten, auf Ereignisse zu reagieren. Entweder über Controller-Klassen oder reguläre Funktionen.",
        "Both are registered in the app or in modules under `listeners`.": "Beide werden in der App oder in Modulen unter \"Listeners\" registriert.",
        "_Controller Listener_": "_Controller Listener_",
        "_Functional Listener_": "_Funktionaler Zuhörer_",
        "Framework Events": "Rahmenveranstaltungen",
        "Deepkit Framework itself has several events from the application server that you can listen for.": "Deepkit Framework selbst verfügt über mehrere Ereignisse vom Anwendungsserver, auf die Sie hören können.",
        "Deployment": "Einsatz",
        "In this chapter, you will learn how to compile your application in JavaScript, configure it for your production environment, and deploy it using Docker.": "In diesem Kapitel lernen Sie, wie Sie Ihre Anwendung in JavaScript kompilieren, sie für Ihre Produktionsumgebung konfigurieren und mit Docker bereitstellen.",
        "Compile TypeScript": "TypeScript kompilieren",
        "Suppose you have an application like this in an `app.ts` file:": "Angenommen, Sie haben eine Anwendung wie diese in einer `app.ts`-Datei:",
        "If you use `ts-node app.ts server:start`, you will see that everything works correctly. In a production environment, you would not typically start the server with `ts-node`. You would compile it into JavaScript and then use the node. To do this, you must have a correct `tsconfig.json` with the correct configuration options. In the \"First Application\" section, your `tsconfig.json` is configured to output JavaScript to the `.dist` folder. We assume that you have configured it that way as well.": "Wenn Sie `ts-node app.ts server:start` verwenden, werden Sie sehen, dass alles korrekt funktioniert. In einer Produktionsumgebung würden Sie den Server normalerweise nicht mit `ts-node` starten. Sie würden ihn in JavaScript kompilieren und dann den Knoten verwenden. Um dies zu tun, müssen Sie eine korrekte `tsconfig.json` mit den korrekten Konfigurationsoptionen haben. Im Abschnitt \"Erste Anwendung\" ist Ihre `tsconfig.json` so konfiguriert, dass JavaScript in den Ordner `.dist` ausgegeben wird. Wir gehen davon aus, dass Sie dies auch so konfiguriert haben.",
        "If all compiler settings are correct and your `outDir` points to a folder like `dist`, then as soon as you run the `tsc` command in your project, all your linked files in the files in the `tsconfig.json` will be compiled to JavaScript. It is enough to specify your entry files in this list. All imported files are also compiled automatically and do not need to be explicitly added to `tsconfig.json`. `tsc` is part of Typescript when you install `npm install typescript`.": "Wenn alle Compiler-Einstellungen korrekt sind und Ihr `outDir` auf einen Ordner wie `dist` zeigt, dann werden, sobald Sie den `tsc`-Befehl in Ihrem Projekt ausführen, alle Ihre gelinkten Dateien in den Dateien in der `tsconfig.json` zu JavaScript kompiliert. Es genügt, wenn Sie Ihre Eingabedateien in dieser Liste angeben. Alle importierten Dateien werden ebenfalls automatisch kompiliert und müssen nicht explizit zu `tsconfig.json` hinzugefügt werden. `tsc` ist Teil von Typescript, wenn Sie `npm install typescript` installieren.",
        "The TypeScript compiler does not output anything if it was successful. You can now check the output of `dist`.": "Der TypeScript-Compiler gibt nichts aus, wenn er erfolgreich war. Sie können nun die Ausgabe von `dist` überprüfen.",
        "You can see that there is only one file. You can run it via `node distapp.js` and get the same functionality as with `ts-node app.ts`.": "Sie können sehen, dass es nur eine Datei gibt. Sie können es über `node distapp.js` ausführen und erhalten die gleiche Funktionalität wie mit `ts-node app.ts`.",
        "For a deployment, it is important that the TypeScript files are compiled correctly and everything works directly through Node. You could now simply move your `dist` folder including your `node_modules` and run `node distapp.js server:start` and your app is successfully deployed. However, you would use other solutions like Docker to package your app correctly.": "Für ein Deployment ist es wichtig, dass die TypeScript-Dateien korrekt kompiliert sind und alles direkt über Node funktioniert. Sie könnten nun einfach Ihren `dist`-Ordner einschließlich Ihrer `node_modules` verschieben und `node distapp.js server:start` ausführen und Ihre App ist erfolgreich deployed. Sie würden jedoch andere Lösungen wie Docker verwenden, um Ihre App korrekt zu verpacken.",
        "In a production environment, you would not bind the server to `localhost`, but most likely to all devices via `0.0.0.0`. If you are not behind a reverse proxy, you would also set the port to 80. To configure these two settings, you need to customize the `FrameworkModule`. The two options we are interested in are `host` and `port`. In order for them to be configured externally via environment variables or via .dotenv files, we must first allow this. Fortunately, our code above has already done this with the `loadConfigFromEnv()` method.": "In einer Produktionsumgebung würden Sie den Server nicht an \"localhost\" binden, sondern höchstwahrscheinlich an alle Geräte über \"0.0.0.0\". Wenn Sie sich nicht hinter einem Reverse-Proxy befinden, würden Sie auch den Port auf 80 setzen. Um diese beiden Einstellungen zu konfigurieren, müssen Sie das `FrameworkModule` anpassen. Die beiden Optionen, an denen wir interessiert sind, sind \"host\" und \"port\". Damit sie von außen über Umgebungsvariablen oder über .dotenv-Dateien konfiguriert werden können, müssen wir dies zunächst zulassen. Glücklicherweise hat unser obiger Code dies bereits mit der Methode `loadConfigFromEnv()` getan.",
        "Please refer to the xref:framework.adoc#confiruration[Konfiguration] chapter to learn more about how to set the application configuration options.": "Bitte lesen Sie das Kapitel xref:framework.adoc#confiruration[Konfiguration], um mehr darüber zu erfahren, wie Sie die Konfigurationsoptionen der Anwendung einstellen.",
        "To see what configuration options are available and what value they have, you can use the `ts-node app.ts app:config` command. You can also see them in the Framework Debugger.": "Um zu sehen, welche Konfigurationsoptionen verfügbar sind und welchen Wert sie haben, können Sie den Befehl `ts-node app.ts app:config` verwenden. Sie können sie auch im Framework-Debugger sehen.",
        "SSL": "SSL",
        "It is recommended (and sometimes required) to run your application over HTTPS with SSL. There are several options for configuring SSL. To enable SSL, use": "Es wird empfohlen (und manchmal auch vorgeschrieben), Ihre Anwendung über HTTPS mit SSL auszuführen. Es gibt mehrere Möglichkeiten, SSL zu konfigurieren. Um SSL zu aktivieren, verwenden Sie",
        "`framework.ssl` and configure its parameters with the following options.": "framework.ssl\" und konfigurieren Sie dessen Parameter mit den folgenden Optionen.",
        "Local SSL": "Lokales SSL",
        "In the local development environment, you can enable self-signed HTTPs with the `framework.selfSigned` option.": "In der lokalen Entwicklungsumgebung können Sie selbstsignierte HTTPs mit der Option `framework.selfSigned` aktivieren.",
        "If you start this server now, your HTTP server is available as HTTPS at `https:localhost:8080`. In Chrome, you now get the error message \"NET::ERR_CERT_INVALID\" when you open this URL because self-signed certificates are considered a security risk: `chrome:flagsallow-insecure-localhost`.": "Wenn Sie diesen Server jetzt starten, ist Ihr HTTP-Server als HTTPS unter `https:localhost:8080` verfügbar. In Chrome erhalten Sie nun die Fehlermeldung \"NET::ERR_CERT_INVALID\", wenn Sie diese URL öffnen, da selbstsignierte Zertifikate als Sicherheitsrisiko angesehen werden: \"chrome:flagsallow-insecure-localhost\".",
        "Testing": "Prüfung",
        "The services and controllers in the Deepkit framework are designed to support SOLID and clean code that is well-designed, encapsulated, and separated. These features make the code easy to test.": "Die Dienste und Steuerungen des Deepkit-Frameworks sind so konzipiert, dass sie SOLID und sauberen Code unterstützen, der gut konzipiert, gekapselt und getrennt ist. Diese Eigenschaften machen den Code einfach zu testen.",
        "This documentation shows you how to set up a testing framework named link:https://jestjs.io[Jest] with `ts-jest`. To do this, run the following command to install `jest` and `ts-jest`.": "Diese Dokumentation zeigt Ihnen, wie Sie ein Test-Framework namens link:https://jestjs.io[Jest] mit `ts-jest` einrichten können. Führen Sie dazu den folgenden Befehl aus, um `jest` und `ts-jest` zu installieren.",
        "Jest needs a few configuration options to know where to find the test suits and how to compile the TS code. Add the following configuration to your `package.json`:": "Jest benötigt ein paar Konfigurationsoptionen, um zu wissen, wo die Testanzüge zu finden sind und wie der TS-Code zu kompilieren ist. Fügen Sie die folgende Konfiguration zu Ihrer `package.json` hinzu:",
        "Your test files should be named `.spec.ts`. Create a `test.spec.ts` file with the following content.": "Ihre Testdateien sollten den Namen `.spec.ts` tragen. Erstellen Sie eine Datei \"test.spec.ts\" mit dem folgenden Inhalt.",
        "You can now use the jest command to run all your test suits at once.": "Sie können nun den Befehl jest verwenden, um alle Ihre Testanzüge auf einmal auszuführen.",
        "Please read the link:https://jestjs.io[Jest-Dokumentation] to learn more about how the Jest CLI tool works and how you can write more sophisticated tests and entire test suites.": "Bitte lesen Sie den Link:https://jestjs.io[Jest-Dokumentation], um mehr darüber zu erfahren, wie das Jest CLI-Tool funktioniert und wie Sie anspruchsvollere Tests und ganze Testsuiten schreiben können.",
        "Unit Test": "Einheitstest",
        "Whenever possible, you should unit test your services. The simpler, better separated, and better defined your service dependencies are, the easier it is to test them. In this case, you can write simple tests like the following:": "Wann immer möglich, sollten Sie Ihre Dienste einem Unit-Test unterziehen. Je einfacher, besser getrennt und besser definiert Ihre Dienstabhängigkeiten sind, desto einfacher ist es, sie zu testen. In diesem Fall können Sie einfache Tests wie den folgenden schreiben:",
        "Integration tests": "Integrationstests",
        "It's not always possible to write unit tests, nor is it always the most efficient way to cover business-critical code and behavior. Especially if your architecture is very complex, it is beneficial to be able to easily perform end-to-end integration tests.": "Es ist nicht immer möglich, Unit-Tests zu schreiben, und es ist auch nicht immer der effizienteste Weg, um geschäftskritischen Code und Verhalten abzudecken. Vor allem wenn Ihre Architektur sehr komplex ist, ist es von Vorteil, End-to-End-Integrationstests einfach durchführen zu können.",
        "As you have already learned in the Dependency Injection chapter, the Dependency Injection Container is the heart of Deepkit. This is where all services are built and run. Your application defines services (providers), controllers, listeners, and imports. For integration testing, you don't necessarily want to have all services available in a test case, but you usually want to have a stripped down version of the application available to test the critical areas.": "Wie Sie bereits im Kapitel Dependency Injection gelernt haben, ist der Dependency Injection Container das Herzstück von Deepkit. Hier werden alle Dienste aufgebaut und ausgeführt. Ihre Anwendung definiert Dienste (Provider), Controller, Listener und Importe. Für Integrationstests müssen nicht unbedingt alle Dienste in einem Testfall zur Verfügung stehen, aber in der Regel wollen Sie eine abgespeckte Version der Anwendung zur Verfügung haben, um die kritischen Bereiche zu testen.",
        "If you have divided your application into several modules, you can test them more easily. For example, suppose you have created an `AppCoreModule` and want to test some services.": "Wenn Sie Ihre Anwendung in mehrere Module unterteilt haben, können Sie diese leichter testen. Nehmen wir zum Beispiel an, Sie haben ein `AppCoreModule` erstellt und wollen einige Dienste testen.",
        "You use your module as follows:": "Sie verwenden Ihr Modul wie folgt:",
        "And test it without booting the entire application server.": "Und testen Sie es, ohne den gesamten Anwendungsserver zu booten.",
        "Command-line Interface (CLI) programs are programs that interact via the terminal in the form of text input and text output. The advantage of interacting with the application in this variant is that only a terminal must exist either locally or via an SSH connection.": "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Texteingabe und Textausgabe interagieren. Der Vorteil dieser Variante der Interaktion mit der Anwendung ist, dass nur ein Terminal entweder lokal oder über eine SSH-Verbindung vorhanden sein muss.",
        "A CLI application in Deepkit has full access to the DI container and can thus access all providers and configuration options.": "Eine CLI-Anwendung in Deepkit hat vollen Zugriff auf den DI-Container und kann somit auf alle Anbieter und Konfigurationsmöglichkeiten zugreifen.",
        "The arguments and options of the CLI application are controlled by method parameters via TypeScript types and are automatically serialized and validated.": "Die Argumente und Optionen der CLI-Anwendung werden durch Methodenparameter über TypeScript-Typen gesteuert und automatisch serialisiert und validiert.",
        "CLI is one of three entry points to a Deepkit Framework application. In the Deepkit framework, the application is always launched via a CLI program, which is itself written in TypeScript by the user. Therefore, there is no Deepkit specific global CLI tool to launch a Deepkit application. This is how you launch the HTTP/RPC server, perform migrations, or run your own commands. This is all done through the same entry point, the same file. Once the Deepkit framework is used by importing `FrameworkModule` from `@deepkit/framework`, the application gets additional commands for the application server, migrations, and more.": "CLI ist einer von drei Einstiegspunkten in eine Deepkit-Framework-Anwendung. Im Deepkit-Framework wird die Anwendung immer über ein CLI-Programm gestartet, das vom Benutzer selbst in TypeScript geschrieben wird. Daher gibt es kein Deepkit-spezifisches globales CLI-Tool zum Starten einer Deepkit-Anwendung. Auf diese Weise können Sie den HTTP/RPC-Server starten, Migrationen durchführen oder Ihre eigenen Befehle ausführen. Dies alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit-Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` verwendet wird, erhält die Anwendung zusätzliche Befehle für den Anwendungsserver, Migrationen und mehr.",
        "The CLI framework allows you to easily register your own commands and is based on simple classes. In fact, it is based on `@deepkit/app`, a small package intended only for this purpose, which can also be used standalone without the deepkit framework. In this package you can find decorators that are needed to decorate the CLI controller class.": "Das CLI-Framework ermöglicht Ihnen die einfache Registrierung Ihrer eigenen Befehle und basiert auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch ohne das Deepkit-Framework verwendet werden kann. In diesem Paket finden Sie Dekoratoren, die für die Dekoration der CLI-Controller-Klasse benötigt werden.",
        "Controllers are managed or instantiated by the Dependency Injection container and can therefore use other providers. See the xref:dependency-injection.adoc[Dependency Injection] chapter for more details.": "Controller werden vom Dependency-Injection-Container verwaltet oder instanziiert und können daher andere Anbieter verwenden. Siehe das Kapitel xref:dependency-injection.adoc[Dependency Injection] für weitere Details.",
        "Since CLI programs in Deepkit are based on Runtime Types, it is necessary to have @deepkit/type already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Da CLI-Programme in Deepkit auf Runtime-Typen basieren, ist es notwendig, @deepkit/type bereits korrekt installiert zu haben. Siehe xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Note that @deepkit/app is partially based on TypeScript decorators and this feature should be enabled accordingly with `experimentalDecorators`.": "Beachten Sie, dass @deepkit/app teilweise auf TypeScript-Dekoratoren basiert und diese Funktion entsprechend mit `experimentalDecorators` aktiviert werden sollte.",
        "If you use functions as controllers only, you do not need TypeScript decorators.": "Wenn Sie nur Funktionen als Controller verwenden, brauchen Sie keine TypeScript-Dekoratoren.",
        "To create a command for your application, you need to create a CLI controller.": "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen.",
        "This is a simple class that has an `execute` method and or a simple function.": "Dies ist eine einfache Klasse, die eine \"Ausführen\"-Methode oder eine einfache Funktion hat.",
        "Functional controller:": "Funktionskontrolle:",
        "Class controllers:": "Klassenlotsen:",
        "This code is already a complete CLI application and can be started this way:": "Dieser Code ist bereits eine vollständige CLI-Anwendung und kann auf diese Weise gestartet werden:",
        "You can see that a \"test\" command is available. To execute this, the name must be passed as an argument:": "Sie sehen, dass ein \"test\"-Befehl verfügbar ist. Um diesen auszuführen, muss der Name als Argument übergeben werden:",
        "It is also possible to make the file executable using `chmod +x app.ts`, so that the command `./app.ts` is already sufficient to start it. Note that then a so-called Shebang is necessary. Shebang denotes the character combination `#!` at the beginning of a script program. In the example above this is already present: `#!/usr/bin/env ts-node-script` and uses the script mode of `ts-node`.": "Es ist auch möglich, die Datei mit `chmod +x app.ts` ausführbar zu machen, so dass der Befehl `./app.ts` bereits ausreicht, um sie zu starten. Beachten Sie, dass dann ein sogenannter Shebang notwendig ist. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. Im obigen Beispiel ist diese bereits vorhanden: `#!/usr/bin/env ts-node-script` und verwendet den Skriptmodus von `ts-node`.",
        "In this way, any number of commands can be created and registered. The unique name should be well-chosen and allows grouping of commands with the `:` character (e.g. `user:create`, `user:remove`, etc).": "Auf diese Weise kann eine beliebige Anzahl von Befehlen erstellt und registriert werden. Der eindeutige Name sollte gut gewählt sein und erlaubt die Gruppierung von Befehlen mit dem Zeichen `:` (z.B. `user:create`, `user:remove`, usw.).",
        "Arguments": "Argumente",
        "Arguments are just parameters of the `execute` method or the function. They are automatically mapped to the command line arguments.": "Argumente sind lediglich Parameter der Methode `execute` oder der Funktion. Sie werden automatisch auf die Kommandozeilenargumente abgebildet.",
        "If you mark a parameter optional, it is not required to be passed. If you have a default value, it is also not required to be passed.": "Wenn Sie einen Parameter als optional kennzeichnen, muss er nicht übergeben werden. Wenn Sie einen Standardwert angeben, muss dieser ebenfalls nicht übergeben werden.",
        "Depending on the type (string, number, union, etc) the passed value is automatically deserialized and validated.": "Je nach Typ (String, Zahl, Union usw.) wird der übergebene Wert automatisch deserialisiert und validiert.",
        "If you execute this command now without specifying the name parameter, an error will be issued:": "Wenn Sie diesen Befehl jetzt ausführen, ohne den Parameter name anzugeben, wird ein Fehler ausgegeben:",
        "By using `--help` you will get more information about the required arguments:": "Wenn Sie `--help` verwenden, erhalten Sie weitere Informationen über die erforderlichen Argumente:",
        "Once the name is passed as an argument, the command is executed and the name is passed correctly.": "Sobald der Name als Argument übergeben wird, wird der Befehl ausgeführt und der Name korrekt übergeben.",
        "Flags are another way to pass values to your command. Mostly these are optional, but they don`t have to be. Parameters decorated withFlag type decorator can be passed via --name value or --name=value.": "Flags sind eine weitere Möglichkeit, Werte an Ihren Befehl zu übergeben. Meistens sind diese optional, aber sie müssen es nicht sein. Parameter, die mit dem TypdekoratorFlag dekoriert sind, können mit --name value oder --name=value übergeben werden.",
        "In the help view you can see in the \"OPTIONS\" that a `--id` flag is necessary. If you enter this flag correctly, the command will receive this value.": "In der Hilfeansicht können Sie unter \"OPTIONEN\" sehen, dass ein `--id`-Flag notwendig ist. Wenn Sie dieses Flag korrekt eingeben, wird der Befehl diesen Wert erhalten.",
        "Flags have the advantage that they can also be used as a valueless flag, for example to activate a certain behavior. As soon as a parameter is marked as an optional Boolean, this behavior is activated.": "Flaggen haben den Vorteil, dass sie auch als wertlose Flagge verwendet werden können, zum Beispiel um ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolescher Wert markiert ist, wird dieses Verhalten aktiviert.",
        "To pass multiple values to the same flag, a flag can be marked as an array.": "Um mehrere Werte an dieselbe Flagge zu übergeben, kann eine Flagge als Array markiert werden.",
        "To allow a flag to be passed as a single character as well, `Flag<{char: 'x'}>` can be used.": "Damit ein Flag auch als einzelnes Zeichen übergeben werden kann, kann `Flag<{char: 'x'}>` verwendet werden.",
        "The signature of the method/function defines which arguments or flags are optional. If the parameter is optional in the type system, the user does not have to provide it.": "Die Signatur der Methode/Funktion definiert, welche Argumente oder Flags optional sind. Wenn der Parameter im Typsystem optional ist, muss der Benutzer ihn nicht angeben.",
        "The same for parameters with a default value:": "Dasselbe gilt für Parameter mit einem Standardwert:",
        "This also applies to flags in the same way.": "Dies gilt in gleicher Weise für Flaggen.",
        "All arguments and flags are automatically deserialized based on its types, validated and can be provided with additional constraints.": "Alle Argumente und Flags werden automatisch auf der Grundlage ihrer Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.",
        "Thus, arguments defined as numbers are always guaranteed to be real numbers in the controller, even though the command-line interface is based on text and thus strings. The conversion happens automatically with the feature xref:serialization.adoc#serialisation-loosely-convertion[].": "So ist gewährleistet, dass Argumente, die als Zahlen definiert sind, im Controller immer reelle Zahlen sind, auch wenn die Kommandozeilenschnittstelle auf Text und damit auf Strings basiert. Die Konvertierung erfolgt automatisch mit der Funktion xref:serialization.adoc#serialisation-loosely-convertion[].",
        "Additional constraints can be defined with the type decorators from `@deepkit/type`.": "Zusätzliche Beschränkungen können mit den Typdekoratoren aus `@deepkit/type` definiert werden.",
        "The type `Postive` in `id` indicates that only positive numbers are wanted. If the user now passes a negative number, the code will not be executed at all and an error message will be presented.": "Der Typ `Postiv` in `id` zeigt an, dass nur positive Zahlen erwünscht sind. Wenn der Benutzer nun eine negative Zahl übergibt, wird der Code überhaupt nicht ausgeführt und eine Fehlermeldung ausgegeben.",
        "If the number is positive, this works again as before. This additional validation, which is very easy to do, makes the command much more robust against wrong entries. See the chapter xref:validation.adoc[Validation] for more information.": "Wenn die Zahl positiv ist, funktioniert der Befehl wieder wie zuvor. Diese zusätzliche Validierung, die sehr einfach durchzuführen ist, macht den Befehl wesentlich robuster gegen Fehleingaben. Weitere Informationen finden Sie im Kapitel xref:validation.adoc[Validation].",
        "To describe a flag or argument, use `@description` comment decorator.": "Um ein Flag oder Argument zu beschreiben, verwenden Sie den Kommentardekorator `@description`.",
        "In the help view, this description appears after the flag or argument:": "In der Hilfeansicht erscheint diese Beschreibung nach dem Flag oder Argument:",
        "The exit code is 0 by default, which means that the command was executed successfully. To change the exit code, a number other than 0 should be returned in the exucute method.": "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollte in der exucute-Methode eine andere Zahl als 0 zurückgegeben werden.",
        "The class and function of the command is managed by the DI Container, so dependencies can be defined that are resolved via the DI Container.": "Die Klasse und Funktion des Befehls wird vom DI Container verwaltet, so dass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.",
        "First application": "Erste Anwendung",
        "Welcome to the Deepkit documentation. In this documentation you will find more information about the use of each library and the Deepkit framework in full detail with sample code.": "Willkommen bei der Deepkit-Dokumentation. In dieser Dokumentation finden Sie weitere Informationen über die Verwendung der einzelnen Bibliotheken und das Deepkit-Framework in allen Einzelheiten mit Beispielcode.",
        "Work in Progress": "Laufende Arbeiten",
        "This documentation is still in progress. Within the documentation there are still many placeholders that have not been written. We are constantly improving the documentation. If you need something urgently, please go to our Discord server.": "Diese Dokumentation ist noch in Arbeit. Innerhalb der Dokumentation gibt es noch viele Platzhalter, die noch nicht geschrieben wurden. Wir sind ständig dabei, die Dokumentation zu verbessern. Wenn Sie dringend etwas brauchen, gehen Sie bitte auf unseren Discord-Server.",
        "API": "API",
        "Use the API documentation to get very detailed information about the API of each module.": "Verwenden Sie die API-Dokumentation, um sehr detaillierte Informationen über die API der einzelnen Module zu erhalten.",
        "link:https://api.framework.deepkit.io/[API Documentation, role=big]": "link:https://api.framework.deepkit.io/[API-Dokumentation, role=big]",
        "Support": "Unterstützung",
        "If you need help, please join the Discord community server:": "Wenn Sie Hilfe benötigen, treten Sie bitte dem Discord-Community-Server bei:",
        "link:https://deepkit.io/community[Community, role=big]": "link:https://deepkit.io/community[Gemeinschaft, role=big]",
        "TypeScript has become powerful enough to describe complex structures and even replace declaration formats like GraphQL, ProtoBuf, and JSON-Schema entirely. With a runtime type system, it's possible to cover the use cases of these tools without any code generators or runtime JavaScript type declaration libraries like \"Zod\". The Deepkit library aims to provide runtime type information and make it easier to develop efficient and compatible solutions.": "TypeScript ist mittlerweile leistungsfähig genug, um komplexe Strukturen zu beschreiben und sogar Deklarationsformate wie GraphQL, ProtoBuf und JSON-Schema vollständig zu ersetzen. Mit einem Laufzeit-Typsystem ist es möglich, die Anwendungsfälle dieser Werkzeuge ohne Code-Generatoren oder Laufzeit-JavaScript-Typdeklarationsbibliotheken wie \"Zod\" abzudecken. Die Deepkit-Bibliothek zielt darauf ab, Laufzeit-Typinformationen bereitzustellen und die Entwicklung effizienter und kompatibler Lösungen zu erleichtern.",
        "Deepkit is built upon the ability to read type information at runtime, using as much TypeScript type information as possible for efficiency. The runtime type system allows reading and computing dynamic types, such as class properties, function parameters, and return types. Deepkit hooks into TypeScript's compilation process to ensure that all type information is embedded into the generated JavaScript using a https://github.com/microsoft/TypeScript/issues/47658[custom bytecode and virtual machine], enabling developers to access type information programmatically.": "Deepkit basiert auf der Fähigkeit, Typinformationen zur Laufzeit zu lesen, wobei aus Effizienzgründen so viele TypeScript-Typinformationen wie möglich verwendet werden. Das Laufzeit-Typsystem ermöglicht das Lesen und Berechnen dynamischer Typen, wie Klasseneigenschaften, Funktionsparameter und Rückgabetypen. Deepkit klinkt sich in den Kompilierungsprozess von TypeScript ein, um sicherzustellen, dass alle Typinformationen in das generierte JavaScript eingebettet werden, indem eine https://github.com/microsoft/TypeScript/issues/47658[custom bytecode and virtual machine] verwendet wird, so dass Entwickler programmatisch auf Typinformationen zugreifen können.",
        "To work directly with the type information itself, there are two basic variants: Type objects and Reflection classes. Type objects are regular JS objects returned by `typeOf<T>()`. Reflection classes are discussed below.": "Um direkt mit den Typinformationen selbst zu arbeiten, gibt es zwei grundlegende Varianten: Typobjekte und Reflexionsklassen. Type-Objekte sind reguläre JS-Objekte, die von `typeOf<T>()` zurückgegeben werden. Reflection-Klassen werden weiter unten behandelt.",
        "The function `typeOf` works for all types, including interfaces, object literals, classes, functions, and type aliases. It returns a type object that contains all the information about the type. You can pass any type as a type argument, including generics.": "Die Funktion `typeOf` funktioniert für alle Typen, einschließlich Schnittstellen, Objektliterale, Klassen, Funktionen und Typ-Aliase. Sie gibt ein Typobjekt zurück, das alle Informationen über den Typ enthält. Sie können jeden Typ als Typargument übergeben, auch generische Typen.",
        "The type object is a simple object literal that contains a `kind` property that indicates the type of the type object. The `kind` property is a number and gets its meaning from the enum `ReflectionKind`. `ReflectionKind` is defined in the `@deepkit/type` package as follows:": "Das Typobjekt ist ein einfaches Objektliteral, das eine Eigenschaft \"kind\" enthält, die den Typ des Typobjekts angibt. Die Eigenschaft `kind` ist eine Zahl und erhält ihre Bedeutung aus dem Enum `ReflectionKind`. Die Eigenschaft `ReflectionKind` ist im Paket `@deepkit/type` wie folgt definiert:",
        "Reflection Classes": "Reflexionsklassen",
        "An event system allows application components within the same process to communicate by sending and listening to events. This aids in code modularization by facilitating message exchanges between functions that might not directly be aware of each other.": "Ein Event-System ermöglicht Anwendungskomponenten innerhalb desselben Prozesses die Kommunikation durch das Senden und Abhören von Ereignissen. Dies trägt zur Modularisierung des Codes bei, indem es den Nachrichtenaustausch zwischen Funktionen erleichtert, die sich möglicherweise nicht direkt kennen.",
        "The application or library provides an opportunity to execute additional functions at specific points during its operation. These additional functions register themselves as what are termed \"event listeners\".": "Die Anwendung oder Bibliothek bietet die Möglichkeit, zu bestimmten Zeitpunkten während ihres Betriebs zusätzliche Funktionen auszuführen. Diese Zusatzfunktionen registrieren sich als so genannte \"Event Listener\".",
        "An event can take various forms:": "Ein Ereignis kann verschiedene Formen annehmen:",
        "The application starts up or shuts down.": "Die Anwendung wird gestartet oder heruntergefahren.",
        "A new user is created or deleted.": "Ein neuer Benutzer wird erstellt oder gelöscht.",
        "An error is thrown.": "Es wird ein Fehler ausgelöst.",
        "A new HTTP request is received.": "Eine neue HTTP-Anfrage wird empfangen.",
        "The Deepkit Framework and its associated libraries offer a range of events that users can listen to and respond to. However, users also have the flexibility to create as many custom events as needed, allowing for modular expansion of the application.": "Das Deepkit-Framework und die zugehörigen Bibliotheken bieten eine Reihe von Ereignissen, auf die der Benutzer hören und reagieren kann. Die Benutzer haben jedoch auch die Flexibilität, so viele benutzerdefinierte Ereignisse wie nötig zu erstellen, was eine modulare Erweiterung der Anwendung ermöglicht.",
        "Below is an example of the low-level API from @deepkit/event. When using the Deepkit Framework, event listeners are not registered directly via the EventDispatcher, but rather through modules. But you can still use the low-level API if you want to.": "Nachfolgend finden Sie ein Beispiel für die Low-Level-API von @deepkit/event. Bei der Verwendung des Deepkit-Frameworks werden Ereignis-Listener nicht direkt über den EventDispatcher registriert, sondern über Module. Sie können aber trotzdem die Low-Level-API verwenden, wenn Sie das möchten.",
        "Since Deepkit's event system is based on runtime types, it's essential to have @deepkit/type installed correctly. For further details, refer to xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Da das Event-System von Deepkit auf Laufzeittypen basiert, ist es wichtig, dass @deepkit/type korrekt installiert ist. Weitere Einzelheiten finden Sie in xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Once this is successfully accomplished, you can install @deepkit/event or the entire Deepkit Framework, which already includes the library under the hood.": "Sobald dies erfolgreich abgeschlossen ist, können Sie @deepkit/event oder das gesamte Deepkit-Framework installieren, das die Bibliothek bereits unter der Haube enthält.",
        "It's important to note that @deepkit/event relies on TypeScript decorators for its class listeners. Therefore, when using a class, you'll need to enable the `experimentalDecorators` feature.": "Es ist wichtig zu beachten, dass @deepkit/event auf TypeScript-Dekoratoren für seine Klassen-Listener angewiesen ist. Wenn Sie eine Klasse verwenden, müssen Sie daher die Funktion \"ExperimentalDecorators\" aktivieren.",
        "As soon as the library is installed, the API can be used directly.": "Sobald die Bibliothek installiert ist, kann die API direkt verwendet werden.",
        "At the core of Deepkit's event system are Event Tokens. These are unique objects that specify both the event ID and the type of event. An event token serves two primary purposes:": "Das Herzstück des Event-Systems von Deepkit sind Ereignis-Token. Dies sind eindeutige Objekte, die sowohl die Ereignis-ID als auch die Art des Ereignisses angeben. Ein Ereignis-Token dient zwei primären Zwecken:",
        "It acts as a trigger for an event.": "Er dient als Auslöser für ein Ereignis.",
        "It listens to the event it triggers.": "Es hört auf das Ereignis, das es auslöst.",
        "When an event gets triggered from an event token, the owner of that token is conceptually the entity that initiated the event. The event token decides the data available at the event and whether asynchronous event listeners are allowed.": "Wenn ein Ereignis von einem Ereignis-Token ausgelöst wird, ist der Besitzer dieses Tokens konzeptionell die Entität, die das Ereignis ausgelöst hat. Das Ereignis-Token entscheidet, welche Daten für das Ereignis verfügbar sind und ob asynchrone Ereignis-Listener erlaubt sind.",
        "Creating Custom Event Data:": "Benutzerdefinierte Ereignisdaten erstellen:",
        "Using `DataEventToken` from @deepkit/event:": "Verwendung von `DataEventToken` aus @deepkit/event:",
        "Extending BaseEvent:": "Erweitern von BaseEvent:",
        "Functional Listeners": "Funktionale Zuhörer",
        "Functional listeners allow users to register a simple function callback with the dispatcher directly. Here's how:": "Funktionale Listener ermöglichen es Benutzern, einen einfachen Funktionsrückruf direkt beim Dispatcher zu registrieren. So geht's:",
        "If you wish to introduce additional arguments like `logger: Logger`, they are automatically injected by the dependency injection system, thanks to Deepkit's runtime type reflection.": "Wenn Sie zusätzliche Argumente einführen möchten, wie `logger: Logger`, werden sie dank der Deepkit-Laufzeittyp-Reflexion automatisch vom System für die Injektion von Abhängigkeiten injiziert.",
        "Note that the first argument has to be the event itself. You can not avoid this argument.": "Beachten Sie, dass das erste Argument das Ereignis selbst sein muss. Sie können dieses Argument nicht vermeiden.",
        "If you use `@deepkit/app`, you can also use app.listen() to register a functional listener.": "Wenn Sie `@deepkit/app` verwenden, können Sie auch app.listen() verwenden, um einen funktionalen Listener zu registrieren.",
        "Class-based Listeners": "Klassenbasierte Zuhörer",
        "Class listeners are classes adorned with decorators. They offer a structured way to listen to events.": "Klassen-Listener sind Klassen, die mit Dekoratoren ausgestattet sind. Sie bieten eine strukturierte Möglichkeit, auf Ereignisse zu hören.",
        "For class listeners, dependency injection works through either the method arguments or the constructor.": "Bei Klassenhörern funktioniert die Dependency Injection entweder über die Methodenargumente oder den Konstruktor.",
        "Deepkit's event system boasts a powerful dependency injection mechanism. When using functional listeners, additional arguments get automatically injected thanks to the runtime type reflection system. Similarly, class-based listeners support dependency injection through either the constructor or method arguments.": "Das Event-System von Deepkit verfügt über einen leistungsfähigen Mechanismus zur Injektion von Abhängigkeiten. Bei der Verwendung von funktionalen Hörern werden zusätzliche Argumente dank des Laufzeit-Typ-Reflexionssystems automatisch injiziert. In ähnlicher Weise unterstützen klassenbasierte Listener die Injektion von Abhängigkeiten entweder über die Konstruktor- oder Methodenargumente.",
        "For example, in the case of a functional listener, if you add an argument like `logger: Logger`, the correct Logger instance gets automatically provided when the function gets called.": "Wenn Sie zum Beispiel im Fall eines funktionalen Listeners ein Argument wie `logger: Logger` hinzufügen, wird automatisch die richtige Logger-Instanz bereitgestellt, wenn die Funktion aufgerufen wird.",
        "Event Propagation": "Ausbreitung von Ereignissen",
        "Every event object comes equipped with a stop() function, allowing you to control the propagation of the event. If an event is halted, no subsequent listeners (in the order they were added) will be executed. This provides granular control over the execution and handling of events, especially useful in scenarios where certain conditions may require the halting of event processing.": "Jedes Ereignisobjekt ist mit einer stop()-Funktion ausgestattet, mit der Sie die Ausbreitung des Ereignisses steuern können. Wenn ein Ereignis gestoppt wird, werden keine nachfolgenden Listener (in der Reihenfolge, in der sie hinzugefügt wurden) ausgeführt. Dies ermöglicht eine genaue Kontrolle über die Ausführung und Behandlung von Ereignissen, was besonders in Szenarien nützlich ist, in denen bestimmte Bedingungen das Anhalten der Ereignisverarbeitung erfordern.",
        "For instance:": "Zum Beispiel:",
        "With the Deepkit framework's event system, developers can create modular, scalable, and maintainable applications with ease. Understanding the event system provides the flexibility to tailor the application's behavior based on specific occurrences or conditions.": "Mit dem Event-System des Deepkit-Frameworks können Entwickler mühelos modulare, skalierbare und wartbare Anwendungen erstellen. Das Verständnis des Event-Systems bietet die Flexibilität, das Verhalten der Anwendung auf der Grundlage von bestimmten Ereignissen oder Bedingungen anzupassen."
    },
    "chinese": {
        "Introduction": "简介",
        "TypeScript is JavaScript that scales. A language designed to implement complex use cases. It allows JavaScript to be written with types that are checked and removed at compile time. This resulting type safety allows for easier writing and maintenance of complex applications. This, among other things, is what has made TypeScript so popular: It allows finding bugs in code, especially on a large scale, much faster and easier than would be possible with pure JavaScript - and it works with JavaScript, not against it.": "TypeScript是可以扩展的JavaScript。一种旨在实现复杂用例的语言。它允许用类型来编写JavaScript，这些类型在编译时被检查和删除。这种产生的类型安全允许更容易地编写和维护复杂的应用程序。除其他事项外，这也是TypeScript如此受欢迎的原因：它允许寻找代码中的错误，特别是在大规模的情况下，比纯JavaScript更快、更容易--而且它与JavaScript一起工作，而不是反对它。",
        "Deepkit is TypeScript that scales. A framework written in TypeScript for TypeScript, designed to develop very complex software in TypeScript. It brings many design patterns known from the Enterprise to TypeScript and introduces completely new features that are only possible with TypeScript’s new type system to increase development speed especially in teams. Small applications can also benefit from this new approach, as Deepkit comes with many libraries for very common use cases that can be used individually or in combination. The framework itself is designed to be as agile as possible and as complex as necessary, not only to get initial results quickly, but also to maintain development speed in the long term.": "Deepkit是可以扩展的TypeScript。一个用TypeScript编写的框架，旨在用TypeScript开发非常复杂的软件。它将许多企业中已知的设计模式带到了TypeScript中，并引入了全新的功能，只有TypeScript的新类型系统才能提高开发速度，尤其是在团队中。小型应用程序也可以从这种新方法中受益，因为Deepkit为非常常见的用例配备了许多库，可以单独或组合使用。该框架本身的设计是尽可能的灵活，并在必要时尽可能的复杂，这不仅是为了快速获得初步的结果，也是为了长期保持开发速度。",
        "JavaScript is now the largest developer community in the world and provides the developer with a correspondingly large selection of many libraries and tools to cover the needs of a project. However, it is not always easy to find the right library. Often the philosophies, API and code qualities of these differ so much that a lot of sticky code and additional abstractions have to be introduced by the developer in order for these libraries to work properly with each other at all. The provision of core functions, which are needed by virtually every project, in nicely abstracted libraries brought together in a framework by a manufacturer or a community has proven itself again and again in the last decades: Java Spring, PHP Symfony/Laravel, and C++ QT are just a few very well-known and successful examples. These frameworks offer to the developer often far common and decades proven concepts, which are converted into libraries or components, in order to be able to be used so comfortably among themselves harmonizing demand-fairly. The offered functionalities and design patterns are thereby not cubed, but based on sometimes over decades old concepts, which worked satisfactorily by the fight in the competition with alternative ideas.": "JavaScript现在是世界上最大的开发者社区，为开发者提供了相应的许多库和工具的选择，以满足项目的需要。然而，要找到合适的库并不总是容易的。通常，这些库的理念、API和代码质量差别很大，以至于开发人员必须引入大量的粘性代码和额外的抽象，才能使这些库彼此之间正常工作。在过去的几十年里，制造商或社区将几乎每个项目都需要的核心功能提供给抽象化的库，并将其整合到一个框架中，这一点已被反复证明：Java的Spring、PHP的Symfony/Laravel和C++的QT只是几个非常知名和成功的例子。这些框架提供给开发者的往往是常见的、经过几十年验证的概念，这些概念被转换成库或组件，以便能够在他们之间舒适地使用，并协调需求--公平。因此，所提供的功能和设计模式不是立体的，而是基于有时超过几十年的旧概念，这些概念在与其他想法的竞争中令人满意地工作。",
        "JavaScript has seen massive progress over the years, so that more and more design patterns from the enterprise environment can now be applied. Design patterns that can be found in more and more libraries, frameworks, and tools. However, JavaScript and also TypeScript have the problem that in order to efficiently apply many proven enterprise patterns, decisive functions are missing in the language itself. This does not mean that these design patterns cannot be applied in general, but that they are less efficient than in other current languages.": "这些年来，JavaScript已经有了巨大的进步，所以现在越来越多来自企业环境的设计模式可以被应用。在越来越多的库、框架和工具中可以找到这些设计模式。然而，JavaScript和TypeScript有一个问题，为了有效地应用许多已被证实的企业模式，在语言本身中缺少决定性的功能。这并不意味着这些设计模式不能被普遍应用，而是意味着它们的效率不如当前其他语言。",
        "TypeScript completely removes its type information at compile time, once TypeScript is converted to JavaScript, so no information about it exists in the generated JavaScript or at runtime. It is undeniable that types are very valuable during development and when checking the correctness of the program. However, types also have tremendous value at runtime. This value is reflected where at runtime data is transformed (converted/serialized), data is validated, meta-information is added to objects, or interface information is required. In these and many other use cases, type information can be very useful at runtime because it provides libraries with the information needed to efficiently provide functionality. Currently, many of these use cases instead use alternatives that incompletely mimic TypeScript’s type system, forcing the developer to write types in a new way that has nothing to do with TypeScript’s syntax. The result is that TypeScript’s powerful type system can no longer show its strength here, and less ergonomic and less efficient ways of working must be used instead.": "TypeScript在编译时完全删除了它的类型信息，一旦TypeScript被转换为JavaScript，那么在生成的JavaScript中或在运行时就不存在任何相关信息。不可否认，在开发过程中和检查程序的正确性时，类型是非常有价值的。然而，类型在运行时也有巨大的价值。这种价值体现在运行时数据被转换（转换/序列化），数据被验证，元信息被添加到对象，或者需要接口信息。在这些和其他许多用例中，类型信息在运行时可能非常有用，因为它为库提供了有效提供功能所需的信息。目前，许多这些用例反而使用了不完全模仿TypeScript类型系统的替代品，迫使开发者以一种与TypeScript语法无关的新方式编写类型。其结果是，TypeScript强大的类型系统在这里无法再显示出它的优势，而必须使用不那么符合人体工程学和效率的工作方式来代替。",
        "Deepkit Framework": "Deepkit框架",
        "Deepkit has developed a type compiler that leaves type information in place, allowing dynamic types to be computed at runtime and existing type information to be read at runtime. With this paradigm shift, completely new ways of working are possible, providing the required information for the aforementioned use cases, radically simplifying the development of complex software, and giving the code more expressiveness. It is thus possible for the first time to use the full power and expressiveness of TypeScript at runtime as well.": "Deepkit开发了一种类型编译器，将类型信息留在原地，允许在运行时计算动态类型，并在运行时读取现有类型信息。随着这种模式的转变，全新的工作方式成为可能，为上述用例提供了所需的信息，从根本上简化了复杂软件的开发，并使代码具有更强的表现力。因此，第一次有可能在运行时也使用TypeScript的全部力量和表现力。",
        "Based on this paradigm shift, Deepkit has developed a whole set of libraries for use cases that can be found in just about any program: Validation, Serialization, Database Abstraction, CLI parser, HTTP Router, RPC Framework, Logger, Template System, Event System and many more. The fundamental difference from other libraries is that type information is at the core of the functionality and as much TypeScript as possible should be reused at runtime, so less boilerplate needs to be written by the developer and even complex programs can be seen at a glance what they are doing. Finally, one of the key features of TypeScript is to give expression to even complex code, and Deepkit brings these expressiveness benefits to the runtime in the form of a powerful framework to now better scale application architecture with appropriate enterprise patterns.": "基于这种模式的转变，Deepkit为几乎所有程序中都能找到的用例开发了一整套的库：验证、序列化、数据库抽象、CLI 分析器、HTTP 路由器、RPC 框架、记录器、模板系统、事件系统等等。与其他库的根本区别在于，类型信息是功能的核心，尽可能多的TypeScript应该在运行时被重用，所以开发者需要写的模板更少，即使是复杂的程序也能一眼看出它们在做什么。最后，TypeScript的主要特点之一是让复杂的代码也有表达能力，Deepkit以强大的框架形式将这些表达能力的好处带到了运行时，现在可以通过适当的企业模式更好地扩展应用架构。",
        "Deepkit consists of two large areas: One is the Deepkit Libraries and the Deepkit Framework. The Deepkit Libraries are a whole family of standalone TypeScript libraries (NPM packages) that are good at one topic and are optimized, well tested, and designed to complement each other optimally. A project can use individual Deepkit libraries, or the entire Deepkit framework, which brings together all the capabilities of the libraries and complements them with additional tools such as the debugger. All together, it allows the developer to create complex, fast, and production-ready applications. Deepkit supports a wide range of use cases. From simple command-line tools (CLI programs) to web applications and micro-services to desktop or mobile applications. The code is designed to run in any known JavaScript engine (browser as well as NodeJS) and integrates beautifully with other frameworks such as Angular, React, and Vue. The claim behind Deepkit Framework is to apply clean code, SOLID principles, and enterprise design patterns to not only offer correspondingly high code quality, but to allow the user to apply them as well. Deepkit also tries to promote these same principles in its documentation and examples, but does not force the developer to follow them themselves.": "Deepkit由两个大的领域组成：一个是Deepkit库和Deepkit框架。Deepkit库是一整个独立的TypeScript库（NPM包）家族，它们都擅长一个主题，并且经过优化、测试，旨在以最佳方式相互补充。一个项目可以使用单独的Deepkit库，也可以使用整个Deepkit框架，它汇集了这些库的所有功能，并以额外的工具（如调试器）对其进行补充。所有这些都使开发者能够创建复杂、快速和可投入生产的应用程序。Deepkit支持广泛的使用案例。从简单的命令行工具（CLI程序）到网络应用和微服务再到桌面或移动应用。这些代码被设计成可以在任何已知的JavaScript引擎（浏览器以及NodeJS）中运行，并与其他框架（如Angular、React和Vue）完美整合。Deepkit框架背后的主张是应用干净的代码、SOLID原则和企业设计模式，不仅提供相应的高代码质量，而且允许用户应用它们。Deepkit还试图在其文档和示例中推广这些相同的原则，但并不强迫开发者自己遵循这些原则。",
        "High-Performance": "高性能",
        "One of the most difficult problems in software development is to maintain a high development speed even after months or years, especially when the code and the team grow. There are many frameworks that promise to get you started quickly and allow you to cobble together more complex applications on your own in a very short time. However, these usually have the common problem that the development speed decreases drastically the older the project or the larger the team becomes. It is not uncommon that even after a few months and only a handful of developers, the development speed collapses to such an extent that it drops to 1% of the original speed. To counteract this phenomenon, it is necessary to apply established design patterns and use the right framework and libraries in advance. Enterprise design patterns have established themselves for the reason that they scale excellently even with larger applications and large teams. Correctly applied, they develop their capabilities especially when a project is to be developed over a longer period of time (several months to years).": "软件开发中最困难的问题之一是在数月或数年后仍能保持较高的开发速度，特别是在代码和团队成长的时候。有许多框架承诺让你快速入门，让你在很短的时间内自行拼凑出更复杂的应用程序。然而，这些框架通常有一个共同的问题，即项目越老或团队越大，开发速度就会急剧下降。即使在几个月后，只有少数几个开发人员，开发速度也会崩溃，以至于下降到原来速度的1%，这种情况并不罕见。为了抵制这种现象，有必要事先应用既定的设计模式并使用正确的框架和库。企业设计模式已经确立了自己的地位，原因是它们即使在较大的应用程序和大型团队中也能出色地扩展。正确的应用，它们会发展自己的能力，特别是当一个项目要在较长的时间内（几个月到几年）开发时。",
        "Design patterns have their advantages in theory, but in practice almost every pattern also has its disadvantages. These disadvantages vary depending on the language and framework, since the language and framework themselves determine how ergonomically a pattern can be applied. Just because a certain pattern can be used in a language, it does not mean that it automatically makes development better and faster. Some languages are better suited than others for applying certain patterns. With JavaScript or even TypeScript itself, various design patterns are often usable in the core, but there are limitations here that massively affect the user experience and thus speed. For example, Typescript decorators with all their idiosyncrasies may become necessary if a dependency injection framework specifies and is based on them. Deepkit’s runtime type system ensures that these design patterns can be applied in the most ergonomic way and with as little boilerplate as possible, unlocking their power to maintain high development speed not only initially, but also over the long term.": "设计模式在理论上有其优势，但在实践中，几乎每个模式都有其缺点。这些缺点因语言和框架的不同而不同，因为语言和框架本身决定了一个模式的应用是否符合人体工程学。仅仅因为某种模式可以在一种语言中使用，并不意味着它可以自动地使开发变得更好和更快。有些语言比其他语言更适合应用某些模式。对于JavaScript甚至TypeScript本身，各种设计模式往往可以在核心中使用，但这里有一些限制，大量影响了用户体验，从而影响了速度。例如，如果依赖注入框架指定并基于Typescript装饰器，那么Typescript装饰器及其所有的特异性就可能成为必要。Deepkit的运行时类型系统确保这些设计模式能够以最符合人体工程学的方式应用，并尽可能少地使用模板，从而释放出它们的力量，不仅在初期，而且在长期内都能保持高开发速度。",
        "Isomorphic TypeScript": "同构的TypeScript",
        "One of the biggest advantages of TypeScript is that complex code can be written better in many use cases. This includes frontend, backend, CLI tools, mobile and desktop apps, and much more. When a project spans these use cases and relies almost exclusively on TypeScript, it is called Isomorphic TypeScript. Using TypeScript in as much code as possible can massively increase development speed. So the following advantages are then suddenly available:": "TypeScript最大的优势之一是，在许多用例中可以更好地编写复杂的代码。这包括前端、后端、CLI工具、移动和桌面应用程序，以及更多。当一个项目跨越这些用例并几乎完全依赖TypeScript时，它被称为Isomorphic TypeScript。在尽可能多的代码中使用TypeScript可以极大地提高开发速度。因此，以下优势就突然出现了：",
        "Code can be shared between departments (frontend, backend, microservice, etc).": "代码可以在部门之间共享（前端、后端、微服务等）。",
        "Models, types and interfaces": "模型、类型和接口",
        "Validation": "审定",
        "Business logic": "业务逻辑",
        "A unified audit system of a single package manager.": "统一的审计系统的一个单一的软件包管理器。",
        "Reuse of known third-party libraries in all departments.": "在所有部门重新使用已知的第三方库。",
        "Knowledge sharing within teams.": "团队内部的知识共享。",
        "Recruitment is simplified to one group (and the biggest one: JavaScript developers).": "招聘工作被简化为一个群体（也是最大的一个群体：JavaScript开发人员）。",
        "Deepkit framework and its runtime type system are designed to exploit these and more advantages of Isomorphic TypeScript to the utmost, so that its maximum powers are revealed.": "Deepkit框架及其运行时类型系统旨在最大限度地利用Isomorphic TypeScript的这些以及更多的优势，从而展现其最大的力量。",
        "Old approaches such as the dual stack (frontend and backend in different languages) can no longer keep up by far, since the context switch between the languages alone already costs an enormous amount of energy and time. All the other advantages that have already been explained even make it an unfair comparison. An isomorphic tech stack like TypeScript, properly applied, is many times faster in development time on a fundamental level than any combination of a dual stack for backend/frontend like Java/JavaScript, PHP/JavaScript, or even JavaScript/JavaScript. Since faster development speed also means less time needed for the same features, it also means that Isomorphic TypeScript saves cash. Besides all the advantages already presented, this is the killer argument to use Isomorphic TypeScript in all the next especially commercial projects.": "旧的方法，如双栈（不同语言的前端和后端）已经远远跟不上了，因为单是语言之间的上下文切换就已经花费了大量的精力和时间。所有其他已经解释过的优势甚至使它成为一个不公平的比较。像TypeScript这样的同构技术栈，如果应用得当，在基本层面上的开发时间要比Java/JavaScript、PHP/JavaScript、甚至JavaScript/JavaScript这样的后端/前端双栈的任何组合快很多倍。由于更快的开发速度也意味着同样的功能需要更少的时间，这也意味着Isomorphic TypeScript节省了现金。除了已经介绍过的所有优点，这也是在接下来所有的特别是商业项目中使用Isomorphic TypeScript的致命理由。",
        "Runtime Types": "运行时类型",
        "Runtime type information in TypeScript unlocks new workflows and features that were previously unavailable or required workarounds. Modern development processes rely heavily on declaring types and schemas for tools like GraphQL, validators, ORMs, and encoders such as ProtoBuf. These tools may require developers to learn new languages specific to their use case, like ProtoBuf and GraphQL having their own declaration language, or validators using their own schema APIs or JSON-Schema.": "TypeScript中的运行时类型信息释放了新的工作流程和功能，这些功能以前是不可用的或需要变通的。现代开发流程在很大程度上依赖于为GraphQL、验证器、ORM和ProtoBuf等编码器等工具声明类型和模式。这些工具可能需要开发人员学习针对其使用情况的新语言，如ProtoBuf和GraphQL有自己的声明语言，或验证器使用自己的模式API或JSON-Chema。",
        "TypeScript has become powerful enough to describe complex structures and even replace declaration formats like GraphQL, ProtoBuf, and JSON-Schema entirely. With a runtime type system, it's possible to cover the use cases of these tools without any code generators. The Deepkit library aims to provide runtime type information and make it easier to develop efficient and compatible solutions.": "TypeScript已经强大到可以描述复杂的结构，甚至可以完全取代GraphQL、ProtoBuf和JSON-Schema等声明格式。有了运行时类型系统，就有可能在没有任何代码生成器的情况下涵盖这些工具的使用情况。Deepkit库的目的是提供运行时类型信息，并使开发高效和兼容的解决方案变得更加容易。",
        "Deepkit is built upon the ability to read type information at runtime, using as much TypeScript type information as possible for efficiency. The runtime type system allows reading and computing dynamic types, such as class properties, function parameters, and return types. Deepkit hooks into TypeScript's compilation process to ensure that all type information is embedded into the generated JavaScript, enabling developers to access type information programmatically.": "Deepkit建立在能够在运行时读取类型信息的基础上，尽可能多地使用TypeScript类型信息以提高效率。运行时类型系统允许读取和计算动态类型，如类属性、函数参数和返回类型。Deepkit 钩住 TypeScript 的编译过程，确保所有类型信息都嵌入到生成的 JavaScript 中，使开发人员能够以编程方式访问类型信息。",
        "With Deepkit, developers can use their existing TypeScript types for various application possibilities, simplifying their development process and making their work more efficient.": "通过Deepkit，开发者可以将他们现有的TypeScript类型用于各种应用的可能性，简化他们的开发过程，使他们的工作更有效率。",
        "Installation": "安装",
        "To install Deepkit's runtime type system two packages are needed. The type compiler in `@deepkit/type-compiler` and the runtime in `@deepkit/type`. The type compiler can be installed in `package.json` _devDependencies_, because it is only needed at build time.": "要安装 Deepkit 的运行时类型系统，需要两个软件包。`@deepkit/type-compiler`中的类型编译器和`@deepkit/type`中的运行时。类型编译器可以安装在`package.json`_devDependencies_中，因为它只在构建时需要。",
        "Runtime type information is not generated by default. It must be set `\"reflection\": true` in the `tsconfig.json` file to enable it in all files in the same folder of this file or in all subfolders. If decorators are to be used, `\"experimentalDecorators\": true` must be enabled in `tsconfig.json`. This is not strictly necessary to work with `@deepkit/type`, but necessary for certain functions of other deepkit libraries and in `@deepkit/framework`.": "运行时类型信息在默认情况下是不产生的。必须在`tsconfig.json`文件中设置`\"reflection\": true`，以便在这个文件的同一文件夹中的所有文件或所有子文件夹中启用它。如果要使用装饰器，`\"experimentalDecorators\": true`必须在`tsconfig.json`中启用。这对于使用`@deepkit/type`来说并不是严格必要的，但对于其他deepkit库和`@deepkit/framework`中的某些功能来说却是必要的。",
        "_File: tsconfig.json_": "文件: tsconfig.json_",
        "Type compiler": "类型编译器",
        "TypeScript itself does not allow to configure the type compiler via a `tsconfig.json`. It is necessary to either use the TypeScript compiler API directly or a build system like Webpack with _ts-loader_. To save this inconvenient way for Deepkit users, the Deepkit type compiler automatically installs itself in `node_modulestypescript` once `@deepkit/type-compiler` is installed (this is done via NPM install hooks).": "TypeScript本身不允许通过`tsconfig.json`来配置类型编译器。必须直接使用TypeScript编译器API，或者使用Webpack这样的构建系统与_ts-loader_。为了给Deepkit用户省去这种不方便的方式，一旦安装了`@deepkit/type-compiler`，Deepkit类型编译器就会自动安装在`node_modulestypescript`中（这是通过NPM安装挂钩完成的）。",
        "This makes it possible for all build tools that access the locally installed TypeScript (the one in `node_modulestypescript`) to automatically have the type compiler enabled. This makes _tsc_, Angular, webpack, _ts-node_, and some other tools automatically work with the deepkit type compiler.": "这使得所有访问本地安装的TypeScript（即`node_modulestypescript`中的那个）的构建工具都能自动启用类型编译器。这使得_tsc_、Angular、webpack、_ts-node_和其他一些工具自动与deepkit类型编译器一起工作。",
        "If the type compiler could not be successfully installed automatically (for example because NPM install hooks are disabled), this can be done manually with the following command:": "如果类型编译器不能成功地自动安装（例如因为NPM安装钩子被禁用），可以通过以下命令手动完成：",
        "Note that `deepkit-type-install` must be run if the local typescript version has been updated (for example, if the typescript version in package.json has changed and `npm install` is run).": "请注意，如果本地的typescript版本已经更新，则必须运行`deepkit-type-install`（例如，如果package.json中的typescript版本已经改变，并且运行了`npm install`）。",
        "Webpack": "网络包装",
        "If you want to use the type compiler in a webpack build, you can do so with the `ts-loader` package (or any other typescript loader that supports transformer registration).": "如果你想在webpack构建中使用类型编译器，你可以使用`ts-loader`包（或任何其他支持transformer注册的类型脚本加载器）来实现。",
        "_File: webpack.config.js_": "文件：webpack.config.js_",
        "Typen-Decorators": "类型化分解器",
        "Type decorators are normal TypeScript types that contain meta-information to change the behavior of various functions at runtime. Deepkit already provides some type decorators that cover some use cases. For example, a class property can be marked as primary key, reference, or index. The database library can use this information at runtime to create the correct SQL queries without prior code generation.": "类型装饰器是正常的 TypeScript 类型，它包含元信息，可以在运行时改变各种函数的行为。Deepkit 已经提供了一些类型装饰器，涵盖了一些使用情况。例如，一个类的属性可以被标记为主键、引用或索引。数据库库可以在运行时使用这些信息来创建正确的SQL查询，而无需事先生成代码。",
        "Validator constraints such as `MaxLength`, `Maximum`, or `Positive` can also be added to any type. It is also possible to tell the serializer how to serialize or deserialize a particular value. In addition, it is possible to create completely custom type decorators and read them at runtime, in order to use the type system at runtime in a very individual way.": "验证器的约束条件，如 \"最大长度\"、\"最大 \"或 \"正\"，也可以被添加到任何类型中。也可以告诉序列化器如何序列化或反序列化一个特定的值。此外，还可以创建完全自定义的类型装饰器，并在运行时读取它们，以便在运行时以非常个性化的方式使用类型系统。",
        "Deepkit comes with a whole set of type decorators, all of which can be used directly from `@deepkit/type`. They are designed not to come from multiple libraries, so as not to tie code directly to a particular library such as Deepkit RPC or Deepkit Database. This allows easier reuse of types, even in the frontend, although database type decorators are used for example.": "Deepkit 配备了一整套类型装饰器，所有这些都可以直接从 `@deepkit/type` 中使用。它们被设计成不来自多个库，这样就不会把代码直接绑在某个特定的库上，如Deepkit RPC或Deepkit数据库。这使得类型的重复使用更加容易，甚至在前端也是如此，尽管数据库类型装饰器被用来作为例子。",
        "Following is a list of existing type decorators. The validator and serializer of `@deepkit/type` and `@deepkit/bson` and Deepkit Database of `@deepkit/orm` used this information differently. See the corresponding chapters to learn more about this.": "以下是现有类型装饰器的列表。`@deepkit/type`和`@deepkit/bson`的验证器和序列化器以及`@deepkit/orm`的Deepkit数据库使用这些信息的方式不同。请参阅相应的章节，以了解更多相关信息。",
        "Integer/Float": "整数/浮点数",
        "Integer and floats are defined as a base as `number` and has several sub-variants:": "整数和浮点数被定义为 \"number \"的基数，并有几个子变种：",
        "Here the `id` of the user is a number at runtime, but is interpreted as an integer in the validation and serialization.": "这里，用户的`id'在运行时是一个数字，但在验证和序列化中被解释为一个整数。",
        "This means that here, for example, no floats may be used in validation and the serializer automatically converts floats into integers.": "这意味着在这里，例如，在验证中不得使用浮点数，序列化器会自动将浮点数转换为整数。",
        "The subtypes can be used in the same way and are useful if a specific range of numbers is to be allowed.": "子类型可以以同样的方式使用，如果要允许一个特定的数字范围，子类型是有用的。",
        "Float": "浮动",
        "UUID": "UUID",
        "UUID v4 is usually stored as a binary in the database and as a string in JSON.": "UUID v4通常在数据库中以二进制形式存储，在JSON中以字符串形式存储。",
        "MongoID": "MongoID",
        "Marks this field as ObjectId for MongoDB. Resolves as a string. Is stored in the MongoDB as binary.": "将此字段标记为MongoDB的ObjectId。解读为一个字符串。以二进制形式存储在MongoDB中。",
        "Bigint": "ǞǞǞ",
        "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save since bigint in JavaScript has an unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the types `BinaryBigInt` and `SignedBinaryBigInt` are available.": "默认情况下，正常的bigint类型在JSON中被序列化为数字（在BSON中为长）。然而，这限制了可以保存的内容，因为bigint在JavaScript中具有无限的潜在大小，而数字在JavaScript中和long在BSON中是有限的。为了绕过这个限制，可以使用`BinaryBigInt`和`SignedBinaryBigInt`类型。",
        "`BinaryBigInt` is the same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (`abs(x)`).": "`BinaryBigInt`与bigint相同，但在数据库中序列化为无限大小的无符号二进制（而不是大多数数据库的8字节），在JSON中序列化为字符串。负值将被转换为正值（`abs(x)`）。",
        "Deepkit ORM stores BinaryBigInt as a binary field.": "Deepkit ORM将BinaryBigInt存储为一个二进制字段。",
        "`SignedBinaryBigInt` is the same as `BinaryBigInt` but is able to store negative values as well. Deepkit ORM stores `SignedBinaryBigInt` as binary. The binary has an additional leading sign byte and is represented as an uint: 255 for negative, 0 for zero, or 1 for positive.": "`SignedBinaryBigInt`与`BinaryBigInt`相同，但也能存储负值。Deepkit ORM将`SignedBinaryBigInt`存储为二进制。二进制有一个额外的前导符号字节，并被表示为一个uint：255表示负数，0表示零，1表示正数。",
        "MapName": "地图名称",
        "To change the name of a property in the serialization.": "要改变序列化中一个属性的名称。",
        "Group": "集团",
        "Properties can be grouped together. For serialization you can for example exclude a group from serialization. See the chapter Serialization for more information.": "属性可以被归为一组。对于序列化，你可以从序列化中排除一个组。更多信息请参见序列化一章。",
        "Data": "数据",
        "Excluded": "不包括",
        "Each property can be excluded from the serialization process for a specific target.": "每个属性都可以被排除在特定目标的序列化过程之外。",
        "Embedded": "嵌入",
        "Marks the field as an embedded type.": "将该字段标记为嵌入类型。",
        "It's possible to change the prefix (which is per default the property name).": "可以改变前缀（默认为属性名称）。",
        "Entity": "实体",
        "To annotate interfaces with entity information. Only used in the database context.": "用实体信息来注释接口。只在数据库背景下使用。",
        "InlineRuntimeType": "InlineRuntimeType",
        "TODO": "TODO",
        "ResetDecorator": "ResetDecorator",
        "Database": "数据库",
        "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.",
        "See xref:validation.adoc#validation-constraint-types[Validation Constraint Types].": "见xref:validation.adoc#validation-constraint-types[验证约束类型]。",
        "Custom Type Decorators": "自定义类型的装饰者",
        "aTypeDecoratorCanBeDefinedAsFollows": "aTypeDecorator可以被定义为如下内容",
        "By convention, a type decorator is defined to be an object literal with a single optional property `__meta` that has a tuple as its type. The first entry in this tuple is its unique name and all subsequent tuple entries are arbitrary options. This allows a type decorator to be equipped with additional options.": "根据惯例，一个类型装饰器被定义为一个具有单一可选属性`__meta`的对象字面，它的类型是一个元组。这个元组的第一个条目是它的唯一名称，所有后续的元组条目是任意的选项。这使得一个类型装饰器可以配备额外的选项。",
        "The type decorator is used with the intersection operator `&`. Any number of type decorators can be used on one type.": "类型装饰器与相交运算符`&`一起使用。任何数量的类型装饰器都可以在一个类型上使用。",
        "The type decorators can be read out via the type objects of `typeOf<T>()` and `metaAnnotation`:": "类型装饰器可以通过`typeOf<T>()`和`metaAnnotation`的类型对象读出来：",
        "The result in `annotation` is either an array with options if the type decorator `myAnnotation` was used or `undefined` if not. If the type decorator has additional options as seen in `AnnotationOption`, the passed values can be found in the array.": "如果使用了类型装饰器`myAnnotation`，`annotation`中的结果是一个带有选项的数组，如果没有，则是`undefined`。如果类型装饰器有额外的选项，如在`AnnotationOption`中看到的，可以在数组中找到传递的值。",
        "Already supplied type decorators like `MapName`, `Group`, `Data`, etc have their own annotation object:": "已经提供的类型装饰器如`MapName`、`Group`、`Data`等都有自己的注释对象：",
        "External Classes": "外来班级",
        "Since TypeScript does not include type information per default, imported types/classes from other packages (that did not use @deepkit/type-compiler) will not have type information available.": "由于TypeScript默认不包括类型信息，因此从其他软件包（没有使用@deepkit/type-compiler）导入的类型/类将没有类型信息。",
        "To annotate types for an external class, use `annotateClass` and make sure this function is executed in the bootstrap phase of your application before the imported class is used somewhere else.": "要为一个外部类注释类型，请使用`annotateClass`，并确保这个函数在你的应用程序的引导阶段执行，然后再在其他地方使用导入的类。",
        "`MyExternalClass` can now be used in serialization functions and in the reflection API.": "`MyExternalClass`现在可以在序列化函数和反射API中使用。",
        "To following shows how to annotate generic classes:": "下面展示了如何注解通用类：",
        "Reflection": "反思",
        "To work directly with the type information itself, there are two basic variants: Type objects and Reflection classes. Reflection classes are discussed below. The function `typeOf` returns type objects, which are very simple object literals. It always contains a `kind` which is a number and gets its meaning from the enum `ReflectionKind`. `ReflectionKind` is defined in the `@deepkit/type` package as follows:": "为了直接处理类型信息本身，有两种基本的变体：类型对象和反射类。反射类将在下面讨论。函数`typeOf`返回类型对象，它是非常简单的对象字面。它总是包含一个`kind'，这是一个数字，并从枚举`ReflectionKind'中获得其含义。`ReflectionKind`在`@deepkit/type`包中定义如下：",
        "There are a number of possible type objects that can be returned. The simplest ones are `never`, `any`, `unknown`, `void, null,` and `undefined`, which are represented as follows:": "有许多可能的类型对象可以被返回。最简单的是 \"never\"、\"any\"、\"unknown\"、\"void\"、\"null \"和 \"undefined\"，它们表示如下：",
        "For example, number 0 is the first entry of the `ReflectionKind` enum, in this case `never`, number 1 is the second entry, here `any`, and so on. Accordingly, primitive types like `string`, `number`, `boolean` are represented as follows:": "例如，数字0是 \"ReflectionKind \"枚举的第一个条目，在这里是 \"never\"，数字1是第二个条目，这里是 \"any\"，以此类推。相应地，像 \"字符串\"、\"数字\"、\"布尔 \"这样的原始类型被表示如下：",
        "These rather simple types have no further information at the type object, because they were passed directly as type argument to `typeOf`. However, if types are passed via type aliases, additional information can be found at the type object.": "这些相当简单的类型在类型对象中没有进一步的信息，因为它们被直接作为类型参数传递给`typeOf`。然而，如果类型是通过类型别名传递的，在类型对象中可以找到额外的信息。",
        "In this case, the name of the type alias 'Title' is also available. If a type alias is a generic, the types passed will also be available at the type object.": "在这种情况下，类型别名 \"Title \"的名称也是可用的。如果一个类型别名是一个通用的，所传递的类型也将在类型对象中可用。",
        "If the type passed is the result of an index access operator, the container and the index type are present:": "如果传递的类型是一个索引访问操作符的结果，那么容器和索引类型就会出现：",
        "Interfaces and object literals are both output as Reflection.objectLiteral and contain the properties and methods in the `types` array.": "接口和对象文字都以Reflection.objectLiteral的形式输出，并包含`types`数组中的属性和方法。",
        "Index signatures are also in the `types` array.": "索引签名也在`types`数组中。",
        "Classes are similar to object literals and also have their properties and methods under a `types` array in addition to `classType` which is a reference to the class itself.": "类类似于对象字面，除了`classType`是对类本身的引用外，还在`types`数组下有其属性和方法。",
        "Note that the type of Reflection.propertySignature has changed to Reflection.property and Reflection.methodSignature has changed to Reflection.method. Since properties and methods on classes have additional attributes, this information can also be retrieved. The latter additionally include `visibility`, `abstract`, and `default`.": "注意Reflection.propertySignature的类型已经变成了Reflection.property，而Reflection.methodSignature则变成了Reflection.method。由于类上的属性和方法有额外的属性，这些信息也可以被检索到。后者额外包括`visibility`，`abstract`和`default`。",
        "Type objects of classes contain only the properties and methods of the class itself and not of super-classes. This is contrary to type objects of interfacesobject-literals, which have all property signatures and method signatures of all parents resolved into `types`. To resolve the property and methods of the super-classes, either ReflectionClass and its `ReflectionClass.getProperties()` (see following sections) or `resolveTypeMembers()` of `@deepkit/type` can be used.": "类的类型对象只包含类本身的属性和方法，而不是超类的。这与interfaceobject-literals的类型对象相反，后者将所有父类的所有属性签名和方法签名解析为`类型`。要解决超类的属性和方法，可以使用ReflectionClass和它的`ReflectionClass.getProperties()`（见以下章节）或者`@deepkit/type`的`resolveTypeMembers()`。",
        "There is a whole plethora of type objects. For example for literal, template literals, promise, enum, union, array, tuple, and many more. To find out which ones all exist and what information is available, it is recommended to import `Type` from `@deepkit/type`. It is a `union` with all possible subtypes like TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, and many more. There you can find the exact structure.": "有一大堆的类型对象。例如，字面意思、模板字面意思、承诺、枚举、联合、数组、元组，以及更多。要想知道哪些类型都存在，有哪些信息可用，建议从`@deepkit/type`导入`Type`。它是一个`union`，具有所有可能的子类型，如TypeAny、TypeUnknonwn、TypeVoid、TypeString、TypeNumber、TypeObjectLiteral、TypeArray、TypeClass，以及更多。在那里你可以找到确切的结构。",
        "Type Cache": "类型 缓存",
        "Type objects are cached for type aliases, functions, and classes as soon as no generic argument is passed. This means that a call to `typeOf<MyClass>()` always returns the same object.": "一旦没有传递通用参数，类型对象就会为类型别名、函数和类进行缓存。这意味着对`typeOf<MyClass>()`的调用总是返回同一个对象。",
        "However, as soon as a generic type is used, new objects are always created, even if the type passed is always the same. This is because an infinite number of combinations are theoretically possible and such a cache would effectively be a memory leak.": "然而，只要使用了通用类型，就总是会创建新的对象，即使传递的类型总是相同的。这是因为理论上有无限多的组合是可能的，这样的缓存实际上是一种内存泄漏。",
        "However, as soon as a type is instantiated multiple times in a recursive type, it is cached. However, the duration of the cache is limited only to the moment the type is computed and does not exist thereafter. Also, although the Type object is cached, a new reference is returned and is not the exact same object.": "然而，只要一个类型在递归类型中被多次实例化，它就被缓存了。然而，缓存的持续时间只限于类型被计算的那一刻，此后就不存在了。另外，虽然Type对象被缓存了，但会返回一个新的引用，而且不是完全相同的对象。",
        "`MyType<string>` is cached as long as `Object` is computed. The PropertySignature of `a` and `b` thus have the same `type` from the cache, but are not the same Type object.": "`MyType<string>`被缓存，只要`Object`被计算。因此，`a'和`b'的PropertySignature从缓存中具有相同的`类型'，但不是同一个Type对象。",
        "All non-root Type objects have a parent property, which usually points to the enclosing parent. This is valuable, for example, to find out whether a Type is part of a union or not.": "所有非根类型对象都有一个父属性，它通常指向包围的父对象。这很有价值，例如，找出一个类型是否是一个联盟的一部分。",
        "'Ref 1' points to the actual union type object.": "'参考1'指向实际的联合类型对象。",
        "For cached Type objects as exemplified above, the `parent` properties are not always the real parents. For example, for a class that is used multiple times, although immediate types in `types` (TypePropertySignature and TypeMethodSignature) point to the correct TypeClass, the `type` of these signature types point to the signature types of the TypeClass of the cached entry. This is important to know so as not to infinitely read the parent structure, but only the immediate parent. The fact that the parent does not have infinite precision is due to performance reasons.": "对于上面举例的缓存的Type对象，`parent`属性不一定是真正的父类。例如，对于一个多次使用的类，尽管`types`中的直接类型（TypePropertySignature和TypeMethodSignature）指向正确的TypeClass，但这些签名类型的`type`指向缓存条目的TypeClass的签名类型。知道这一点很重要，这样就不会无限地读取父结构，而只读取直接的父结构。父结构不具有无限精度的事实是由于性能的原因。",
        "JIT Cache": "JIT缓存",
        "In the further course some functions and features are described, which are often based on the type objects. To implement some of them in a performant way, a JIT (just in time) cache per type object is needed. This can be provided via `getJitContainer(type)`. This function returns a simple object on which arbitrary data can be stored. As long as no reference to the object is held, it will be deleted automatically by the GC as soon as the Type object itself is also no longer referenced.": "在进一步的课程中，我们描述了一些功能和特性，这些功能和特性往往是基于类型对象的。为了以一种高性能的方式实现其中的一些功能，需要为每个类型对象建立一个JIT（及时）缓存。这可以通过`getJitContainer(type)`提供。这个函数返回一个简单的对象，上面可以存储任意的数据。只要不持有对该对象的引用，只要Type对象本身也不再被引用，它就会被GC自动删除。",
        "Reflection-Klassen": "反射-镜面",
        "In addition to the `typeOf<>()` function, there are various reflection classes that provide an OOP alternative to the Type objects. The reflection classes are only available for classes, InterfaceObject literals and functions and their direct sub-types (Properties, Methods, Parameters). All deeper types must be read again with the Type objects.": "除了`typeOf<>()`函数外，还有各种反射类，它们为Type对象提供了一个OOP替代方案。反射类只适用于类、InterfaceObject字样和函数以及它们的直接子类型（属性、方法、参数）。所有更深层次的类型必须用类型对象重新读取。",
        "Receive type information": "接收类型信息",
        "In order to provide functions that operate on types, it can be useful to offer the user to pass a type manually. For example, in a validation function, it might be useful to provide the type to be requested as the first type argument and the data to be validated as the first function argument.": "为了提供对类型进行操作的函数，向用户提供手动传递类型可能是有用的。例如，在一个验证函数中，提供要请求的类型作为第一个类型参数和要验证的数据作为第一个函数参数可能是有用的。",
        "In order for this function to get the type `string`, it must tell this to the type compiler.": "为了让这个函数得到 \"string \"类型，它必须告诉类型编译器这一点。",
        "`ReceiveType` with the reference to the first type arguments `T` signals the type compiler that each call to `validate` should put the type in second place (since `type` is declared in second place). To then read out the information at runtime, the `resolveReceiveType` function is used.": "`ReceiveType`与第一个类型参数`T`的引用向类型编译器发出信号，每次调用`validate`都应该把类型放在第二位（因为`type`被声明在第二位）。然后要在运行时读出信息，就要使用`resolveReceiveType`函数。",
        "It is useful to assign the result to the same variable to avoid creating a new one unnecessarily. In `type` now either a type object is stored or an error is thrown, if for example no type argument was passed, Deepkit's type compiler was not installed correctly, or the emitting of type information is not activated (see the section Installation above).": "将结果分配给同一个变量是很有用的，可以避免不必要地创建一个新的变量。在`type`中，现在要么存储一个类型对象，要么抛出一个错误，例如，没有传递类型参数，Deepkit的类型编译器没有正确安装，或者没有激活类型信息的发射（见上面的安装一节）。",
        "Bytecode": "字节代码",
        "To learn in detail how Deepkit encodes and reads the type information in JavaScript, this chapter is intended. It explains how the types are actually converted into bytecode, emitted in JavaScript, and then interpreted at runtime.": "要详细了解 Deepkit 是如何编码和读取 JavaScript 中的类型信息的，本章就是要介绍。它解释了类型实际上是如何被转换为字节码，在 JavaScript 中发出，然后在运行时进行解释的。",
        "Typen-Compiler": "类型编译器",
        "The type compiler (in @deepkit/type-compiler) is responsible for reading the defined types in the TypeScript files and compiling them into a bytecode. This bytecode has everything needed to execute the types in runtime.": "类型编译器（在 @deepkit/type-compiler 中）负责读取 TypeScript 文件中定义的类型，并将其编译为字节码。这个字节码拥有在运行时执行这些类型所需的一切。",
        "At the time of this writing, the type compiler is a so-called TypeScript transformer. This transformer is a plugin for the TypeScript compiler itself and converts a TypeScript AST (Abstract Syntax Tree) into another TypeScript AST. Deepkit's type compiler reads the AST in this process, produces the corresponding bytecode, and inserts it into the AST.": "在写这篇文章的时候，类型编译器是一个所谓的TypeScript转化器。这个转化器是TypeScript编译器本身的一个插件，它将TypeScript AST（抽象语法树）转换成另一个TypeScript AST。Deepkit的类型编译器在这个过程中读取AST，产生相应的字节码，并将其插入AST中。",
        "TypeScript itself does not allow you to configure this plugin aka transformer via a tsconfig.json. It is either necessary to use the TypeScript compiler API directly, or a build system like Webpack with `ts-loader`. To save this inconvenient way for Deepkit users, the Deepkit type compiler automatically installs itself in `node_modulestypescript` whenever `@deepkit/type-compiler` is installed. This makes it possible for all build tools that access the locally installed TypeScript (the one in `node_modulestypescript`) to automatically have the type compiler enabled. This makes tsc, Angular, webpack, ts-node, and some other tools work automatically with Deepkit's type compiler.": "TypeScript本身并不允许你通过tsconfig.json来配置这个插件（又称转化器）。它要么需要直接使用TypeScript编译器API，要么需要像Webpack这样的构建系统与`ts-loader`。为了给Deepkit用户省去这种不方便的方式，Deepkit类型编译器在安装`@deepkit/type-compiler`时自动安装在`node_modulestypescript`中。这使得所有访问本地安装的TypeScript（即`node_modulestypescript`中的那个）的构建工具都能自动启用类型编译器。这使得 tsc、Angular、webpack、ts-node 和其他一些工具能够自动与 Deepkit 的类型编译器一起工作。",
        "If automatic running of NPM install scripts is not enabled and thus the locally installed typescript is not modified, this process must be run manually if you want to. Alternatively, the types compiler can be used manually in a build tool such as webpack. See the Installation section above.": "如果没有启用NPM安装脚本的自动运行功能，因此本地安装的类型脚本不会被修改，如果你想，这个过程必须手动运行。另外，也可以在webpack等构建工具中手动使用类型编译器。见上面的安装部分。",
        "Bytecode Encoding": "字节码编码",
        "The bytecode is a sequence of commands for a virtual machine and is encoded in the JavaScript itself as an array of references and string (the actual bytecode).": "字节码是虚拟机的命令序列，在JavaScript本身中被编码为一个引用数组和字符串（实际的字节码）。",
        "The existing commands themselves are each one byte in size and can be found in `@deepkit/type-spec` as `ReflectionOp` enums. At the time of this writing, the command set is over 81 commands in size.": "现有的命令本身只有一个字节大小，可以在`@deepkit/type-spec`中找到，作为`ReflectionOp`枚举。在撰写本文时，该命令集的大小超过了81条。",
        "A sequence of commands is encoded as a string to save memory. So a type `string[]` is conceptualized as a bytecode program `[string, array]` which has the bytes `[5, 37]` and encoded with the following algorithm:": "一系列的命令被编码为一个字符串，以节省内存。因此，一个类型`string[]`被概念化为一个字节码程序`[string, array]`，它的字节数为`[5, 37]`，并通过以下算法进行编码：",
        "Accordingly, a 5 becomes an `&` character and a 37 becomes an `F` character. Together they become `&F` and are emitted in Javascript as `['&F']`.": "因此，5成为一个`&'字符，37成为一个`F'字符。它们一起成为\"&F\"，并在Javascript中以\"['&F']\"的形式发射出来。",
        "To prevent naming conflicts, each type is given a \"_Ω\" prefix. For each explicitly defined type that is exported or used by an exported type, a bytecode is emitted the JavaScript. Classes and functions also receive a bytecode directly as a property.": "为了防止命名冲突，每个类型都有一个\"_Ω \"前缀。对于每个明确定义的、被导出或被导出的类型所使用的类型，都会有一个字节码被发射到JavaScript中。类和函数也直接作为一个属性接收字节码。",
        "Virtual Machine": "虚拟机",
        "A virtual machine (in `@deepkit/type` the class Processor) at runtime is responsible for decoding and executing the encoded bytecode. It always returns a type object, see the Reflection section above.": "运行时的虚拟机（在`@deepkit/type`中的类处理器）负责解码和执行编码的字节码。它总是返回一个类型对象，见上面的反思部分。",
        "Validation is the process of checking data for correctness. Correctness is given if the type is the correct one and additional defined constraints are fulfilled. Deepkit generally distinguishes between type validation and the validation of additional constraints.": "验证是检查数据正确性的过程。如果类型是正确的，并且满足了其他定义的约束条件，那么就说明是正确的。Deepkit通常将类型验证和附加约束的验证区分开来。",
        "Validation is used whenever data comes from a source that is considered uncertain. Uncertain means that no guaranteed assumptions can be made about the types or contents of the data, and thus the data could have literally any value at runtime.": "当数据来自一个被认为是不确定的来源时，就会使用验证。不确定意味着对数据的类型或内容不能做出有保证的假设，因此数据在运行时可能具有字面上的任何价值。",
        "For example, data from user input is generally not considered secure. Data from an HTTP request (query parameter, body), CLI arguments, or a read-in file must be validated. If a variable is declared as a number, there must also be a number in it, otherwise the program may crash or a security hole may occur.": "例如，来自用户输入的数据通常不被认为是安全的。来自HTTP请求（查询参数、正文）、CLI参数或读入文件的数据必须被验证。如果一个变量被声明为数字，其中也必须有一个数字，否则程序可能会崩溃或出现安全漏洞。",
        "In a controller of an HTTP route, for example, the top priority is to check every user input (query parameter, body). Especially in the TypeScript environment, it is important not to use type casts, as they are fundamentally insecure.": "例如，在HTTP路由的控制器中，首要任务是检查每个用户的输入（查询参数、正文）。特别是在TypeScript环境中，重要的是不要使用类型转换，因为它们从根本上是不安全的。",
        "This often seen code is a bug that can lead to a program crash or a security vulnerability because a type cast `as number` was used that does not provide any security at runtime. The user can simply pass a string as `limit` and the program would then work with a string in `limit`, although the code is based on the fact that it must be a number. To maintain this security at runtime there are validators and type guards. Also, a serializer could be used to convert `limit` to a number. More information about this can be found in xref:serialization.adoc[Serialization].": "这段经常看到的代码是一个错误，它可能导致程序崩溃或安全漏洞，因为使用了一个`作为数字'的类型转换，在运行时没有提供任何安全保障。用户可以简单地传递一个字符串作为`limit`，然后程序就会在`limit`中工作，尽管代码的基础是它必须是一个数字。为了在运行时保持这种安全性，有验证器和类型防护。另外，可以使用一个序列化器来将`limit`转换为一个数字。关于这一点的更多信息可以在xref:serialization.adoc[序列化]中找到。",
        "Validation is an essential part of any application and it is better to use it once too often than once too little. Deepkit provides many validation options and has a high-performance implementation, so in most cases there is no need to worry about execution time. Use as much validation as possible, in case of doubt once more, to be on the safe side.": "验证是任何应用程序的一个重要组成部分，经常使用一次总比少用一次好。Deepkit提供了许多验证选项，并有一个高性能的实现，所以在大多数情况下，不需要担心执行时间。为了安全起见，在有疑问的情况下，尽可能多地使用验证，再来一次。",
        "In doing so, many components of Deepkit such as the HTTP router, the RPC abstraction, but also the database abstraction itself have validation built in and is performed automatically, so in many cases it is not necessary to do this manually.": "这样一来，Deepkit的许多组件，如HTTP路由器、RPC抽象，以及数据库抽象本身都内置了验证功能，并自动执行，所以在许多情况下，没有必要手动操作。",
        "In the corresponding chapters (xref:cli.adoc[CLI], xref:http.adoc[HTTP], xref:rpc.adoc[RPC], xref:database.adoc[Database]) it is explained in detail when a validation happens automatically. Make sure that you know where restrictions or types have to be defined and don't use `any` to make these validations work well and safely automatically. This can save you a lot of manual work to keep the code clean and safe.": "在相应的章节（xref:cli.adoc[CLI], xref:http.adoc[HTTP], xref:rpc.adoc[RPC], xref:database.adoc[Database]）中，详细说明了验证何时自动发生。确保你知道在哪里必须定义限制或类型，不要使用`any`来使这些验证自动很好地安全工作。这可以为你节省大量的手工工作来保持代码的干净和安全。",
        "Use": "使用",
        "The basic function of the validator is to check a value for its type. For example, whether a value is a string. This is not about what the string contains, but only about its type. There are many types in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, and many more. Due to Typescript’s powerful type system, a large variety of different types are available.": "验证器的基本功能是检查一个值的类型。例如，一个值是否是一个字符串。这不是关于字符串包含什么，而只是关于它的类型。Typescript中有很多类型：字符串、数字、布尔值、bigint、对象、类、接口、泛型、映射类型等等。由于Typescript强大的类型系统，有大量的不同类型。",
        "In JavaScript itself, primitive types can be parsed with the `typeof` operator. For more complex types like interfaces, mapped types, or generic set/map this is not so easy anymore and a validator library like `@deepkit/type` becomes necessary. Deepkit is the only solution that allows to validate all TypesScript types directly without any detours.": "在JavaScript中，原始类型可以用`typeof`操作符进行解析。对于更复杂的类型，如接口、映射类型或通用集合/映射，这就不那么容易了，像`@deepkit/type`这样的验证器库就变得非常必要。Deepkit是唯一允许直接验证所有TypesScript类型的解决方案，不需要走任何弯路。",
        "In Deepkit, type validation can be done using either the `validate`, `is`, or `assert` function.": "在Deepkit中，可以使用`validate`、`is`或`assert`函数进行类型验证。",
        "The function `is` is a so-called type guard and `assert` is a type assertion. Both will be explained in the next section.": "函数`is`是一个所谓的类型保护，`assert`是一个类型断言。两者都将在下一节进行解释。",
        "The function `validate` returns an array of found errors and on success an empty array. Each entry in this array describes the exact error code and the error message as well as the path when more complex types like objects or arrays are validated.": "函数`validate`返回一个发现错误的数组，成功时返回一个空数组。这个数组中的每个条目都描述了确切的错误代码和错误信息，以及在验证更复杂的类型如对象或数组时的路径。",
        "All three functions are used in roughly the same way. The type is specified or referenced as the first type argument and the data is passed as the first function argument.": "所有这三个函数的使用方法大致相同。类型被指定或引用为第一个类型参数，数据被传递为第一个函数参数。",
        "If you work with more complex types like classes or interfaces, the array can also contain several entries.": "如果你处理更复杂的类型，如类或接口，数组也可以包含几个条目。",
        "The validator also supports deep recursive types. Paths are then separated with a dot.": "验证器也支持深度递归类型。然后用点来分隔路径。",
        "Take advantage of the benefits that TypeScript offers you. For example, more complex types like a `user` can be reused in multiple places without having to declare it again and again. For example, if a `user` is to be validated without its `id`, TypeScript utitilies can be used to quickly and efficiently create derived subtypes. Very much in the spirit of DRY (Don't Repeat Yourself).": "充分利用TypeScript为你提供的好处。例如，更复杂的类型，如`用户`，可以在多个地方重复使用，而不需要反复声明它。例如，如果一个 \"用户 \"要在没有 \"id \"的情况下进行验证，TypeScript工具可以用来快速有效地创建派生子类型。非常符合DRY（Don't Repeat Yourself）的精神。",
        "Deepkit is the only major framework that has the ability to access TypeScripts types in this way at runtime. If you want to use types in frontend and backend, types can be swapped out to a separate file and thus imported anywhere. Use this option to your advantage to keep the code efficient and clean.": "Deepkit是唯一能够在运行时以这种方式访问TypeScripts类型的主要框架。如果你想在前端和后端使用类型，可以将类型换成一个单独的文件，从而在任何地方导入。使用这个选项对你有利，可以保持代码的高效和简洁。",
        "A type cast (contrary to type guard) in TypeScript is not a construct at runtime, but is only handled in the type system itself. It is not a safe way to assign a type to unknown data.": "TypeScript中的类型转换（与类型保护相反）不是运行时的构造，而是只在类型系统本身中处理。它不是一个为未知数据分配类型的安全方式。",
        "The `as string` code is not safe. The variable `data` could have literally any value, for example `{username: 123}`, or even `{}`, and would have the consequence that `username` is not a string, but something completely different and therefore the code `username.startsWith('@')` will lead to an error, so that in the worst case the program crashes. To guarantee at runtime that `data` here has a property `username` with the type string, type-guards must be used.": "`作为字符串'的代码是不安全的。变量`data`可以有字面上的任何值，例如`{username: 123}`，甚至是`{}`，其结果是`username`不是一个字符串，而是完全不同的东西，因此代码`username.startsWith('@')`会导致一个错误，所以在最坏的情况下，程序会崩溃。为了保证在运行时`data`有一个类型为字符串的属性`username`，必须使用类型保护器。",
        "Type guards are functions that give TypeScript a hint about what type the passed data is guaranteed to have at runtime. Armed with this knowledge, TypeScript then \"narrows\" the type as the code progresses. For example, `any` can be made into a string, or any other type in a safe way. So if there is data of which the type is not known (`any` or `unknown`), a type guard helps to narrow it down more precisely based on the data itself. However, the type guard is only as safe as its implementation. If you make a mistake, this can have severe consequences, because fundamental assumptions suddenly turn out to be untrue.": "类型守卫是给TypeScript一个提示，告诉它在运行时保证传递的数据有什么类型的函数。有了这些知识，TypeScript就可以在代码进行过程中 \"缩小 \"类型。例如，`any`可以变成一个字符串，或任何其他类型的安全方式。因此，如果有不知道类型的数据（`any`或`unknown`），类型保护有助于根据数据本身更精确地缩小它。然而，类型保护只有在其实现时才是安全的。如果你犯了一个错误，这可能会产生严重的后果，因为基本的假设突然变成了不真实。",
        "Type-Guard": "类型-护卫",
        "A type guard on the above used type `User` could look in simplest form as follows. Note that the above explained special features with NaN are not part here and thus this type guard is not quite correct.": "对上述使用的类型`User`的类型保护，最简单的形式如下。请注意，上面解释的NaN的特殊功能不在这里，因此这个类型保护并不完全正确。",
        "A type guard always returns a Boolean and is usually used directly in an If operation.": "类型保护器总是返回一个布尔值，通常在If操作中直接使用。",
        "Writing a separate function for each type guard, especially for more complex types, and then adapting it every time a type changes is extremely tedious, error-prone, and not efficient. Therefore, Deepkit provides the function `is`, which automatically provides a Type-Guard for any TypeScript type. This then also automatically takes into account special features such as the above-mentioned problem with NaN. The function `is` does the same as `validate`, but instead of an array of errors it simply returns a boolean.": "为每个类型保护写一个单独的函数，特别是对于更复杂的类型，然后在每次类型变化时都要对其进行调整，这是非常繁琐的，容易出错，而且效率不高。因此，Deepkit 提供了函数 `is`，它为任何 TypeScript 类型自动提供了一个类型保护器。然后，这也会自动考虑到一些特殊的功能，比如上面提到的NaN的问题。函数`is`的作用与`validate`相同，但它不是一个错误数组，而只是返回一个布尔值。",
        "A pattern that can be found more often is to return an error directly in case of incorrect validation, so that subsequent code is not executed. This can be used in various places without changing the complete flow of the code.": "一个可以更经常发现的模式是在验证不正确的情况下直接返回错误，这样后续的代码就不会被执行。这可以用在不同的地方，而不改变代码的完整流程。",
        "Alternatively, a TypeScript type assertion can be used. The `assert` function automatically throws an error if the given data does not validate correctly to a type. The special signature of the function, which distinguishes TypeScript type assertions, helps TypeScript to automatically narrow the passed variable.": "另外，也可以使用TypeScript类型断言。如果给定的数据不能正确地验证为一个类型，`assert`函数会自动抛出一个错误。该函数的特殊签名，区别于TypeScript类型断言，有助于TypeScript自动缩小传递的变量。",
        "Here, too, take advantage of the benefits that TypeScript offers you. Types can be reused or customized using various TypeScript functions.": "在这里，也要利用TypeScript为你提供的好处。类型可以被重用或使用各种TypeScript函数进行定制。",
        "Error Reporting": "错误报告",
        "The functions `is`, `assert` and `validates` return a boolean as result. To get exact information about failed validation rules, the `validate` function can be used. It returns an empty array if everything was validated successfully. In case of errors the array will contain one or more entries with the following structure:": "函数`is`、`assert`和`validates`返回一个布尔值作为结果。为了获得验证规则失败的确切信息，可以使用`validate`函数。如果所有东西都被成功验证，它将返回一个空数组。如果出现错误，数组将包含一个或多个条目，结构如下：",
        "The function receives as first type argument any TypeScript type and as first argument the data to validate.": "该函数接收任何TypeScript类型作为第一个类型参数，并作为第一个参数接收要验证的数据。",
        "Complex types such as interfaces, classes, or generics can also be used.": "也可以使用复杂的类型，如接口、类或泛型。",
        "Constraints": "限制条件",
        "In addition to checking the types, other arbitrary constraints can be added to a type. The validation of these additional content constraints is done automatically after the types themselves have been validated. This is done in all validation functions like `validate`, `is`, and `assert`.": "除了检查类型之外，其他任意的约束可以被添加到一个类型中。这些额外内容约束的验证是在类型本身被验证后自动完成的。这在所有的验证函数中完成，如`validate`、`is`和`assert`。",
        "A restriction can be, for example, that a string must have a certain minimum or maximum length. These restrictions are added to the actual types via the type decorators. There is a whole variety of decorators that can be used. Own decorators can be defined and used at will in case of extended needs.": "一个限制可以是，例如，一个字符串必须有一定的最小或最大长度。这些限制是通过类型装饰器添加到实际类型中的。有一大堆可以使用的装饰器。自己的装饰器可以被定义，并在有扩展需求的情况下随意使用。",
        "With `&` any number of type decorators can be added to the actual type. The result, here `username`, can then be used in all validation functions but also in other types.": "通过`&`，任何数量的类型装饰器都可以被添加到实际类型中。结果，这里是`username'，然后可以在所有验证函数中使用，也可以在其他类型中使用。",
        "The function `validate` gives useful error messages coming from the constraints.": "函数`validate`给出了来自约束的有用的错误信息。",
        "This information can be represented for example wonderfully also at a form automatically and be translated by means of the `code`. Through the existing path for objects and arrays, fields in a form can filter out and display the appropriate error.": "这些信息可以在一个表单中自动表示出来，例如精彩的也可以通过`代码'的方式来翻译。通过对象和数组的现有路径，表单中的字段可以过滤出并显示适当的错误。",
        "An often useful use case is also to define an email with a RegExp constraint. Once the type is defined, it can be used anywhere.": "一个经常有用的用例也是用正则表达式约束来定义一个电子邮件。一旦定义了这个类型，它就可以在任何地方使用。",
        "Any number of constraints can be added.": "可以添加任何数量的约束。",
        "Constraint Types": "约束类型",
        "Validate&lt;typeof myValidator&gt;": "Validate&lt;typeof myValidator&gt；",
        "Validation using a custom validator function. See next section Custom Validator for more information.": "使用自定义验证器函数进行验证。更多信息见下一节自定义验证器。",
        "Pattern&lt;typeof myRegexp&gt;": "Pattern&lt;typeof myRegexp&gt；",
        "Defines a regular expression as validation pattern. Usually used for E-Mail validation or more complex content validation.": "定义了一个正则表达式作为验证模式。通常用于电子邮件验证或更复杂的内容验证。",
        "Alpha": "阿尔法",
        "Validation for alpha characters (a-Z).": "验证字母字符（a-Z）。",
        "Alphanumeric": "字母数字",
        "Validation for alpha and numeric characters.": "对字母和数字字符进行验证。",
        "Ascii": "阿斯奇",
        "Validation for ASCII characters.": "对ASCII字符进行验证。",
        "Decimal&lt;number, number&gt;": "十进制&lt;数字，数字&gt；",
        "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.": "对字符串表示十进制数字的验证，如0.1，.3，1.1，1.00003，4.0等。",
        "MultipleOf&lt;number&gt;": "MultipleOf&lt;number&gt；",
        "Validation of numbers that are a multiple of given number.": "验证是给定数字的倍数的数字。",
        "MinLength&lt;number&gt;, MaxLength&lt;number&gt;": "MinLength&lt;number&gt;, MaxLength&lt;number&gt；",
        "Validation for min/max length for arrays or strings.": "对数组或字符串的最小/最大长度进行验证。",
        "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;": "包括&lt;'任何&gt; 不包括&lt;'任何&gt；",
        "Validation for an array item or sub string being included/excluded": "对一个数组项或子字符串被包括/排除的验证",
        "Minimum&lt;number&gt;, Maximum&lt;number&gt;": "最小&lt;数&gt;，最大&lt;数&gt；",
        "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.": "验证一个值是最小或最大的给定数字。与`>=`和`&lt;=`相同。",
        "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;": "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt；",
        "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.": "与最小/最大值相同，但不包括值本身。与`>`和`<`相同。",
        "Positive, Negative, PositiveNoZero, NegativeNoZero": "正数、负数、正数不为零、负数不为零",
        "Validation for a value being positive or negative.": "验证一个值是正还是负。",
        "BeforeNow, AfterNow": "现在之前，现在之后",
        "Validation for a date value compared to now (new Date)..": "验证一个日期值与现在（新日期）的比较。",
        "Email": "电子邮件",
        "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.": "通过`/^\\S+@/S+$/`对电子邮件进行简单的重定式验证。是自动的`字符串`，所以不需要做`字符串&电子邮件`。",
        "integer": "整数",
        "Ensures that the number is a integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.": "确保数字是正确范围内的整数。自动是一个 \"数字\"，所以不需要做 \"数字和整数\"。",
        "See Special types: integer/floats for more information": "更多信息见特殊类型：整数/浮点数",
        "Custom validator": "自定义验证器",
        "If the built-in validators are not sufficient, custom validation functions can be created and used via the `Validate` decorator.": "如果内置的验证器不够用，可以通过`Validate`装饰器创建和使用自定义的验证函数。",
        "Note that your custom validation function is executed after all built-in type validators have been called. If a validator fails, all subsequent validators for the current type are skipped. Only one failure is possible per type.": "请注意，你的自定义验证函数是在所有内置类型验证器被调用后执行的。如果一个验证器失败了，当前类型的所有后续验证器将被跳过。每个类型只可能有一次失败。",
        "Generic Validator": "通用验证器",
        "In the Validator function the type object is available which can be used to get more information about the type using the validator. There is also a possibility to define an arbitrary validator option that must be passed to the validate type and makes the validator configurable. With this information and its parent references, powerful generic validators can be created.": "在验证器函数中，类型对象是可用的，它可以用来获得更多关于使用验证器的类型的信息。也有可能定义一个任意的验证器选项，必须传递给验证器类型，并使验证器可配置。有了这些信息和它的父引用，可以创建强大的通用验证器。",
        "Serialisation": "序列化",
        "Serialization is the process of converting data types into a format suitable for transport or storage, for example. Deserialization is the process of undoing this. This is done loss-lessly, meaning that data can be converted to and from a serialization target without losing data type information or the data itself.": "序列化是将数据类型转换为适合传输或存储的格式的过程，例如。反序列化是撤销这一过程的过程。这是一个无损的过程，意味着数据可以在不丢失数据类型信息或数据本身的情况下转换到序列化目标中去。",
        "In JavaScript, serialization is usually between JavaScript objects and JSON. JSON supports only String, Number, Boolean, Objects, and Arrays. JavaScript, on the other hand, supports many other types such as BigInt, ArrayBuffer, typed arrays, Date, custom class instances, and many more. Now, to transmit JavaScript data to a server using JSON, you need a serialization process (on the client) and a deserialization process (on the server), or vice versa if the server sends data to the client as JSON. Using `JSON.parse` and `JSON.stringify` is often not sufficient for this, as it is not lossless.": "在JavaScript中，序列化通常是在JavaScript对象和JSON之间进行。JSON只支持字符串、数字、布尔值、对象和数组。另一方面，JavaScript支持许多其他类型，如BigInt、ArrayBuffer、类型化数组、Date、自定义类实例等等。现在，要使用JSON向服务器传输JavaScript数据，你需要一个序列化过程（在客户端）和一个反序列化过程（在服务器上），反之亦然，如果服务器将数据作为JSON发送到客户端。使用`JSON.parse`和`JSON.stringify`往往不能满足这个要求，因为它不是无损的。",
        "This serialization process is absolutely necessary for non-trivial data, since JSON loses its information even for basic types like a date. A new Date is finally serialized as a string in JSON:": "这个序列化过程对于非简单的数据来说是绝对必要的，因为JSON甚至对于像日期这样的基本类型都会丢失其信息。一个新的Date最终被序列化为JSON中的一个字符串：",
        "As you can see, the result of JSON.stringify is a JSON string. If you deserialize it again with JSON.parse, you will not get a date object, but a string.": "你可以看到，JSON.stringify的结果是一个JSON字符串。如果你再次用JSON.parse对其进行反序列化，你将不会得到一个日期对象，而是一个字符串。",
        "Although there are various workarounds to teach JSON.parse to deserialize Date objects, they are error-prone and poorly performing. To enable type-safe serialization and deserialization for this case and many other types, a serialization process is necessary.": "虽然有各种变通方法来教JSON.parse反序列化Date对象，但它们容易出错而且性能很差。为了使这种情况和许多其他类型的序列化和反序列化的类型安全，需要一个序列化过程。",
        "There are four main functions available: `serialize`, `cast`, `deserialize` and `validatedDeserialize`. Under the hood of these functions, the globally available JSON serializer from `@deepkit/type` is used by default, but a custom serialization target can also be used.": "有四个主要函数可用：`serialize`, `cast`, `deserialize` 和 `validatedDeserialize`。在这些函数的内部，默认使用来自`@deepkit/type`的全局可用的JSON序列化器，但也可以使用自定义的序列化目标。",
        "Deepkit Type supports user-defined serialization targets, but already comes with a powerful JSON serialization target that serializes data as JSON objects and then can be correctly and safely converted as JSON using JSON.stringify. With `@deepkit/bson`, BSON can also be used as a serialization target. How to create a custom serialization target (for example for a database driver) can be learned in the Custom Serializer section.": "Deepkit Type 支持用户定义的序列化目标，但已经配备了一个强大的 JSON 序列化目标，该目标将数据序列化为 JSON 对象，然后可以使用 JSON.stringify 正确、安全地转换为 JSON。通过`@deepkit/bson`，BSON也可以作为一个序列化目标使用。如何创建一个自定义的序列化目标（例如为数据库驱动程序），可以在自定义序列化器部分了解。",
        "Note that although serializers also validate data for compatibility, these validations are different from the validation in xref:validation.adoc[Validation]. Only the `cast` function also calls the full validation process from the xref:validation.adoc[Validation] chapter after successful deserialization, and throws an error if the data is not valid.": "请注意，尽管序列化器也验证数据的兼容性，但这些验证与xref:validation.adoc[验证]中的验证是不同的。只有`cast`函数在成功反序列化后还会调用xref:validation.adoc[Validation]章节中的完整验证过程，如果数据无效，则抛出一个错误。",
        "Alternatively, `validatedDeserialize` can be used to validate after deserialization. Another alternative is to manually call the `validate` or `validates` functions on deserialized data from the `deserialize` function, see xref:validation.adoc[Validation].": "另外，`validatedDeserialize`可以用来在反序列化后进行验证。另一个选择是手动调用`validate`或`validates`函数对`deserialize`函数中的反序列化数据进行验证，见xref:validation.adoc[Validation]。",
        "All functions from serialization and validation throw a `ValidationError` from `@deepkit/type` on errors.": "所有来自序列化和验证的函数在出错时都会从`@deepkit/type`抛出一个`ValidationError`。",
        "Cast": "铸件",
        "Todo": "嘟嘟",
        "Serialisierung": "串行化",
        "The function `serialize` converts the passed data by default with the JSON serializer into a JSON object, that is: String, Number, Boolean, Object, or Array. The result of this can then be safely converted to a JSON using `JSON.stringify`.": "函数`serialize`默认使用JSON序列化器将传递的数据转换为JSON对象，也就是：String, Number, Boolean, Object, or Array.然后可以使用`JSON.stringify`将其结果安全地转换为JSON。",
        "Deserialisierung": "解读",
        "The function `deserialize` converts the passed data per default with the JSON serializer into the corresponding specified types. The JSON serializer expects a JSON object, i.e.: string, number, boolean, object, or array. This is usually obtained from a `JSON.parse` call.": "函数`deserialize`将传递的数据默认用JSON序列化器转换为相应的指定类型。JSON序列化器希望得到一个JSON对象，即：字符串、数字、布尔值、对象或数组。这通常是通过`JSON.parse`调用获得的。",
        "If the correct data type is already passed (for example, a Date object in the case of `created`), then this is taken as it is.": "如果已经传递了正确的数据类型（例如，在`created'的情况下，是一个Date对象），那么这将被视为是正确的。",
        "Not only a class, but any TypeScript type can be specified as the first type argument. So even primitives or very complex types can be passed:": "不仅是一个类，而且任何TypeScript类型都可以被指定为第一个类型参数。所以即使是基元或非常复杂的类型也可以被传递：",
        "Soft Type Conversion": "软类型转换",
        "In the deserialization process a soft type conversion is implemented. This means that String and Number for String types or a Number for a String type can be accepted and converted automatically. This is useful, for example, when data is accepted via a URL and passed to the deserializer. Since the URL is always a string, Deepkit Type still tries to resolve the types for Number and Boolean.": "在反序列化过程中，实现了软类型转换。这意味着String和Number的字符串类型或Number的字符串类型可以被接受并自动转换。例如，当通过URL接受数据并传递给反序列化器时，这很有用。由于URL总是一个字符串，Deepkit Type仍然试图解决Number和Boolean的类型。",
        "The following soft type conversions are built into the JSON serializer:": "以下是JSON序列化器中内置的软类型转换：",
        "*number|bigint*: Number or Bigint accept String, Number, and BigInt. `parseFloat` or `BigInt(x)` are used in case of a necessary conversion.": "*number|bigint*：Number或Bigint接受String、Number和BigInt。`parseFloat`或`BigInt(x)`在需要转换的情况下使用。",
        "*boolean*: Boolean accepts Number and String. 0, '0', 'false' is interpreted as `false`. 1, '1', 'true' is interpreted as `true`.": "*boolean*：布尔型接受数字和字符串。0, '0', 'false'被解释为`false'。1, '1', 'true' 被解释为`true'。",
        "*string*: String accepts Number, String, Boolean, and many more. All non-string values are automatically converted with `String(x)`.": "*string*：字符串接受Number（数字）、String（字符串）、Boolean（布尔）和其他更多。所有非字符串的值都可以用`String(x)`自动转换。",
        "The soft conversion can also be deactivated:": "软转换也可以停用：",
        "In the case of invalid data, no attempt is made to convert it and instead an error message is thrown.": "在无效数据的情况下，不会尝试进行转换，而是抛出一个错误信息。",
        "Type-Decorators": "类型-分解器",
        "Integer": "整数",
        "Mapped": "绘图",
        "Naming Strategy": "命名策略",
        "Benutzerdefinierter Serializer": "串行器的定义",
        "By default, `@deepkit/type` comes with a JSON serializer and type validation for TypeScript types. You can extend this and add or remove the serialization functionality or change the way validation is done, as validation is also linked to the serializer.": "默认情况下，`@deepkit/type`带有一个JSON序列化器和TypeScript类型的类型验证。您可以对此进行扩展，添加或删除序列化功能，或改变验证方式，因为验证也与序列化器相关。",
        "New Serializer": "新的串行器",
        "A serializer is simply an instance of the `Serializer` class with registered serializer templates. Serializer templates are small functions that create JavaScript code for the JIT serializer process. For each type (String, Number, Boolean, etc.) there is a separate Serializer template that is responsible for returning code for data conversion or validation. This code must be compatible with the JavaScript engine that the user is using.": "一个序列化器只是一个带有注册序列化器模板的`Serializer`类的实例。序列器模板是为JIT序列器过程创建JavaScript代码的小函数。对于每种类型（字符串、数字、布尔值等）都有一个单独的序列器模板，负责返回数据转换或验证的代码。这个代码必须与用户使用的JavaScript引擎兼容。",
        "Only during the execution of the compiler template function do you (or should you) have full access to the full type. The idea is that you should embed all the information needed to convert a type directly into the JavaScript code, resulting in highly optimized code (also called JIT-optimized code).": "只有在编译器模板函数的执行过程中，你（或你应该）才能完全访问完整的类型。我们的想法是，你应该把转换类型所需的所有信息直接嵌入到JavaScript代码中，从而产生高度优化的代码（也称为JIT优化的代码）。",
        "The following example creates an empty serializer.": "下面的例子创建了一个空的序列化器。",
        "As you can see, nothing has been converted (`created` is still a number, but we have defined it as `date`). To change this, we add a serializer template for deserialization of type Date.": "正如你所看到的，没有任何东西被转换（`created`仍然是一个数字，但是我们把它定义为`date`）。为了改变这种情况，我们为Date类型的反序列化添加一个序列化器模板。",
        "Now our serializer converts the value into a Date object.": "现在我们的序列化器将该值转换为一个Date对象。",
        "To do the same for serialization, we register another serialization template.": "为了对序列化做同样的事情，我们注册另一个序列化模板。",
        "Our new serializer now correctly converts the date from the Date object to a string in the serialization process.": "我们新的序列化器现在可以在序列化过程中正确地将日期从Date对象转换为字符串。",
        "Examples": "实例",
        "To see many more examples, you can take a look at the code of the link:https://github.com/deepkit/deepkit-framework/blob/master/packages/type/src/serializer.ts#L1688[JSON-Serializers] included in Deepkit Type.": "要想看到更多的例子，你可以看看Deepkit Type中包含的链接：https://github.com/deepkit/deepkit-framework/blob/master/packages/type/src/serializer.ts#L1688[JSON-序列化器]的代码。",
        "Expanding A Serializer": "扩展一个串行器",
        "If you want to extend an existing serializer, you can do so using class inheritance. This works because serializers should be written to register their templates in the constructor.": "如果你想扩展一个现有的序列化器，你可以使用类的继承来实现。这样做是因为序列化器应该被写成在构造函数中注册他们的模板。",
        "Dependency Injection": "依赖性注入",
        "Dependency Injection (DI) is a design pattern in which classes and functions _receive_ their dependencies. It follows the principle of Inversion of Control (IoC) and helps to better separate complex code in order to significantly improve testability, modularity and clarity. Although there are other design patterns, such as the service locator pattern, for applying the principle of IoC, DI has established itself as the dominant pattern, especially in enterprise software.": "依赖性注入（DI）是一种设计模式，其中类和函数_接收_它们的依赖关系。它遵循反转控制（IoC）的原则，有助于更好地分离复杂的代码，以显著提高可测试性、模块化和清晰性。尽管还有其他的设计模式，如服务定位器模式，用于应用IoC的原则，但DI已经确立了自己的主导模式，特别是在企业软件中。",
        "To illustrate the principle of IoC, here is an example:": "为了说明IoC的原理，这里有一个例子：",
        "The UserRepository class has an HttpClient as a dependency. This dependency in itself is nothing remarkable, but it is problematic that `UserRepository` creates the HttpClient itself.": "UserRepository类有一个HttpClient作为依赖关系。这个依赖关系本身并没有什么了不起的，但是`UserRepository`自己创建了HttpClient，这就有问题了。",
        "It seems to be a good idea to encapsulate the creation of the HttpClient in the UserRepository, but this is not the case. What if we want to replace the HttpClient? What if we want to test UserRepository in a unit test without allowing real HTTP requests to go out? How do we know that the class even uses an HttpClient?": "将HttpClient的创建封装在UserRepository中似乎是个好主意，但事实并非如此。如果我们想替换HttpClient呢？如果我们想在单元测试中测试UserRepository而不允许真正的HTTP请求出去呢？我们怎么知道这个类甚至使用了HttpClient？",
        "Inversion of Control": "反转控制",
        "In the thought of Inversion of Control (IoC) is the following alternative variant that sets the HttpClient as an explicit dependency in the constructor (also known as constructor injection).": "在反转控制（IoC）的思想中，以下是另一种变体，它将HttpClient设置为构造函数中的显式依赖（也被称为构造函数注入）。",
        "Now UserRepository is no longer responsible for creating the HttpClient, but the user of UserRepository. This is Inversion of Control (IoC). The control has been reversed or inverted. Specifically, this code applies dependency injection, because dependencies are received (injected) and no longer created or requested. Dependency Injection is only one variant of IoC.": "现在 UserRepository 不再负责创建 HttpClient，而是 UserRepository 的用户。这就是控制的反转（IoC）。控制权已经被逆转或颠倒了。具体来说，这段代码应用了依赖注入，因为依赖被接收（注入），而不再被创建或请求。依赖注入只是IoC的一个变体。",
        "Service Locator": "服务定位器",
        "Besides DI, Service Locator (SL) is also a way to apply the IoC principle. This is commonly considered the counterpart to Dependency Injection, as it requests dependencies rather than receiving them. If HttpClient were requested in the above code as follows, it would be called a Service Locator pattern.": "除了DI，Service Locator（SL）也是应用IoC原则的一种方式。这通常被认为是与依赖注入相对应的，因为它请求依赖而不是接受依赖。如果在上面的代码中按如下方式请求HttpClient，它将被称为服务定位器模式。",
        "The function `locator.getHttpClient` can have any name. Alternatives would be function calls like `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` or a container call like `container.get(HttpClient)`. An import of a global is a slightly different variant of a service locator, using the module system itself as the locator:": "函数`locator.getHttpClient`可以有任何名字。替代品是函数调用，如`useContext(HttpClient)`、`getHttpClient()`、`await import(\"client\")`，或容器调用，如`container.get(HttpClient)`。全局的导入是服务定位器的一个稍微不同的变体，使用模块系统本身作为定位器：",
        "All these variants have in common that they explicitly request the HttpClient dependency. This request can happen not only to properties as a default value, but also somewhere in the middle of the code. Since in the middle of the code means that it is not part of a type interface, the use of the HttpClient is hidden. Depending on the variant of how the HttpClient is requested, it can sometimes be very difficult or completely impossible to replace it with another implementation. Especially in the area of unit tests and for the sake of clarity, difficulties can arise here, so that the service locator is now classified as an anti-pattern in certain situations.": "所有这些变体的共同点是它们明确地请求HttpClient的依赖性。这种请求不仅可以发生在作为默认值的属性上，也可以发生在代码中间的某个地方。因为在代码的中间意味着它不是类型接口的一部分，所以HttpClient的使用是隐藏的。根据如何请求HttpClient的变体，有时会非常困难或完全不可能用另一种实现来替代它。特别是在单元测试领域，为了清晰起见，这里会出现困难，所以现在服务定位器在某些情况下被归为反模式。",
        "With Dependency Injection, nothing is requested, but it is explicitly provided by the user or received by the code. As can be seen in the example of Inversion of Control, the dependency injection pattern has already been applied there. Specifically, constructor injection can be seen there, since the dependency is declared in the constructor. So UserRepository must now be used as follows.": "在依赖注入中，没有什么要求，但它是由用户明确提供或由代码接收的。从控制反转的例子中可以看出，依赖注入模式已经在那里被应用。具体来说，在那里可以看到构造函数注入，因为依赖性是在构造函数中声明的。所以UserRepository现在必须按如下方式使用。",
        "The code that wants to use UserRepository must also provide (inject) all its dependencies. Whether HttpClient should be created each time or the same one should be used each time is now decided by the user of the class and no longer by the class itself. It is no longer requested (from the class's point of view) as in the case of the service locator, or created entirely by itself in the initial example. This inversion of the flow has various advantages:": "想要使用UserRepository的代码也必须提供（注入）它的所有依赖关系。HttpClient是否应该每次都被创建或者每次都使用同一个，现在由类的用户决定，而不再由类本身决定。它不再像服务定位器那样被请求（从类的角度），也不再像最初的例子那样完全由自己创建。这种流程的反转有各种好处：",
        "The code is easier to understand because all dependencies are explicitly visible.": "代码更容易理解，因为所有的依赖关系都是明确可见的。",
        "The code is easier to test because all dependencies are unique and can be easily modified if needed.": "代码更容易测试，因为所有的依赖关系都是唯一的，如果需要，可以很容易地修改。",
        "The code is more modular, as dependencies can be easily exchanged.": "代码更加模块化，因为依赖关系可以轻松交换。",
        "It promotes the Separation of Concern principle, as UserRepository is no longer responsible for creating very complex dependencies itself when in doubt.": "它促进了关注点分离原则，因为UserRepository不再负责在有疑问时自己创建非常复杂的依赖关系。",
        "But an obvious disadvantage can also be recognized directly: Do I really need to create or manage all dependencies like the HttpClient myself? Yes and No. Yes, there are many cases where it is perfectly legitimate to manage the dependencies yourself. The hallmark of a good API is that dependencies don't get out of hand, and that even then they are pleasant to use. For many applications or complex libraries, this may well be the case. To provide a very complex low-level API with many dependencies in a simplified way to the user, facades are wonderfully suitable.": "但也可以直接认识到一个明显的缺点：我真的需要自己创建或管理像HttpClient这样的所有依赖关系吗？是的，也不是。是的，有很多情况下，自己管理依赖关系是完全合法的。一个好的API的标志是，依赖关系不会失控，而且即使这样，它们也是令人愉快的。对于许多应用程序或复杂的库来说，情况很可能是这样的。为了以简化的方式向用户提供一个非常复杂的有许多依赖关系的低级API，facades是非常合适的。",
        "Dependency Injection Container": "依赖性注入容器",
        "For more complex applications, however, it is not necessary to manage all dependencies yourself, because that is exactly what a so-called dependency injection container is for. This not only creates all objects automatically, but also \"injects\" the dependencies automatically, so that a manual \"new\" call is no longer necessary. There are various types of injection, such as constructor injection, method injection, or property injection. This makes it easy to manage even complicated constructions with many dependencies.": "然而，对于更复杂的应用程序，没有必要自己管理所有的依赖关系，因为这正是所谓的依赖注入容器的作用。这不仅可以自动创建所有对象，还可以自动 \"注入 \"依赖关系，这样就不再需要手动调用 \"新建 \"了。有各种类型的注入，如构造函数注入、方法注入或属性注入。这使得即使是有许多依赖关系的复杂结构也能轻松管理。",
        "A dependency injection container (also called DI container or IoC container) brings Deepkit in `@deepkit/injector` or already ready integrated via App modules in the Deepkit Framework. The above code would look like this using a low-level API from the `@deepkit/injector` package.": "依赖性注入容器（也称为DI容器或IoC容器）在`@deepkit/injector`中带来了Deepkit，或者已经准备好通过Deepkit框架中的App模块进行集成。使用`@deepkit/injector`包中的低级API，上述代码会是这样的。",
        "The `injector` object in this case is the dependency injection container. Instead of using \"new UserRepository\", the container returns an instance of UserRepository using `get(UserRepository)`. To statically initialize the container, a list of providers is passed to the `InjectorContext.forProviders` function (in this case, simply the classes).": "在这种情况下，`injector`对象是依赖性注入容器。容器没有使用 \"new UserRepository\"，而是使用`get(UserRepository)`返回UserRepository的一个实例。为了静态地初始化容器，一个提供者的列表被传递给`InjectorContext.forProviders`函数（在这种情况下，仅仅是类）。",
        "Since DI is all about providing dependencies, the container is provided with the dependencies, hence the technical term \"provider\". There are several types of providers: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. All together, they allow very flexible architectures to be mapped with a DI container.": "由于DI是关于提供依赖关系的，容器被提供了依赖关系，因此技术术语为 \"提供者\"。有几种类型的提供者：ClassProvider、ValueProvider、ExistingProvider、FactoryProvider。所有这些，它们允许非常灵活的架构与DI容器进行映射。",
        "All dependencies between providers are automatically resolved and as soon as an `injector.get()` call occurs, the objects and dependencies are created, cached, and correctly passed either as a constructor argument (which is known as constructor injection), set as a property (which is known as property injection), or passed to a method call (which is known as method injection).": "提供者之间的所有依赖关系都会被自动解决，一旦发生`injector.get()`调用，对象和依赖关系就会被创建、缓存，并正确地作为构造函数参数传递（这被称为构造函数注入）、设置为属性（这被称为属性注入）或传递给方法调用（这被称为方法注入）。",
        "Now to exchange the HttpClient with another one, another provider (here the ValueProvider) can be defined for HttpClient:": "现在，为了将HttpClient与另一个HttpClient交换，可以为HttpClient定义另一个提供者（这里是ValueProvider）：",
        "As soon as UserRepository is requested via `injector.get(UserRepository)`, it receives the AnotherHttpClient object. Alternatively, a ClassProvider can be used here very well, so that all dependencies of AnotherHttpClient are also managed by the DI container.": "一旦UserRepository通过`injector.get(UserRepository)`被请求，它就会收到AnotherHttpClient对象。另外，一个ClassProvider也可以用在这里，这样AnotherHttpClient的所有依赖关系也会被DI容器所管理。",
        "All types of providers are listed and explained in the xref:dependency-injection.adoc#di-providers[Dependency Injection Providers] section.": "所有类型的提供者都在xref:dependency-injection.adoc#di-providers[依赖注入提供者]部分列出并解释。",
        "It should be mentioned here that Deepkit's DI container only works with Deepkit's runtime types. This means that any code that contains classes, types, interfaces, and functions must be compiled by the Deepkit Type Compiler in order to have the type information available at runtime. See the chapter xref:runtime-types.adoc[Runtime Types].": "这里应该提到，Deepkit的DI容器只适用于Deepkit的运行时类型。这意味着任何包含类、类型、接口和函数的代码都必须经过Deepkit类型编译器的编译，才能在运行时获得类型信息。参见xref:runtime-types.adoc[运行时类型]一章。",
        "Dependency Inversion": "依赖性反转",
        "The example of UserRepository under Inversion of Control shows that UserRepository depends on a lower level HTTP library. In addition, a concrete implementation (class) is declared as a dependency instead of an abstraction (interface). At first glance, this may seem to be in line with the object-oriented paradigms, but it can lead to problems, especially in complex and large architectures.": "反转控制下的 UserRepository 的例子显示 UserRepository 依赖于一个较低级别的 HTTP 库。此外，一个具体的实现（类）被声明为依赖关系，而不是一个抽象（接口）。乍一看，这似乎符合面向对象的范式，但它会导致问题，特别是在复杂和大型的架构中。",
        "An alternative variant would be to convert the HttpClient dependency into an abstraction (interface) and thus not import code from an HTTP library into UserRepository.": "另一种变体是将HttpClient依赖关系转换为一个抽象（接口），从而不将HTTP库的代码导入UserRepository。",
        "This is called the dependency inversion principle. UserRepository no longer has a dependency directly on an HTTP library and is instead based on an abstraction (interface). It thus solves two fundamental goals in this principle:": "这就是所谓的依赖性倒置原则。UserRepository不再直接依赖一个HTTP库，而是基于一个抽象（接口）。因此它解决了这个原则中的两个基本目标：",
        "High-level modules should not import anything from low-level modules.": "高级别的模块不应该从低级别的模块中导入任何东西。",
        "Implementations should be based on abstractions (interfaces).": "实现应该基于抽象（接口）。",
        "Merging the two implementations (UserRepository with an HTTP library) can now be done via the DI container.": "合并两种实现（UserRepository与HTTP库）现在可以通过DI容器完成。",
        "Since Deepkit's DI container is capable of resolving abstract dependencies (interfaces) such as this one of HttpClientInterface, UserRepository automatically gets the implementation of HttpClient since HttpClient implemented the interface HttpClientInterface. This is done either by HttpClient specifically implementing HttpClientInterface (`class HttpClient implements HttpClientInterface`), or by HttpClient's API simply being compatible with HttpClientInterface.": "由于Deepkit的DI容器能够解决抽象的依赖关系（接口），例如HttpClientInterface的这种依赖关系，UserRepository自动获得HttpClient的实现，因为HttpClient实现了接口HttpClientInterface。这可以通过HttpClient专门实现HttpClientInterface（`class HttpClient implements HttpClientInterface`），或者通过HttpClient的API仅仅与HttpClientInterface兼容来实现。",
        "As soon as HttpClient modifies its API (for example, removes the `get` method) and is thus no longer compatible with HttpClientInterface, the DI container throws an error (\"the HttpClientInterface dependency was not provided\").": "一旦HttpClient修改了它的API（例如，删除了`get`方法），从而不再与HttpClientInterface兼容，DI容器就会抛出一个错误（\"没有提供HttpClientInterface的依赖性\"）。",
        "Here the user, who wants to bring both implementations together, is in the obligation to find a solution. As an example, an adapter class could be registered here that implements HttpClientInterface and correctly forwards the method calls to HttpClient.": "在这里，想要将两种实现结合起来的用户有义务找到一个解决方案。作为一个例子，可以在这里注册一个适配器类，它实现了HttpClientInterface并正确地将方法调用转发给HttpClient。",
        "It should be noted here that although in theory the dependency inversion principle has its advantages, in practice it also has significant disadvantages. It not only leads to more code (since more interfaces have to be written), but also to more complexity (since each implementation now has an interface for each dependency). This price to pay is only worth it when the application reaches a certain size and this flexibility is needed. Like any design pattern and principle, this one has its cost-use factor, which should be thought through before it is applied.": "这里需要指出的是，虽然理论上依赖关系反转原则有其优点，但实际上它也有很大的缺点。它不仅导致了更多的代码（因为必须编写更多的接口），而且也导致了更多的复杂性（因为现在每个实现都有一个接口用于每个依赖关系）。只有当应用程序达到一定规模，需要这种灵活性时，这种代价才是值得的。像任何设计模式和原则一样，这个模式也有它的成本-使用因素，在应用之前应该考虑清楚。",
        "Design patterns should not be used blindly and across the board for even the simplest code. However, if the prerequisites such as a complex architecture, large applications, or a scaling team are given, dependency inversion and other design patterns only unfold their true strength.": "即使是最简单的代码，也不应该盲目地、一刀切地使用设计模式。然而，如果有复杂的架构、大型的应用程序或扩展团队等先决条件，依赖反转和其他设计模式才会展现出其真正的力量。",
        "If this is done successfully, `@deepkit/injector` can be installed by itself or the Deepkit framework which already uses the library under the hood.": "如果这一点做得很成功，`@deepkit/injector'就可以自行安装，或者安装已经在引擎盖下使用该库的Deepkit框架。",
        "Once the library is installed, the API of it can be used directly.": "一旦库被安装，它的API就可以直接使用。",
        "To use Dependency Injection now, there are three ways.": "现在要使用依赖性注入，有三种方法。",
        "Injector API (Low Level)": "注射器API（低水平）。",
        "Module API": "模块API",
        "App API (Deepkit Framework)": "应用程序API（Deepkit框架）。",
        "If `@deepkit/injector` is to be used without the deepkit framework, the first two variants are recommended.": "如果`@deepkit/injector`要在没有deepkit框架的情况下使用，推荐使用前两种变体。",
        "Injector API": "注射器API",
        "The Injector API has already been introduced in the introduction to Dependency Injection. It is characterized by a very simple usage by means of a single class `InjectorContext` that creates a single DI container and is particularly suitable for simpler applications without modules.": "在依赖注入的介绍中已经介绍了Injector API。它的特点是通过一个单一的类`InjectorContext`来创建一个单一的DI容器，用法非常简单，特别适用于没有模块的简单应用程序。",
        "The `injector` object in this case is the dependency injection container. The function `InjectorContext.forProviders` takes an array of providers. See the section xref:dependency-injection.adoc#di-providers[Dependency Injection Providers] to learn which values can be passed.": "在这种情况下，`injector`对象是依赖性注入容器。函数`InjectorContext.forProviders`接收一个提供者的数组。参见xref:dependency-injection.adoc#di-providers[依赖注入提供者]一节，了解哪些值可以被传递。",
        "A more complex API is the `InjectorModule` class, which allows to store the providers in different modules to create multiple encapsulated DI containers per module. Also this allows using configuration classes per module, which makes it easier to provide configuration values automatically validated to the providers. Modules can import themselves among themselves, providers export, in order to build up so a hierarchy and nicely separated architecture.": "一个更复杂的API是 \"InjectorModule \"类，它允许在不同的模块中存储提供者，以便在每个模块中创建多个封装的DI容器。同时，这也允许每个模块使用配置类，这使得提供配置值自动验证给提供者更容易。模块之间可以互相导入，提供者可以导出，以便建立一个层次结构和良好的分离架构。",
        "This API should be used if the application is more complex and the Deepkit framework is not used.": "如果应用程序比较复杂，并且没有使用Deepkit框架，就应该使用这个API。",
        "The `injector` object in this case is the dependency injection container. Providers can be split into different modules and then imported again in different places using module imports. This creates a natural hierarchy that reflects the hierarchy of the application or architecture.": "在这种情况下，`injector`对象是依赖性注入容器。提供者可以被分割成不同的模块，然后使用模块导入在不同的地方再次导入。这创造了一个自然的层次结构，反映了应用程序或架构的层次结构。",
        "The InjectorContext should always be given the top module in the hierarchy, also called root module or app module. The InjectorContext then only has an intermediary role: calls to `injector.get()` are simply forwarded to the root module. However, it is also possible to get providers from non-root modules by passing the module as a second argument.": "InjectorContext应该总是被赋予层次结构中的顶级模块，也称为根模块或应用模块。然后，InjectorContext只有一个中间角色：对`injector.get()`的调用被简单地转发给根模块。然而，通过将模块作为第二个参数传递，也可以从非根模块获得提供者。",
        "All non-root modules are encapsulated by default, so that all providers in this module are only available to itself. If a provider is to be available to other modules, this provider must be exported. By exporting, the provider moves to the parent module of the hierarchy and can be used that way.": "所有的非根模块都是默认封装的，因此这个模块中的所有提供者只对自己可用。如果一个提供者要对其他模块可用，这个提供者必须被导出。通过导出，提供者就会转移到层次结构的父模块中，并可以这样使用。",
        "To export all providers by default to the top level, the root module, the option `forRoot` can be used. This allows all providers to be used by all other modules.": "为了默认将所有提供者输出到顶层，即根模块，可以使用选项`forRoot`。这允许所有提供者被所有其他模块使用。",
        "App API": "应用程序API",
        "Once the Deepkit framework is used, modules are defined with the `@deepkit/app` API. This is based on the Module API, so the capabilities from there are also available. In addition, it is possible to work with powerful hooks and define configuration loaders to map even more dynamic architectures.": "一旦使用了Deepkit框架，就可以用`@deepkit/app` API来定义模块。这是以模块API为基础的，所以那里的功能也是可用的。此外，还可以使用强大的钩子，定义配置加载器，以映射更多的动态架构。",
        "Providers": "提供者",
        "There are several ways to provide dependencies in the Dependency Injection container. The simplest variant is simply the specification of a class. This is also known as short ClassProvider.": "有几种方法可以在依赖注入容器中提供依赖关系。最简单的变体是简单地指定一个类。这也被称为简短的ClassProvider。",
        "This represents a special provider, since only the class is specified. All other providers must be specified as object literals.": "这代表了一个特殊的提供者，因为只有类被指定。所有其他提供者必须被指定为对象字面。",
        "By default, all providers are marked as singletons, so only one instance exists at any given time. To create a new instance each time a provider is deployed, the `transient` option can be used. This will cause classes to be recreated each time or factories to be executed each time.": "默认情况下，所有提供者都被标记为单子，所以在任何时候都只有一个实例存在。要在每次部署提供者时创建一个新的实例，可以使用`transient`选项。这将导致每次都要重新创建类或每次都要执行工厂。",
        "ClassProvider": "类提供者",
        "Besides the short ClassProvider there is also the regular ClassProvider, which is an object literal instead of a class.": "除了简短的ClassProvider，还有普通的ClassProvider，它是一个对象字面，而不是一个类。",
        "This is equivalent to these two:": "这相当于这两个：",
        "It can be used to exchange a provider with another class.": "它可以用来与另一个类交换一个提供者。",
        "In this example, the `OtherUserRepository` class is now also managed in the DI container and all its dependencies are resolved automatically.": "在这个例子中，`OtherUserRepository`类现在也在DI容器中被管理，它的所有依赖关系都被自动解决。",
        "ValueProvider": "价值提供者",
        "Static values can be provided with this provider.": "静态值可以用这个提供者提供。",
        "Since not only class instances can be provided as dependencies, any value can be specified as `useValue`. A symbol or a primitive (string, number, boolean) could also be used as a provider token.": "因为不仅仅是类的实例可以作为依赖关系提供，任何值都可以被指定为`useValue'。一个符号或一个基元（字符串、数字、布尔值）也可以被用作提供者标记。",
        "Primitive provider tokens must be declared with the Inject type as a dependency.": "原始提供者令牌必须以Inject类型作为依赖关系来声明。",
        "The combination of an inject alias and primitive provider tokens can also be used to provide dependencies from packages that do not contain runtime type information.": "inject别名和原始提供者令牌的组合也可以用来提供不包含运行时类型信息的软件包的依赖关系。",
        "And then declared on the user side as follows:": "然后在用户端声明如下：",
        "ExistingProvider": "现有供应商",
        "A forwarding to an already defined provider can be defined.": "可以定义转发到一个已经定义的提供者。",
        "FactoryProvider": "工厂提供者（FactoryProvider",
        "A function can be used to provide a value for the provider. This function can also contain parameters, which in turn are provided by the DI container. Thus, other dependencies or configuration options are accessible.": "一个函数可以用来为提供者提供一个值。这个函数也可以包含参数，而这些参数又是由DI容器提供的。因此，其他的依赖性或配置选项可以被访问。",
        "InterfaceProvider": "接口提供者（InterfaceProvider",
        "In addition to classes and primitives, abstractions (interfaces) can also be provided. This is done via the function `provide` and is particularly useful if the value to be provided does not contain any type information.": "除了类和基元之外，还可以提供抽象（接口）。这是通过函数`provide`完成的，如果要提供的值不包含任何类型信息，则特别有用。",
        "If multiple providers have implemented the Connection interface, the last provider is used.": "如果多个提供者都实现了连接接口，则使用最后一个提供者。",
        "As argument for provide() all other providers are possible.": "作为provider()的参数，所有其他提供者都是可能的。",
        "Asynchronous Providers": "异步提供者",
        "The design of `@deepkit/injector` precludes the use of asynchronous providers with an asynchronous Dependency Injection container. This is because requesting providers would also need to be asynchronous, necessitating the entire application to operate at the highest level asynchronously.": "`@deepkit/injector`的设计排除了使用异步依赖注入容器的异步提供者。这是因为请求提供者也需要是异步的，这使得整个应用程序必须在最高级别上异步运行。",
        "To initialize something asynchronously, this initialization should be moved to the application server bootstrap,  because there the events can be asynchronous. Alternatively, an initialization can be triggered manually.": "要异步初始化一些东西，这个初始化应该被移到应用服务器引导层，因为那里的事件可以是异步的。另外，也可以手动触发初始化。",
        "Constructor/Property Injection": "构造函数/属性注入",
        "In most cases, constructor injection is used. All dependencies are specified as constructor arguments and are automatically injected by the DI container.": "在大多数情况下，构造函数注入被使用。所有的依赖被指定为构造函数参数，并由DI容器自动注入。",
        "Optional dependencies should be marked as such, otherwise an error could be triggered if no provider can be found.": "可选的依赖应被标记为可选，否则如果找不到提供者，可能会引发错误。",
        "An alternative to constructor injection is property injection. This is usually used when the dependency is optional or the constructor is otherwise too full. The properties are automatically assigned once the instance is created (and thus the constructor is executed).": "构造函数注入的一个替代方法是属性注入。这通常是在依赖关系是可选的或者构造函数太满的情况下使用。一旦实例被创建（也就是构造函数被执行），这些属性就会被自动分配。",
        "Configuration": "配置",
        "The dependency injection container also allows configuration options to be injected. This configuration injection can be received via constructor injection or property injection.": "依赖性注入容器也允许配置选项被注入。这种配置注入可以通过构造函数注入或属性注入接收。",
        "The Module API supports the definition of a configuration definition, which is a regular class. By providing such a class with properties, each property acts as a configuration option. Because of the way classes can be defined in TypeScript, this allows defining a type and default values per property.": "模块API支持配置定义，它是一个普通的类。通过提供这样一个带有属性的类，每个属性作为一个配置选项。由于类可以在TypeScript中定义的方式，这允许定义一个类型和每个属性的默认值。",
        "The configuration options `domain` and `debug` can now be used quite conveniently type-safe in providers.": "配置选项`domain`和`debug`现在可以很方便地在供应商中使用类型安全的配置。",
        "The values of the options themselves can be set via `configure()`.": "选项本身的值可以通过`configure()`来设置。",
        "Options that do not have a default value but are still necessary can be provided with a `!`. This forces the user of the module to provide the value, otherwise an error will occur.": "没有默认值但仍然需要的选项可以用\"！\"来提供。这将迫使模块的用户提供该值，否则将发生错误。",
        "Also, all serialization and validation types from the previous chapters xref:validation.adoc[Validation] and xref:serialization.adoc[Serialization] can be used to specify in great detail what type and content restrictions an option must have.": "另外，前几章的所有序列化和验证类型xref:validation.adoc[验证]和xref:serialization.adoc[序列化]都可以用来非常详细地指定一个选项必须有哪些类型和内容限制。",
        "Injection": "注射",
        "Configuration options, like other dependencies, can be safely and easily injected through the DI container as shown earlier. The simplest method is to reference a single option using the index access operator:": "配置选项，像其他的依赖关系一样，可以通过DI容器安全而容易地注入，如前面所示。最简单的方法是使用索引访问操作符来引用单个选项：",
        "Configuration options can be referenced not only individually, but also as a group. The TypeScript utility type `Partial` is used for this purpose:": "配置选项不仅可以单独引用，还可以作为一个组来引用。TypeScript的实用类型`Partial`被用于此目的：",
        "To get all configuration options, the configuration class can also be referenced directly:": "为了获得所有的配置选项，也可以直接引用配置类：",
        "However, it is recommended to reference only the configuration options that are actually used. This not only simplifies unit tests, but also makes it easier to see what is actually needed from the code.": "然而，我们建议只引用实际使用的配置选项。这不仅简化了单元测试，而且也使人们更容易从代码中看到实际需要的东西。",
        "Scopes": "瞄准镜",
        "By default, all providers of the DI container are singletons and are therefore instantiated only once. This means that in the example of UserRepository there is always only one instance of UserRepository during the entire runtime. At no time is a second instance created, unless the user does this manually with the \"new\" keyword.": "默认情况下，DI容器的所有提供者都是单子，因此只被实例化一次。这意味着在UserRepository的例子中，在整个运行时间内始终只有一个UserRepository的实例。任何时候都不会创建第二个实例，除非用户用 \"new \"关键字来手动创建。",
        "However, there are various use cases where a provider should only be instantiated for a short time or only during a certain event. Such an event could be, for example, an HTTP request or an RPC call. This would mean that a new instance is created for each event and after this instance is no longer used it is automatically removed (by the garbage collector).": "然而，在各种用例中，提供者应该只在短时间内或只在某个事件中被实例化。例如，这样的事件可以是一个HTTP请求或一个RPC调用。这将意味着为每个事件创建一个新的实例，在这个实例不再被使用后，它将被自动删除（由垃圾收集器）。",
        "An HTTP request is a classic example of a scope. For example, providers such as a session, a user object, or other request-related providers can be registered to this scope. To create a scope, simply choose an arbitrary scope name and then specify it with the providers.": "一个 HTTP 请求是一个典型的作用域的例子。例如，诸如会话、用户对象或其他与请求有关的提供者可以被注册到这个作用域。要创建一个作用域，只需选择一个任意的作用域名称，然后用提供者指定它。",
        "Once a scope is specified, this provider cannot be obtained directly from the DI container, so the following call will fail:": "一旦指定了一个作用域，这个提供者就不能直接从DI容器中获得，所以下面的调用将失败：",
        "Instead, a scoped DI container must be created. This would happen every time an HTTP request comes in:": "相反，必须创建一个有范围的DI容器。这将在每次HTTP请求进来的时候发生：",
        "Providers that are also registered in this scope can now be requested on this scoped DI container, as well as all providers that have not defined a scope.": "现在可以在这个范围内注册的提供者，以及所有没有定义范围的提供者，都可以在这个范围的DI容器上请求。",
        "Since all providers are singleton by default, each call to `get(UserSession)` will always return the same instance per scoped container. If you create multiple scoped containers, multiple UserSessions will be created.": "由于所有的提供者默认是单子，每次调用`get(UserSession)`将总是返回每个作用域容器的同一个实例。如果你创建了多个范围内的容器，将创建多个UserSession。",
        "Scoped DI containers have the ability to set values dynamically from the outside. For example, in an HTTP scope, it is easy to set the HttpRequest and HttpResponse objects.": "作用域DI容器有能力从外部动态地设置值。例如，在一个HTTP作用域中，很容易设置HttpRequest和HttpResponse对象。",
        "Applications using the Deepkit framework have by default an `http`, an `rpc`, and a `cli` scope. See respectively the chapter xref:cli.adoc[CLI], xref:http.adoc[HTTP], or xref:rpc.adoc[RPC].": "使用Deepkit框架的应用程序默认有一个`http`、一个`rpc`和一个`cli`范围。请分别参阅xref:cli.adoc[CLI]、xref:http.adoc[HTTP]或xref:rpc.adoc[RPC]章节。",
        "Setup Calls": "设置电话",
        "Setup calls allow to manipulate the result of a provider. This is useful for example to use another dependency injection variant, the method injection.": "设置调用允许对提供者的结果进行操作。例如，这对于使用另一种依赖性注入的变体--方法注入是非常有用的。",
        "Setup calls can only be used with the module API or the app API and are registered above the module.": "设置调用只能用于模块API或应用程序API，并在模块上方注册。",
        "The `setupProvider` method thereby returns a proxy object of UserRepository on which its methods can be called. It should be noted that these method calls are merely placed in a queue and are not executed at this time. Accordingly, no return value is returned.": "`setupProvider`方法因此返回一个UserRepository的代理对象，其方法可以被调用。应该注意的是，这些方法的调用只是放在一个队列中，此时并没有被执行。因此，没有返回值。",
        "In addition to method calls, properties can also be set.": "除了方法调用之外，还可以设置属性。",
        "This assignment is also simply placed in a queue.": "这项任务也被简单地放在一个队列中。",
        "The calls or the assignments in the queue are then executed on the actual result of the provider as soon as this is created. That is with a ClassProvider these are applied to the class instance, as soon as the instance is created, with a FactoryProvider on the result of the Factory, and with a ValueProvider on the Provider.": "队列中的调用或赋值会在提供者的实际结果上执行，只要这个结果被创建。也就是说，对于 ClassProvider 来说，一旦实例被创建，这些就会被应用到类的实例上；对于 FactoryProvider 来说，这些就会被应用到 Factory 的结果上；对于 ValueProvider 来说，这些就会被应用到 Provider 上。",
        "To reference not only static values, but also other providers, the function `injectorReference` can be used. This function returns a reference to a provider, which is also requested by the DI container when the setup calls are executed.": "为了不仅引用静态值，而且引用其他提供者，可以使用函数`injectorReference`。这个函数返回对提供者的引用，当设置调用被执行时，DI容器也会请求它。",
        "*Abstractions/Interfaces*": "*Abstractions/Interfaces *",
        "Setup calls can also be assigned to an interface.": "设置呼叫也可以分配给一个接口。",
        "Event System": "事件系统",
        "Ein Event-System ermöglicht es Anwendungskomponenten im selben Prozess miteinander zu kommunizieren, indem sie Ereignisse versenden und auf sie hören. Es hilft bei der Modularisierung des Codes, indem Nachrichten zwischen Funktionen gesendet werden, die nicht direkt voneinander wissen.": "一个事件系统可以让应用组件在自己的过程中相互沟通，并让它们对自己的行为负责。它有助于代码的模块化，使功能之间的联系得以实现，而这些联系并不是直接的。",
        "Die Anwendung oder Library eröffnet dabei die Möglichkeit an einem bestimmten Zeitpunkt der Ausführung zusätzliche Funktionen auszuführen. Diese zusätzlichen Funktionen registrieren sich dabei selbst als sogenannte Event-Listener.": "在这种情况下，Anwendung或Library就有可能在一个最佳的时间点上启动一些特殊的功能。这些功能都是自己注册的，并成为事件听众。",
        "Ein Event kann dabei vielfältig sein:": "一个事件可以是一个非常重要的事件：",
        "Die Anwendung fährt hoch oder runter.": "严格按照规定进行操作。",
        "Ein neuer User wurde erstellt oder gelöscht.": "一个新的用户已经诞生或被冻结了。",
        "Eine Error wurde geworfen.": "有一个错误被发现了。",
        "Ein neuer HTTP-Request ist hereingekommen.": "这里有一个新的HTTP-Request。",
        "Deepkit Framework und seine Libraries bieten bereits diverse Events an, auf die der Benutzer hören und reagieren kann. Es können jedoch auch beliebig viele eigene Events angelegt werden, um so die Anwendung modular erweiterbar zu machen.": "Deepkit Framework和它的程序库提供了各种事件，使用户可以使用和响应。但是，它还可以提供很多独特的事件，以便使模块化的应用更加完善。",
        "Nachfolgend ein Beispiel der Low-Level API von `@deepkit/event`. Wenn Deepkit Framework genutzt wird, geschieht die Registrierung von Event-Listener nicht über `EventDispatcher` direkt sondern über Module.": "以下是\"@deepkit/event \"的低级API的例子。如果Deepkit框架被使用，那么事件监听器的注册就不能直接通过`EventDispatcher`，而是通过模块。",
        "Da das Event-System von Deepkit basiert auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于Deepkit的事件系统是以运行时类型为基础的，因此需要在之前就把`@deepkit/type`安装好。请参阅 xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation]。",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/event` installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果你想成功，可以安装`@deepkit/event`，或者使用Deepkit框架，因为该库已经被安装了。",
        "Zu beachten ist, dass `@deepkit/event` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller API verwendet wird.": "值得注意的是，`@deepkit/event`为控制器API提供了TypeScript-Decorators的基础，并且必须通过`experimentalDecorators`激活这一特性，否则控制器API将被使用。",
        "Sobald die Library installiert ist, kann die API davon direkt benutzt werden.": "如果安装了库，就可以直接使用API了。",
        "Event Token": "事件令牌",
        "Im Mittelpunkt vom Event-System stehen die Event-Tokens. Sie sind Objekte, die die eindeutige Event-ID und den Event-Typen definieren. Über ein Event-Token kann ein Event ausgelöst und auf ein Event gehört werden. Dabei ist konzeptionell derjenige, der den Event eines Event-Tokens auslöst, auch der Besitzer dieses Event-Tokens. Das Event-Token entscheidet entsprechend darüber, welche Daten an dem Event verfügbar sind und ob asynchrone Event-Listener erlaubt werden.": "在事件系统的中间位置，有一些事件指标。它们是定义了特定的事件ID和事件类型的对象。在一个事件标记上，可以显示一个事件，也可以显示一个事件。这样一来，就会有一个人，也就是事件令牌的持有者，也就是事件令牌的持有者。事件令牌显示了事件中的哪些数据是可以访问的，以及是否会有非同步的事件监听器被使用。",
        "TODO asynchrone": "TODO asynchrone",
        "Event Types": "事件类型",
        "Propagation": "传播",
        "TODO. event.stop()": "TODO.event.stop()",
        "CLI": "CLI",
        "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Text-Eingabe und Text-Ausgabe interagieren. Der Vorteil in dieser Variante mit der Anwendung zu interagieren, ist, dass lediglich ein Terminal entweder lokal oder über eine SSH-Verbindung bestehen muss.": "命令行界面（CLI）程序是一种程序，它以文本编辑和文本使用的形式在终端上进行交互。这种方案的好处是，可以通过本地或通过SSH-Verbindung来实现终端的交互。",
        "Eine CLI-Anwendung in Deepkit hat den vollen Zugriff auf den DI-Container und kann so auf alle Provider und Konfigurationsoptionen zugreifen.": "Deepkit中的CLI应用对DI容器有很大的影响，因此可以对所有的提供者和配置选项进行修改。",
        "Die Argumente und Optionen der CLI-Anwendung werden über Methoden-Parameter via TypeScript Typen gesteuert und werden automatisch serialisiert und validiert.": "CLI应用中的参数和选项通过TypeScript类型的方法参数来实现，并自动进行序列化和验证。",
        "CLI ist einer von drei Einstiegspunkten zu einer Deepkit Framework Anwendung. Im Deepkit Framework wird die Anwendung immer über ein CLI-Program gestartet, das selbst vom User in TypeScript geschrieben ist. Es gibt daher keine Deepkit spezifisches globales CLI tool, um eine Deepkit Anwendung zu starten. Auf diese Weise starten Sie den HTTP/RPC-Server, führen Migrationen aus oder führen eigene Befehle aus. Das alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` benutzt wird, erhält die Anwendung zusätzliche Commands für den Application Server, Migrations, und mehr.": "CLI是Deepkit框架应用的三个基础中的一个。在Deepkit框架中，使用的是CLI程序，该程序是由用户自己用TypeScript编写的。因此，没有专门的Deepkit全球CLI工具来启动Deepkit Anwendung。通过这种方式，你可以启动HTTP/RPC服务器，进行迁移，或者启动你自己的功能。所有这一切都源于一个新的起点--数据。如果Deepkit框架从`@deepkit/framework`中导入，就可以为应用服务器、迁移和更多的事情使用这些命令了。",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Decorators, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "CLI-Framework以简单的方式让用户注册自己的命令，并以简单的类为基础。它的基础是\"@deepkit/app\"，这是一个小型的包，只为这个目的而设，而且在不使用Deepkit框架的情况下也可以独立存在。在这个包里可以找到一些装饰器，这些装饰器可以用来设计CLI-控制器系列。",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel xref:dependency-injection.adoc[Dependency Injection] für weitere Details.": "控制器将通过依赖注入容器进行管理，并且可以使用其他的提供者。更多细节请参见 xref:dependency-injection.adoc [Dependency Injection] 。",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Deepkit 中的 CLI 程序以运行时类型为基础，因此需要 @deepkit/type 在之前就进行安装。请参见 xref:runtime-types.adoc#runtime-types-installation[运行时类型安装]。",
        "Falls dies erfolgreich geschehen ist, kann @deepkit/app installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果你能顺利完成任务，你可以使用@deepkit/app或者Deepkit框架来安装这个库。",
        "Zu beachten ist, dass `@deepkit/app` auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss.": "值得注意的是，`@deepkit/app`基于TypeScript-Decorators，并且必须通过`experimentalDecorators`来实现这一功能。",
        "Benutzung": "本公司",
        "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen. Dabei handelt es sich um eine einfache Klasse, die eine Methode `exeecute` hat und mit Informationen über den Befehl ausgestattet ist.": "如果你想为你的应用建立一个目标，你必须建立一个CLI-控制器。这样一来，就有了一个简单的界面，它的方法是 \"执行\"，并有关于目标的信息。",
        "_File: app.ts_": "文件：app.ts_",
        "In dem Decorator `@cli.controller` wird als erstes Argument der eindeutige Name der CLI-Anwendung definiert. Weitere Optionen wie eine Beschreibung können im Objekt an der zweiten Stelle optional hinzufügt werden.": "在装饰器`@cli.controller`中，定义了CLI-Anwendung的第一个参数，即eindeutige Name。其他的选项，比如 Beschreibung，可以在第二个选项中选择，并在第二个选项中加入。",
        "Dieser Code ist bereits eine komplette CLI-Anwendung und kann so gestartet werden:": "这些代码已经是一个完整的CLI应用，并且可以这样设置：",
        "Zu sehen ist, dass ein \"test\" Command verfügbar ist. Um dieses auszuführen, muss der Name als Argument übergeben werden:": "我们可以看到，\"测试 \"命令是可以使用的。如果你想知道这些，你必须把名称作为参数来使用：",
        "Es ist auch möglich, die Datei mittels `chmod +x app.ts` ausführbar zu machen, sodass der Command `./app.ts` bereits ausreicht, um es zu starten. Zu beachten ist, dass dann ein sogenannter": "也可以通过 \"chmod +x app.ts \"的方式使数据生效，因为\"./app.ts \"的命令已经存在，所以可以启动。值得注意的是，这样一来，就会有更多的人加入进来。",
        "Shebang notwendig ist. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. In dem Beispiel oben ist dies bereits vorhanden: `&#35;!/usr/bin/env ts-node-script` und nutzt den Skript-Modus von `ts-node`.": "Shebang是不需要的。Shebang指的是在脚本程序开始时的Zeichenkombination `#!`。在前面的例子中，这个词已经存在了：`&#35;!/usr/bin/env ts-name-script`，并且连接到了`ts-name'的脚本模式。",
        "Auf diese Weise können beliebig viele Commands erstellt und registriert werden. Der in `@cli.controller` angegeben eindeutige Name sollte gut gewählt werden und erlaubt das Gruppieren von Commands mit dem `:` Zeichen (z.B. `user:create`, `user:remove`, etc).": "在这种情况下，很多命令就会被制定和注册，这是很重要的。在\"@cli.controller \"中指定的特定名称应该是正确的，并且可以用\": \"来显示命令的组别（例如 \"user:create\", \"user:remove\", 等等）。",
        "Argumente": "论证",
        "Um Argumente hinzuzufügen, werden neue Parameter auf die Methode `execute` hinzugefügt und mit dem Decorator `@arg` dekoriert.": "如果要修改参数，需要在 \"执行 \"模式下修改新的参数，并使用装饰器\"@arg \"来设计。",
        "Wenn Sie diesen Befehl jetzt ausführen, ohne einen Namen anzugeben, wird ein Fehler ausgegeben:": "如果你现在发现了这个问题，但没有找到你的名字，那么你就会发现这个问题的存在：",
        "Durch die Verwendung von `--help` erhalten Sie weitere Informationen über die erforderlichen Argumente:": "通过使用`--help`，你可以获得更多的信息，了解你所需要的论据：",
        "Sobald der Name als Argument übergeben wird, wird die Methode `execute` in TestCommand ausgeführt und der Name korrekt übergeben.": "如果名字是一个参数，那么TestCommand中的`execute'方法就会被激活，名字也会被重新激活。",
        "Flags": "旗帜",
        "Flags sind eine weitere Möglichkeit, Ihrem Befehl Werte zu übergeben. Meist sind diese Optional, doch müssen es nicht sein. Parameter, die mit `@flag name` dekoriert sind, können via `--name value` oder `--name=value` übergeben werden.": "旗帜是一种新的方法，可以让我的作品得到更多的关注。主要是可选的，但也有可能是不确定的。用`@flag name'表示的参数，可以通过`--name value'或`--name=value'进行编辑。",
        "In der Hilfe-Ansicht ist in den \"OPTIONS\" nun zu sehen, dass ein `--id` Flag notwendig ist. Gibt man dieses Korrekt an, erhält der Command diesen Wert.": "在Hilfe-Ansicht的 \"OPTIONS \"中可以看到，\"--id \"标志是不需要的。如果你有这样的选项，你就会发现这个命令的作用。",
        "Boolean Flags": "布尔型标志",
        "Flags haben den Vorteil, dass sie auch als wertlosen Flag verwendet werden können, um so zum Beispiel ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolean markiert ist, wird dieses Verhalten aktiviert.": "旗子有一个好处，那就是它们也可以作为一个独立的旗子来使用，这样就可以使一个最佳属性得到发挥。如果一个参数被标记为可选的布尔值，那么这个变量就会被激活。",
        "Multiple Flags": "多个旗帜",
        "Um mehrere Werte demselben Flag zu übergeben, kann ein Flag als Array markiert werden.": "如果要在两个旗帜之间选择一个，可以将一个旗帜标记为阵列。",
        "Single Character Flags": "单一字符标志",
        "Um einem Flag zu erlauben, auch als ein einzelner Charakter übergeben zu werden, kann `@flag.char('x')` genutzt werden.": "如果想让一个旗子显示出来，或者让它成为一个独立的字符，可以使用\"@flag.char('x') \"来实现。",
        "Optional / Default": "可选/默认",
        "Die Signatur der Methode `execute` definiert, welche Argument oder Flags optional sind. Ist der Parameter als Optional markiert, so muss er nicht angegeben werden.": "执行 \"方法的标志，定义了哪些参数或标志是可选的。如果参数被标记为可选，那么它就不可能再被激活。",
        "Dasselbe für Parameter mit einem Default-Wert:": "Dasselbe für Parameter mit einem Default-Wert：",
        "Dies gilt auch für Flags in derselben Art und Weise.": "这也适用于不同艺术和方式的旗帜。",
        "Serialization / Validation": "序列化/验证",
        "Alle Argumente und Flags werden automatisch basierend auf dessen Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.": "Alle Argumente和Flags将自动根据其类型进行序列化、有效化，并可在此基础上对其进行修改。",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature xref:serialization.adoc#serialisation-loosely-convertion[Weiche Typenkonvertierung].": "因此，作为数字定义的Argument，在控制器中也能保证有一个单独的数字，尽管命令行界面以文本和字符串为基础。在这种情况下，可以通过xref:serialization.adoc#serialisation-loosely-convertion[Weiche Typenkonvertierung]这一特性自动实现。",
        "Zusätzliche Einschränkungen können mit den Typen-Decorators aus `@deepkit/type` definiert werden.": "Zusätzliche Einschränkungen可以通过`@deepkit/type`定义的Typen-Decorators来实现。",
        "Der Typ `Postive` bei `id` gibt an, dass nur positive Nummern gewollt sind. Übergibt der User nun eine negative Zahl, so wird der Code in `execute` gar nicht erst ausgeführt und es wird eine Fehlermeldung präsentiert.": "在 \"id \"中的 \"Postive \"类型是指，只有正数才会被发现。如果用户有负数，那么`execute`中的代码就不会出现，并且会显示出错误信息。",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel xref:validation.adoc[Validation] für mehr Informationen.": "如果是正数的话，就会像以前一样运行。通过这种简单易行的验证方式，可以使命令更有效地防止故障。更多信息请参见xref:validation.adoc[Validation]一节。",
        "Description": "描述",
        "Um einen Flag oder Argument zu beschreiben, kann `@flag.description` beziehungsweise `@arg.description` genutzt werden.": "当一个标志或参数被描述时，`@flag.description`必须是`@arg.description`。",
        "In der Hilfe-Ansicht erscheint diese Beschreibung hinter dem Flag beziehungsweise Argument:": "在Hilfe-Ansicht中，我们可以在旗帜下看到这样的描述：",
        "Exit code": "退出代码",
        "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollten in der `exucute`-Methode eine Zahl ungleich 0 zurückgeben werden.": "Exit-Code是标准的0，这意味着Befehl已经完成了。如果要使退出代码生效，需要在 \"解释 \"方法中设置一个不为0的值。",
        "Die Klasse des Commands wird vom DI Container verwaltet, sodass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.": "命令集是通过DI容器来管理的，如果定义了Abhängigkeiten，那么就可以通过DI容器来实现。",
        "HTTP": "HTTP",
        "Processing HTTP requests is one of the most well-known tasks for a server. It converts an input (HTTP request) into an output (HTTP response) and performs a specific task. A client can send data to the server via an HTTP request in a variety of ways, which must be read and handled correctly. In addition to the HTTP body, HTTP query or HTTP header values are also possible. How data is actually processed depends on the server. It is the server that defines where and how the values are to be sent by the client.": "处理HTTP请求是服务器最著名的任务之一。它将输入（HTTP请求）转换为输出（HTTP响应）并执行特定的任务。客户端可以通过HTTP请求以各种方式向服务器发送数据，这些数据必须被正确读取和处理。除了HTTP主体之外，HTTP查询或HTTP头值也是可能的。数据如何被实际处理取决于服务器。正是服务器定义了客户端要在哪里以及如何发送这些值。",
        "The top priority here is not only to correctly execute what the user expects, but to correctly convert (deserialize) and validate any input from the HTTP request.": "这里的首要任务不仅是正确执行用户期望的内容，而且要正确转换（反序列化）和验证来自HTTP请求的任何输入。",
        "The pipeline through which an HTTP request passes on the server can be varied and complex. Many simple HTTP libraries pass only the HTTP request and the HTTP response for a given route, and expect the developer to process the HTTP response directly. A middleware API allows the pipeline to be extended as needed.": "一个HTTP请求在服务器上经过的管道可以是多样的、复杂的。许多简单的HTTP库只传递HTTP请求和给定路径的HTTP响应，并期望开发者直接处理HTTP响应。中间件API允许根据需要对管道进行扩展。",
        "_Express Beispiel_": "快递公司_快递公司_",
        "This is very well tailored for simple use cases, but quickly becomes confusing as the application grows, since all inputs and outputs must be manually serialized or deserialized and validated. Also, consideration must be given to how objects and services such as a database abstraction can be obtained from the application itself. It forces the developer to put an architecture on top of it that maps these mandatory functionalities.": "这对于简单的用例来说是非常合适的，但随着应用程序的增长，很快就会变得混乱，因为所有的输入和输出都必须手动进行序列化或反序列化并进行验证。另外，必须考虑到如何从应用程序本身获得对象和服务，如数据库抽象。它迫使开发者在上面放一个架构，映射这些强制性的功能。",
        "Deepkit's HTTP Library leverages the power of TypeScript and Dependency Injection. SerializationDeserialization and validation of any values happen automatically based on the defined types. It also allows defining routes either via a functional API as in the example above or via controller classes to cover the different needs of an architecture.": "Deepkit的HTTP库利用了TypeScript和依赖注入的力量。序列化、解序列化和任何值的验证都是根据定义的类型自动进行的。它还允许通过功能API（如上面的例子）或通过控制器类来定义路由，以满足架构的不同需求。",
        "It can be used either with an existing HTTP server like Node's `http` module or with the Deepkit framework. Both API variants have access to the dependency injection container and can thus conveniently retrieve objects such as a database abstraction and configurations from the application.": "它既可以与现有的HTTP服务器（如Node的`http`模块）一起使用，也可以与Deepkit框架一起使用。这两种API变体都可以访问依赖性注入容器，因此可以方便地从应用程序中检索对象，如数据库抽象和配置。",
        "_Deepkit Example_": "_Deepkit范例_",
        "Since CLI programs in Deepkit are based on runtime types, it is necessary to have `@deepkit/type` already installed correctly. See for this xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于Deepkit中的CLI程序是基于运行时类型的，因此有必要正确安装`@deepkit/type`。请参阅xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation]。",
        "If this is done successfully, `@deepkit/app` can be installed or the Deepkit framework which already uses the library under the hood.": "如果这样做成功了，就可以安装`@deepkit/app`或者Deepkit框架，该框架已经在引擎盖下使用该库。",
        "Note that `@deepkit/http` for the controller API is based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators` once the controller API is used.": "请注意，控制器API的`@deepkit/http`是基于TypeScript装饰器的，一旦使用控制器API，必须用`experimentalDecorators`相应地启用这一功能。",
        "Functional API": "功能性API",
        "The functional API is based on functions and can be registered via the router registry, which can be obtained via the DI container of the app.": "功能性API是基于函数的，可以通过路由器注册表注册，可以通过应用程序的DI容器获得。",
        "The router registry can also be obtained in Event Listener or in the bootstrap, so that based on modules, configurations and other providers various routes are registered.": "路由器注册表也可以在Event Listener或bootstrap中获得，这样基于模块、配置和其他提供者的各种路由被注册。",
        "Once modules are used, functional routes can also be provided dynamically by modules.": "一旦使用模块，功能路线也可以由模块动态地提供。",
        "See xref:framework.adoc#framework-modules[Framework Modules], to learn more about App Modules.": "参见xref:framework.adoc#framework-modules[框架模块]，以了解更多关于应用模块的信息。",
        "Controller API": "控制器API",
        "The controller API is based on classes and can be registered via the App-API under the option `controllers`.": "控制器API是基于类的，可以通过App-API的 \"controllers \"选项注册。",
        "Once modules are used, controllers can also be provided by modules.": "一旦使用模块，控制器也可以由模块提供。",
        "To provide controllers dynamically (depending on the configuration option, for example), the `process` hook can be used.": "为了动态地提供控制器（例如，取决于配置选项），可以使用`process`钩子。",
        "HTTP Server": "HTTP服务器",
        "If Deepkit Framework is used, an HTTP server is already built in. However, the HTTP library can also be used with its own HTTP server without using the Deepkit framework.": "如果使用Deepkit框架，已经内置了一个HTTP服务器。但是，HTTP库也可以使用自己的HTTP服务器，而不使用Deepkit框架。",
        "HTTP Client": "HTTP客户端",
        "todo: fetch API, validation, und cast.": "todo：获取API，验证，und cast。",
        "Route Names": "路线名称",
        "Routes can be given a unique name that can be referenced when forwarding. Depending on the API, the way a name is defined differs.": "路由可以被赋予一个独特的名称，在转发时可以被引用。根据API的不同，定义名称的方式也不同。",
        "From all routes with a name the URL can be requested by `Router.resolveUrl()`.": "可以通过`Router.resolveUrl()`请求所有有名字的路由的URL。",
        "The router functions as well as the controller classes and controller methods can define arbitrary dependencies, which are resolved by the dependency injection container. For example, it is possible to conveniently get to a database abstraction or logger.": "路由器函数以及控制器类和控制器方法可以定义任意的依赖关系，这些依赖关系由依赖注入容器来解决。例如，可以方便地进入数据库抽象或记录器。",
        "For example, if a database has been provided as a provider, it can be injected:": "例如，如果一个数据库被作为一个提供者提供，它可以被注入：",
        "_Functional API:_": "_功能API：_",
        "_Controller API:_": "_控制器API:_",
        "See xref:dependency-injection.adoc[Dependency Injection] to learn more.": "参见xref:dependency-injection.adoc[依赖注入]以了解更多。",
        "Input": "输入",
        "All of the following input variations function in the same way for both the functional and the controller API. They allow data to be read from an HTTP request in a type-safe and decoupled manner. This not only leads to significantly increased security, but also simplifies unit testing, since strictly speaking, not even an HTTP request object needs to exist to test the route.": "以下所有的输入变体对于功能型和控制器API的功能都是一样的。它们允许以一种类型安全和解耦的方式从HTTP请求中读取数据。这不仅使安全性大大增加，而且还简化了单元测试，因为严格来说，甚至不需要存在一个HTTP请求对象来测试路由。",
        "All parameters are automatically converted (deserialized) to the defined TypeScript type and validated. This is done via the `@deepkit/type` package and its xref:serialization.adoc[Serialization] and xref:validation.adoc[Validation] features.": "所有的参数都会自动转换（反序列化）为定义的TypeScript类型并进行验证。这是通过`@deepkit/type`包及其xref:serialization.adoc[序列化]和xref:validation.adoc[验证]功能实现的。",
        "For simplicity, all examples with the functional API are shown below.": "为了简单起见，所有带有功能API的例子都显示在下面。",
        "Path Parameters": "路径参数",
        "Path parameters are values extracted from the URL of the route. The type of the value depends on the type at the associated parameter of the function or method. The conversion is done automatically with the feature xref:serialization.adoc#serialisation-loosely-convertion[Soft Type Conversion].": "路径参数是从路由的URL中提取的值。值的类型取决于函数或方法的相关参数处的类型。转换是通过xref:serialization.adoc#serialisation-loosely-convertion[软类型转换]这一特性自动完成的。",
        "If a Path parameter is defined as a type other than string, it will be converted correctly.": "如果一个Path参数被定义为字符串以外的类型，它将被正确转换。",
        "Additional validation constraints can also be applied to the types.": "额外的验证约束也可以应用于类型。",
        "All validation types from `@deepkit/type` can be applied. For more on this, see xref:http.adoc#http-validation[HTTP Validation]].": "所有来自`@deepkit/type`的验证类型都可以被应用。关于这一点，请参阅xref:http.adoc#http-validation[HTTP Validation]]。",
        "The Path parameters have `[^]+` set as a regular expression by default in the URL matching. The RegExp for this can be customized as follows:": "路径参数在URL匹配中默认设置了`[^]+`作为正则表达式。这方面的正则表达式可以自定义，如下所示：",
        "This is only necessary in exceptional cases, because often the types in combination with validation types themselves already correctly restrict possible values.": "这只有在特殊情况下才有必要，因为往往与验证类型相结合的类型本身已经正确地限制了可能的值。",
        "Query Parameters": "查询参数",
        "Query parameters are values from the URL after the `?` character and can be read with the `HttpQuery<T>` type. The name of the parameter corresponds to the name of the query parameter.": "查询参数是URL中`?`字符后的值，可以用`HttpQuery<T>`类型读取。参数的名称与查询参数的名称相对应。",
        "Query parameters are also automatically deserialized and validated.": "查询参数也被自动反序列化和验证。",
        "All validation types from `@deepkit/type` can be applied. For more on this, see xref:http.adoc#http-validation[HTTP Validation].": "所有来自`@deepkit/type`的验证类型都可以被应用。关于这一点，请参阅xref:http.adoc#http-validation[HTTP Validation]。",
        "Warning: Parameter values are not escaped/sanitized. Their direct return in a string in a route as HTML opens a security hole (XSS). Make sure that external input is never trusted and filtere/sanitize/convert data where necessary.": "警告：参数值没有被转义/消毒。它们在路由中的字符串中直接返回为HTML，会打开一个安全漏洞（XSS）。确保外部输入永远不被信任，必要时过滤/消毒/转换数据。",
        "Query Model": "查询模式",
        "With a large number of query parameters, it can quickly become confusing. To bring order back in here, a model (class or interface) can be used, which summarizes all possible query parameters.": "有了大量的查询参数，它很快就会变得混乱。为了使这里恢复秩序，可以使用一个模型（类或接口），它概括了所有可能的查询参数。",
        "The properties in the specified model can contain all TypeScript types and validation types that `@deepkit/type` supports. See the chapter xref:serialization.adoc[Serialization] and xref:validation.adoc[Validation].": "指定模型中的属性可以包含`@deepkit/type`支持的所有TypeScript类型和验证类型。参见xref:serialization.adoc[序列化]和xref:validation.adoc[验证]章节。",
        "Body": "身体",
        "For HTTP methods that allow an HTTP body, a body model can also be specified. The body content type of the HTTP request must be either `application/x-www-form-urlencoded`, `multipart/form-data` or `application/json` so that Deepkit can automatically convert this to JavaScript objects.": "对于允许有HTTP正文的HTTP方法，还可以指定一个正文模型。HTTP请求的主体内容类型必须是`application/x-www-form-urlencoded`、`multipart/form-data`或`application/json`，以便Deepkit能够自动将其转换为JavaScript对象。",
        "Header": "标题",
        "Stream": "溪流",
        "Manual Validation Handling": "手动验证处理",
        "To manually take over the validation of the body model, a special type `HttpBodyValidation<T>` can be used. It allows to receive also invalid body data and to react very specifically to error messages.": "为了手动接管身体模型的验证，可以使用一个特殊的类型`HttpBodyValidation<T>`。它允许接收无效的身体数据，并对错误信息作出非常具体的反应。",
        "As soon as `valid()` returns `false`, the values in the specified model may be in a faulty state. This means that the validation has failed. If `HttpBodyValidation` is not used and an incorrect HTTP request is received, the request would be directly aborted and the code in the function would never be executed. Use `HttpBodyValidation` only if, for example, error messages regarding the body should be manually processed in the same route.": "一旦`valid()`返回`false`，指定模型中的值就可能处于错误的状态。这意味着验证已经失败。如果不使用`HttpBodyValidation`，收到一个不正确的HTTP请求，请求将直接被中止，函数中的代码将永远不会被执行。只有在例如关于正文的错误信息应该在同一个路由中被手动处理的情况下才使用`HttpBodyValidation`。",
        "File Upload": "文件上传",
        "A special property type on the body model can be used to allow the client to upload files. Any number of `UploadedFile` can be used.": "身体模型上的一个特殊的属性类型可以用来允许客户上传文件。可以使用任何数量的`UploadedFile`。",
        "By default, Router saves all uploaded files to a temp folder and removes them once the code in the route has been executed. It is therefore necessary to read the file in the specified path in `path` and save it to a permanent location (local disk, cloud storage, database).": "默认情况下，Router将所有上传的文件保存在一个临时文件夹中，一旦路由中的代码被执行，就会将其删除。因此，有必要读取`path`中指定路径的文件，并将其保存到一个永久的位置（本地磁盘、云存储、数据库）。",
        "Validation in an HTTP server is a mandatory functionality, because almost always work with data that is not trustworthy. The more places data is validated, the more stable the server is. Validation in HTTP routes can be conveniently used via types and validation constraints and is checked with a highly optimized validator from `@deepkit/type`, so there are no performance problems in this regard. It is therefore highly recommended to use these validation capabilities as well. Better one time too much, than one time too little.": "HTTP服务器中的验证是一个强制性的功能，因为几乎总是与不值得信任的数据一起工作。数据被验证的地方越多，服务器就越稳定。HTTP路由中的验证可以通过类型和验证约束方便地使用，并通过`@deepkit/type`的高度优化的验证器进行检查，所以在这方面没有性能问题。因此，我们强烈建议你也使用这些验证功能。一次太多，总比一次太少好。",
        "All inputs such as path parameters, query parameters, and body parameters are automatically validated for the specified TypeScript type. If additional constraints are specified via types of `@deepkit/type`, these are also checked.": "所有的输入，如路径参数、查询参数和主体参数，都会被自动验证为指定的TypeScript类型。如果通过`@deepkit/type`的类型指定了额外的约束，这些也会被检查。",
        "See xref:validation.adoc[Validation] for more information on this.": "请参阅xref:validation.adoc[Validation]获取更多相关信息。",
        "Output": "输出",
        "A route can return various data structures. Some of them are handled in a special way, such as redirects and templates, and others, such as simple objects, are simply sent as JSON.": "一个路由可以返回各种数据结构。其中一些是以特殊方式处理的，如重定向和模板，而其他的，如简单的对象，则简单地作为JSON发送。",
        "JSON": "JSON",
        "By default, normal JavaScript values are returned to the client as JSON with the header `applicationjson; charset=utf-8`.": "默认情况下，正常的JavaScript值会以JSON形式返回给客户端，标头为`applicationjson; charset=utf-8`。",
        "If an explicit return type is specified for the function or method, the data is serialized to JSON with the Deepkit JSON Serializer according to this type.": "如果为函数或方法指定了明确的返回类型，就会根据该类型用Deepkit JSON序列化器将数据序列化为JSON。",
        "HTML": "HTML",
        "To send HTML there are two possibilities. Either the object `HtmlResponse` or Template Engine with TSX is used.": "要发送HTML，有两种可能性。要么使用对象`HtmlResponse`，要么使用带有TSX的模板引擎。",
        "The template engine variant with TSX has the advantage that used variables are automatically HTML-escaped. See also xref:template.adoc[Template].": "使用TSX的模板引擎变体有一个好处，就是使用的变量会自动进行HTML转义。参见xref:template.adoc[Template]。",
        "Custom Content": "自定义内容",
        "Besides HTML and JSON it is also possible to send text or binary data with a specific content type. This is done via the object `Response`.": "除了HTML和JSON，还可以发送具有特定内容类型的文本或二进制数据。这是通过对象`Response`完成的。",
        "HTTP Errors": "HTTP错误",
        "By throwing various HTTP errors, it is possible to immediately interrupt the processing of an HTTP request and output the corresponding HTTP status of the error.": "通过抛出各种HTTP错误，可以立即中断HTTP请求的处理，并输出错误的相应HTTP状态。",
        "By default, all errors are returned to the client as JSON. This behavior can be customized in the event system under the event `httpWorkflow.onControllerError`. See the section xref:http.adoc#http-events[HTTP Events].": "默认情况下，所有错误都以JSON格式返回给客户端。这一行为可以在事件系统中的`httpWorkflow.onControllerError'事件下进行自定义。参见xref:http.adoc#http-events[HTTP事件]部分。",
        "The error `HttpAccessDeniedError` is a special case. As soon as it is thrown, the HTTP workflow (see xref:http.adoc#http-events[HTTP Events]) does not jump to `controllerError` but to `accessDenied`.": "错误`HttpAccessDeniedError`是一个特殊情况。一旦它被抛出，HTTP工作流（见xref:http.adoc#http-events[HTTP事件]）就不会跳到`controllerError`，而是跳到`accessDenied`。",
        "Custom HTTP errors can be created and thrown with `createHttpError`.": "自定义HTTP错误可以用`createHttpError`来创建和抛出。",
        "Additional headers": "额外的标题",
        "To modify the header of an HTTP response, additional methods can be called on the `Response`, `JSONResponse`, and `HTMLResponse` objects.": "为了修改HTTP响应的头，可以在`Response`、`JSONResponse`和`HTMLResponse`对象上调用其他方法。",
        "Redirect": "重定向",
        "To return a 301 or 302 redirect as a response, `Redirect.toRoute` or `Redirect.toUrl` can be used.": "要返回301或302重定向作为响应，可以使用`Redirect.toRoute`或`Redirect.toUrl`。",
        "The `Redirect.toRoute` method uses the route name here. How to set a route name can be seen in the section xref:http.adoc#http-route-name[HTTP Route Name]. If this referenced route (query or path) contains parameters, they can be specified via the second argument:": "`Redirect.toRoute`方法在这里使用路由名称。如何设置路由名称可以在xref:http.adoc#http-route-name[HTTP路由名称]部分看到。如果这个被引用的路由（查询或路径）包含参数，可以通过第二个参数指定：",
        "Alternatively, you can redirect to a URL with `Redirect.toUrl`.": "或者，你可以用`Redirect.toUrl`重定向到一个URL。",
        "By default, both use a 302 forwarding. This can be customized via the `statusCode` argument.": "默认情况下，两者都使用302转发。这可以通过 \"statusCode \"参数来定制。",
        "Scope": "范围",
        "All HTTP controllers and functional routes are managed within the `http` dependency injection scope. HTTP controllers are instantiated accordingly for each HTTP request. This also means that both can access providers registered for the `http` scope. So additionally `HttpRequest` and `HttpResponse` from `@deepkit/http` are usable as dependencies. If deepkit framework is used, `SessionHandler` from `@deepkit/framework` is also available.": "所有的HTTP控制器和功能路由都在`http`依赖注入范围内管理。HTTP控制器在每个HTTP请求中被相应地实例化。这也意味着两者都可以访问为`http`范围注册的提供者。因此，来自`@deepkit/http`的`HttpRequest`和`HttpResponse`可以作为依赖关系使用。如果使用deepkit框架，`@deepkit/framework'的`SessionHandler'也可以使用。",
        "It can be useful to place providers in the `http` scope, for example to instantiate services for each HTTP request. Once the HTTP request has been processed, the `http` scoped DI container is deleted, thus cleaning up all its provider instances from the garbage collector (GC).": "在`http`作用域中放置提供者可能很有用，例如为每个HTTP请求实例化服务。一旦HTTP请求被处理，`http`范围内的DI容器就会被删除，从而从垃圾收集器（GC）中清理掉它的所有提供者实例。",
        "See xref:dependency-injection.adoc#di-scopes[Dependency Injection Scopes] to learn how to place providers in the `http` scope.": "参见xref:dependency-injection.adoc#di-scopes[依赖注入作用域]，了解如何将提供者放在`http`作用域中。",
        "Events": "活动",
        "The HTTP module is based on a workflow engine that provides various event tokens that can be used to hook into the entire process of processing an HTTP request.": "HTTP模块是基于一个工作流引擎，它提供了各种事件标记，可以用来挂钩处理HTTP请求的整个过程。",
        "The workflow engine is a finite state machine that creates a new state machine instance for each HTTP request and then jumps from position to position. The first position is the `start` and the last the `response`. Additional code can be executed in each position.": "工作流引擎是一个有限状态机，为每个HTTP请求创建一个新的状态机实例，然后从一个位置跳到另一个位置。第一个位置是 \"开始\"，最后一个是 \"响应\"。在每个位置可以执行额外的代码。",
        "Each event token has its own event type with additional information.": "每个事件标记都有自己的事件类型，并有附加信息。",
        "Since all HTTP events are based on the workflow engine, its behavior can be modified by using the specified event and jumping there with the `event.next()` method.": "由于所有的HTTP事件都是基于工作流引擎的，它的行为可以通过使用指定的事件并通过`event.next()`方法跳转到那里进行修改。",
        "The HTTP module uses its own event listeners on these event tokens to implement HTTP request processing. All these event listeners have a priority of 100, which means that when you listen for an event, your listener is executed first by default (since the default priority is 0). Add a priority above 100 to run after the HTTP module's event listeners.": "HTTP模块在这些事件令牌上使用自己的事件监听器来实现HTTP请求处理。所有这些事件监听器的优先级都是100，这意味着当你监听一个事件时，你的监听器默认会被首先执行（因为默认的优先级是0）。添加一个高于100的优先级，在HTTP模块的事件监听器之后运行。",
        "For example, suppose you want to catch the event when a controller is invoked. If a particular controller is to be invoked, we check if the user has access to it. If the user has access, we continue. But if not, we jump to the next workflow item `accessDenied`. There, the procedure of an access-denied is then automatically processed further.": "例如，假设你想捕捉一个控制器被调用时的事件。如果一个特定的控制器要被调用，我们要检查用户是否有权限。如果用户有访问权，我们就继续。但如果没有，我们就跳到下一个工作流项目`accessDenied`。在那里，访问被拒绝的程序会被自动进一步处理。",
        "Security": "安全问题",
        "Sessions": "会议",
        "Middleware": "中间件",
        "HTTP middlewares allow you to hook into the request/response cycle as an alternative to HTTP events. Its API allows you to use all middlewares from the Express/Connect framework.": "HTTP中间件允许你钩住请求/响应周期，作为HTTP事件的替代。它的API允许你使用Express/Connect框架中的所有中间件。",
        "A middleware can either be a class (which is instantiated by the dependency injection container) or a simple function.": "一个中间件可以是一个类（由依赖注入容器实例化），也可以是一个简单的函数。",
        "Global": "全球",
        "By using httpMiddleware.for(MyMiddleware) a middleware is registered for all routes, globally.": "通过使用httpMiddleware.for(MyMiddleware)，在全球范围内为所有路由注册一个中间件。",
        "Per Controller": "每个控制器",
        "You can limit middlewares to one or multiple controllers in two ways. Either by using the `@http.controller` or `httpMiddleware.for(T).forControllers()`. `excludeControllers` allow you to exclude controllers.": "你可以通过两种方式将中间件限制在一个或多个控制器上。要么使用`@http.controller`，要么使用`httpMiddleware.for(T).forControllers()`。`excludeControllers`允许你将控制器排除在外。",
        "Per Route Name": "每个路线名称",
        "`forRouteNames` along with its counterpart `excludeRouteNames` allow you to filter the execution of a middleware per route names.": "`forRouteNames`和其对应的`excludeRouteNames`允许你根据路由名称过滤中间件的执行。",
        "Per Action/Route": "每个行动/路线",
        "To execute a middleware only for a certain route, you can either use `@http.GET().middleware()` or": "要想只为某个路由执行一个中间件，你可以使用`@http.GET().middleware()`或",
        "`httpMiddleware.for(T).forRoute()` where forRoute has multiple options to filter routes.": "`httpMiddleware.for(T).forRoute()`其中forRoute有多个选项来过滤路由。",
        "`forRoutes()` allows as first argument several way to filter for routes.": "`forRoutes()`允许作为第一个参数的几种方式来过滤路线。",
        "Path Pattern": "路径模式",
        "`path` supports wildcard *.": "`path`支持通配符*。",
        "RegExp": "正则",
        "HTTP Method": "HTTP方法",
        "Filter all routes by a HTTP method.": "通过一个HTTP方法过滤所有路由。",
        "Category": "类别",
        "`category` along with its counterpart `excludeCategory` allow you to filter per route category.": "`类别'和其对应的`排除类别'允许你按路线类别进行过滤。",
        "`group` along with its counterpart `excludeGroup` allow you to filter per route group.": "`group`和其对应的`excludeGroup`允许你按路由组过滤。",
        "Per Modules": "每个模块",
        "You can limit the execution of a module for a whole module.": "你可以限制一个模块的执行，对整个模块进行限制。",
        "Per Self Modules": "每个自我模块",
        "To execute a middleware for all controllers/routes of a module where the middleware was registered use `forSelfModules()`.": "使用`forSelfModules()`来为注册了中间件的模块的所有控制器/路由执行一个中间件。",
        "Timeout": "超时",
        "All middleware needs to execute `next()` sooner or later. If a middleware does not execute `next()` withing a timeout, a warning is logged and the next middleware executed. To change the default of 4seconds to something else use timeout(milliseconds).": "所有的中间件迟早都需要执行`next()`。如果一个中间件在超时内没有执行`next()`，就会记录一个警告并执行下一个中间件。使用timeout(milliseconds)将默认的4秒改为其他时间。",
        "Multiple Rules": "多种规则",
        "To combine multiple filters, you can chain method calls.": "为了组合多个过滤器，你可以连锁调用方法。",
        "Express Middleware": "快捷中间件",
        "Almost all express middlewares are supported. Those who access certain request methods of express are not yet supported.": "几乎所有的Express中间件都被支持。那些访问快车的某些请求方法还不被支持。",
        "Resolver": "解答器",
        "Router supports a way to resolve complex parameter types. For example, given a route such as `/user/:id`, this `id` can be resolved to a `user` object outside the route using a resolver. This further decouples HTTP abstraction and route code, further simplifying testing and modularity.": "Router支持一种方法来解决复杂的参数类型。例如，给定一个路由，如`/user/:id`，这个`id`可以使用解析器在路由之外解析为一个`user`对象。这进一步解耦了HTTP抽象和路由代码，进一步简化了测试和模块化。",
        "The decorator in `@http.resolveParameter` specifies which class is to be resolved with the `UserResolver`. As soon as the specified class `User` is specified as a parameter in the function or method, the resolver is used to provide it.": "`@http.resolveParameter`中的装饰器指定了哪个类要用`UserResolver`来解析。只要指定的类`User`被指定为函数或方法中的参数，解析器就会被用来提供它。",
        "If `@http.resolveParameter` is specified at the class, all methods of this class get this resolver. The decorator can also be applied per method:": "如果在类中指定了`@http.resolveParameter`，这个类的所有方法都会得到这个解析器。该装饰器也可以应用于每个方法：",
        "Also, the functional API can be used:": "此外，还可以使用功能性API：",
        "The `User` object does not necessarily have to depend on a parameter. It could just as well depend on a session or an HTTP header, and only be provided when the user is logged in. In `RouteParameterResolverContext` a lot of information about the HTTP request is available, so that many use cases can be mapped.": "`User'对象不一定要依赖一个参数。它也可以依赖于一个会话或一个HTTP头，并且只在用户登录时提供。在`RouteParameterResolverContext`中，有很多关于HTTP请求的信息，所以很多用例都可以被映射。",
        "In principle, it is also possible to have complex parameter types provided via the Dependency Injection container from the `http` scope, since these are also available in the route function or method. However, this has the disadvantage that no asynchronous function calls can be used, since the DI container is synchronous throughout.": "原则上，也可以通过依赖注入容器从`http`范围提供复杂的参数类型，因为这些参数在路由函数或方法中也是可用的。然而，这有一个缺点，就是不能使用异步函数调用，因为DI容器自始至终都是同步的。",
        "RPC": "RPC",
        "RPC, which stands for Remote Procedure Call, allows functions on a remote server to be called as if they were local functions. Unlike HTTP client-server communication, which uses HTTP methods and a URL for mapping, RPC uses the function name for mapping. The data to be sent is passed as normal function arguments, and the result of the function call on the server is sent back to the client.": "RPC是远程过程调用的缩写，它允许远程服务器上的函数被调用，就像它们是本地函数一样。与使用HTTP方法和URL进行映射的HTTP客户-服务器通信不同，RPC使用函数名称进行映射。要发送的数据作为正常的函数参数被传递，而服务器上的函数调用结果被送回客户端。",
        "The advantage of RPC is that the client-server abstraction is lightweight because it does not work with headers, URLs, query strings, or similar. The disadvantage is that functions on a server via RPC cannot be easily called by a browser and often require a specific client.": "RPC的优点是客户端-服务器的抽象是轻量级的，因为它不与头文件、URL、查询字符串或类似的东西一起工作。缺点是，通过RPC在服务器上的功能不能轻易被浏览器调用，往往需要一个特定的客户端。",
        "One key feature of RPC is that the data between the client and server is automatically serialized and deserialized. Therefore, type-safe RPC clients are usually possible. Some RPC frameworks force users to provide types (parameter types and return types) in a specific format. This can be in the form of a DSL such as Protocol Buffers for gRPC and GraphQL or a JavaScript schema builder. Additional data validation can also be provided by the RPC framework but is not supported by all.": "RPC的一个关键特征是，客户端和服务器之间的数据会自动序列化和反序列化。因此，类型安全的RPC客户端通常是可能的。一些RPC框架强迫用户以特定的格式提供类型（参数类型和返回类型）。这可以是DSL的形式，如用于gRPC和GraphQL的Protocol Buffers或JavaScript模式生成器。额外的数据验证也可以由RPC框架提供，但不是所有的框架都支持。",
        "Deepkit RPC extracts types from the TypeScript code itself, so it is not necessary to use a code generator or define them manually. Deepkit supports automatic serialization and deserialization of parameters and results. Once additional restrictions are defined in Validation, they are automatically validated. This makes communication via RPC extremely type-safe and efficient. The support for streaming via `rxjs` in Deepkit RPC makes this RPC framework a suitable tool for real-time communication.": "Deepkit RPC 从 TypeScript 代码本身中提取类型，因此没有必要使用代码生成器或手动定义它们。Deepkit支持参数和结果的自动序列化和反序列化。一旦在验证中定义了额外的限制，它们就会自动得到验证。这使得通过RPC进行的通信极为类型安全和高效。Deepkit RPC中通过`rxjs`对流媒体的支持使这个RPC框架成为实时通信的合适工具。",
        "To illustrate the concept behind RPC, consider the following code:": "为了说明RPC背后的概念，考虑以下代码：",
        "A method like hello is implemented just like a normal function within a class on the server and can be called by a remote client.": "像hello这样的方法就像服务器上的类中的普通函数一样被实现，可以被远程客户端调用。",
        "Because RPC is fundamentally based on asynchronous communication, communication is usually over HTTP but can also be over TCP or WebSockets. This means that all function calls in TypeScript are converted to a `Promise` themselves. The result can be received asynchronously with a corresponding `await`.": "因为RPC从根本上是基于异步通信的，通信通常是通过HTTP，但也可以是通过TCP或WebSockets。这意味着TypeScript中的所有函数调用都被转换为一个`Promise`本身。结果可以通过相应的 \"await \"异步接收。",
        "When a project uses TypeScript on both the client (usually frontend) and server (backend), it is called Isomorphic TypeScript. A type-safe RPC framework based on TypeScript's types is particularly beneficial for such a project because types can be shared between the client and server.": "当一个项目在客户端（通常是前端）和服务器（后端）都使用TypeScript时，它被称为Isomorphic TypeScript。基于TypeScript的类型安全的RPC框架对这样的项目特别有利，因为类型可以在客户端和服务器之间共享。",
        "To take advantage of this, types that are used on both sides should be outsourced to their own file or package. Importing on the respective side then puts them back together.": "为了利用这一点，在两边都使用的类型应该外包给它们自己的文件或包。然后在各自的一方导入，再把它们放回一起。",
        "Backward compatibility can be implemented in the same way as with a normal local API: either new parameters are marked as optional or a new method is added.": "向后兼容可以用与普通本地API相同的方式实现：要么将新的参数标记为可选，要么添加一个新的方法。",
        "To use Deepkit RPC, it is necessary to have `@deepkit/type` correctly installed because it is based on Runtime Types. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "要使用Deepkit RPC，必须正确安装`@deepkit/type`，因为它是基于Runtime Types的。参见xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation]。",
        "Once this is successfully done, `@deepkit/rpc` or the Deepkit Framework, which already uses the library under the hood, can be installed.": "一旦成功完成，就可以安装`@deepkit/rpc`或Deepkit框架，它已经在引擎盖下使用了该库。",
        "Note that controller classes in `@deepkit/rpc` are based on TypeScript decorators, and this feature must be enabled with experimentalDecorators.": "请注意，`@deepkit/rpc`中的控制器类是基于TypeScript装饰器的，这个功能必须用experimentalDecorators启用。",
        "The `@deepkit/rpc` package must be installed on the server and client if they have their own package.json.": "`@deepkit/rpc`包必须安装在服务器和客户端，如果它们有自己的package.json。",
        "To communicate over TCP with the server, the `@deepkit/rpc-tcp` package must be installed on the client and server.": "要通过TCP与服务器通信，必须在客户端和服务器上安装`@deepkit/rpc-tcp`包。",
        "For WebSocket communication, the package is also required on the server. The client in the browser, on the other hand, uses WebSocket from the official standard.": "对于WebSocket通信，服务器上也需要该软件包。而浏览器中的客户端则使用官方标准中的WebSocket。",
        "If the client is also to be used in an environment where WebSocket is not available (for example, NodeJS), the package ws is required in the client.": "如果客户端也要在没有WebSocket的环境中使用（例如NodeJS），则客户端中需要使用ws包。",
        "Below is a fully functional example based on WebSockets and the low-level API of @deepkit/rpc. When using the Deepkit Framework, controllers are provided via app modules, and an RpcKernel is not instantiated manually.": "下面是一个基于WebSockets和@deepkit/rpc的低级API的全功能例子。在使用Deepkit框架时，控制器是通过应用模块提供的，而RpcKernel则不需要手动实例化。",
        "_File: server.ts_": "文件：server.ts_",
        "_File: client.ts_": "文件：client.ts_",
        "Server Controller": "服务器控制器",
        "The term \"Procedure\" in Remote Procedure Call is also commonly referred to as an \"Action\". An Action is a method defined in a class and marked with the `@rpc.action` decorator. The class itself is marked as a Controller with the `@rpc.controller` decorator and given a unique name. This name is then referenced in the client to address the correct controller. Multiple controllers can be defined and registered as needed.": "远程过程调用中的 \"过程 \"通常也被称为 \"动作\"。动作是定义在一个类中的方法，用`@rpc.action`装饰器来标记。类本身被标记为一个控制器，并被赋予一个唯一的名字，即`@rpc.controller`装饰器。这个名字会在客户端被引用，以解决正确的控制器。可以根据需要定义和注册多个控制器。",
        "Only methods marked as `@rpc.action()` can be called by a client.": "只有标记为\"@rpc.action() \"的方法可以被客户端调用。",
        "Types must be explicitly specified and cannot be inferred. This is important because the serializer needs to know exactly what the types look like in order to convert them into binary data (BSON) or JSON which is then sent over the wire.": "类型必须是明确指定的，不能推断。这一点很重要，因为序列化器需要确切地知道类型是什么样子的，以便将它们转换成二进制数据（BSON）或JSON，然后通过电线发送。",
        "Client Controller": "客户端控制器",
        "The normal flow in RPC is that the client can execute functions on the server. However, in Deepkit RPC, it is also possible for the server to execute functions on the client. To allow this, the client can also register a controller.": "RPC中的正常流程是，客户端可以在服务器上执行函数。然而，在Deepkit RPC中，服务器也有可能在客户端上执行功能。为了实现这一点，客户端还可以注册一个控制器。",
        "Controller classes are managed by the Dependency Injection Container from `@deepkit/injector`. When using the Deepkit Framework, these controllers automatically have access to the providers of the modules that provide the controller.": "控制器类由`@deepkit/injector`的依赖注入容器管理。当使用Deepkit框架时，这些控制器会自动访问提供控制器的模块的提供者。",
        "In the Deepkit Framework, controllers are instantiated in the Dependency Injection Scope `rpc`, allowing all controllers to automatically access various providers from this scope. These additional providers are `HttpRequest` (optional), `RpcInjectorContext`, `SessionState`, `RpcKernelConnection`, and `ConnectionWriter`.": "在Deepkit框架中，控制器被实例化在依赖性注入范围`rpc`中，允许所有控制器自动访问这个范围中的各种提供者。这些额外的提供者是`HttpRequest`（可选）、`RpcInjectorContext`、`SessionState`、`RpcKernelConnection`和`ConnectionWriter`。",
        "However, when an `RpcKernel` is manually instantiated, a DI Container can also be passed. The RPC Controller will then be instantiated through this DI Container. This is useful if you want to use `@deepkit/rpc` in a non-Deepkit Framework environment, like Express.js.": "然而，当一个 \"RpcKernel \"被手动实例化时，也可以传递一个DI容器。然后RPC控制器将通过这个DI容器被实例化。如果你想在非Deepkit框架环境中使用`@deepkit/rpc`，比如Express.js，这就很有用。",
        "See [Dependency Injection](xref:dependency-injection.adoc) to learn more.": "参见[依赖注入](xref:dependency-injection.adoc)以了解更多。",
        "Nominal Types": "名义类型",
        "When the client receives data from a function call, it has first been serialized on the server and then deserialized on the client. If the function's return type includes classes, these classes will be reconstructed on the client side, but they will lose their nominal identity and associated methods. To address this issue, register the classes as nominal types with unique IDs/names. This approach should be applied to all classes used within an RPC-API.": "当客户端收到来自一个函数调用的数据时，它首先在服务器上被序列化，然后在客户端被反序列化。如果函数的返回类型包括类，这些类将在客户端被重构，但它们将失去它们的名义身份和相关方法。为了解决这个问题，将类注册为具有唯一ID/名称的名义类型。这种方法应该应用于RPC-API中使用的所有类。",
        "To register a class, use the decorator `@entity.name('id')`.": "要注册一个类，使用装饰器`@entity.name('id')`。",
        "Once this class is used as the result of a function, its identity will be preserved.": "一旦这个类被用作一个函数的结果，它的身份就会被保留下来。",
        "Error Forwarding": "错误转发",
        "RPC functions can throw errors. By default, these errors are forwarded to the client and thrown again. If you are using custom error classes, you should enable their nominal type. See [RPC Nominal Types](xref:rpc.adoc#rpc-nominal-types) for more information": "RPC函数可以抛出错误。默认情况下，这些错误被转发到客户端并再次抛出。如果你使用自定义的错误类，你应该启用其名义类型。参见[RPC名义类型](xref:rpc.adoc#rpc-nominal-types)获取更多信息",
        "By default, all RPC functions can be called from any client, and the peer-to-peer communication feature is enabled. To precisely control which client is allowed to do what, you can override the `RpcKernelSecurity` class.": "默认情况下，所有的RPC函数可以从任何客户端调用，并且启用了点对点通信功能。为了精确控制哪个客户端被允许做什么，你可以覆盖`RpcKernelSecurity`类。",
        "To use this, pass the provider to the `RpcKernel`:": "要使用这个，请将提供者传递给`RpcKernel`：",
        "Or, in the case of a Deepkit Framework application, override the `RpcKernelSecurity` class with a provider in the app:": "或者，在Deepkit Framework应用程序中，用应用程序中的提供者覆盖`RpcKernelSecurity`类：",
        "Authentication / Session": "认证/会话",
        "By default, the `Session` object is an anonymous session, meaning the client has not authenticated. When the client wants to authenticate, the `authenticate` method is called. The token received by the `authenticate` method comes from the client and can have any value.": "默认情况下，`Session`对象是一个匿名会话，意味着客户端没有进行认证。当客户端想要认证时，会调用`authenticate'方法。`authenticate`方法收到的令牌来自客户端，可以有任何值。",
        "Once the client sets a token, the authentication is executed when the first RPC function is called or when `client.connect()` is manually invoked.": "一旦客户端设置了一个令牌，当第一个RPC函数被调用或`client.connect()`被手动调用时，就会执行认证。",
        "In this case, `RpcKernelSecurity.authenticate` receives the token `123456789` and can return a different session accordingly. The returned session is then passed to all other methods like `hasControllerAccess`.": "在这种情况下，`RpcKernelSecurity.authenticate`会收到令牌`123456789`，并可以相应地返回一个不同的会话。然后返回的会话被传递给所有其他方法，如`hasControllerAccess`。",
        "Controller Access": "控制器访问",
        "The `hasControllerAccess` method determines whether a client is allowed to execute a specific RPC function. This method is called for every RPC function invocation. If it returns `false`, access is denied, and an error is thrown on the client.": "`hasControllerAccess`方法决定了客户端是否被允许执行特定的RPC函数。每个RPC函数的调用都会调用这个方法。如果它返回 \"false\"，则拒绝访问，并向客户端抛出一个错误。",
        "The `RpcControllerAccess` contains valuable information about the RPC function:": "`RpcControllerAccess`包含关于RPC功能的宝贵信息：",
        "Groups and additional data can be changed via the decorator `@rpc.action()`:": "组和其他数据可以通过装饰器`@rpc.action()`来改变：",
        "Transform Error": "变形误差",
        "Since thrown errors are automatically forwarded to the client with all its information like the error message and also the stacktrace, this could unwantedly publish sensitive information. To change this, in the method `transformError` the thrown error can be modified.": "由于抛出的错误会自动转发到客户端，包括错误信息和堆栈跟踪等所有信息，这可能会不必要地公布敏感信息。为了改变这种情况，在方法`transformError`中，可以修改抛出的错误。",
        "Note that once the error is converted to a generic `error`, the complete stack trace and the identity of the error are lost. Accordingly, no `instanceof` checks can be used on the error in the client.": "请注意，一旦错误被转换为通用的`error'，完整的堆栈跟踪和错误的身份就会丢失。因此，在客户端不能对该错误使用`instanceof`检查。",
        "If Deepkit RPC is used between two microservices, and thus the client and server are under complete control of the developer, then transforming the error is rarely necessary. If, on the other hand, the client is running in a browser with an unknown, then care should be taken in `transformError` as to what information is to be disclosed. If in doubt, each error should be transformed with a generic `Error` to ensure that no internal details are leaked. Logging the error would then be a good idea at this point.": "如果Deepkit RPC是在两个微服务之间使用的，因此客户端和服务器完全在开发者的控制之下，那么转化错误就很少有必要。另一方面，如果客户端在一个未知的浏览器中运行，那么在`transformError'中应注意要披露哪些信息。如果有疑问，每个错误都应该用一个通用的`Error'进行转换，以确保没有内部细节被泄露。在这一点上，记录错误是一个好主意。",
        "When the Deepkit framework is used, the class is instantiated by the Dependency Injection container and thus automatically has access to all other providers in the application.": "当使用Deepkit框架时，该类被依赖性注入容器实例化，因此自动访问了应用程序中的所有其他提供者。",
        "See also xref:dependency-injection.adoc[Dependency Injection].": "另见xref:dependency-injection.adoc[依赖性注入]。",
        "Streaming RxJS": "流动的RxJS",
        "Transport Protocol": "运输协议",
        "Deepkit RPC supports several transport protocols. WebSockets is the protocol that has the best compatibility (since browsers support it) while supporting all features like streaming. TCP is usually faster and is great for communication between servers (microservices) or non-browser clients. But WebSockets work well for server to server communication as well.": "Deepkit RPC支持几种传输协议。WebSockets是兼容性最好的协议（因为浏览器支持它），同时支持流媒体等所有功能。TCP通常更快，非常适合服务器（微服务）或非浏览器客户端之间的通信。但是WebSockets对于服务器与服务器之间的通信也很适用。",
        "Deepkit's RPC HTTP protocol is a variant that is particularly easy to debug in the browser, as each function call is an HTTP request, but has its limitations such as no support for RxJS streaming.": "Deepkit的RPC HTTP协议是一个变种，在浏览器中特别容易调试，因为每个函数调用都是一个HTTP请求，但也有其局限性，如不支持RxJS流。",
        "TODO: Not implemented yet.": "TODO: 还没有实施。",
        "WebSockets": "网络套接字",
        "@deepkit/rpc-tcp `RpcWebSocketServer` and Browser WebSocket or Node `ws` package.": "@deepkit/rpc-tcp `RpcWebSocketServer`和浏览器WebSocket或Node `ws`包。",
        "TCP": "TCP",
        "@deepkit/rpc-tcp `RpcNetTcpServer` and `RpcNetTcpClientAdapter`": "@deepkit/rpc-tcp `RpcNetTcpServer`和`RpcNetTcpClientAdapter`。",
        "Peer To Peer": "点对点",
        "Deepkit provides an ORM that allows databases to be accessed in a modern way.": "Deepkit提供了一个ORM，允许以现代方式访问数据库。",
        "Entities are simply defined using TypeScript types:": "实体是使用TypeScript类型简单定义的：",
        "Any TypeScript types and validation decorators from Deepkit can be used to fully define the entity.": "可以使用Deepkit的任何TypeScript类型和验证装饰器来完全定义实体。",
        "The entity type system is designed in such a way that these types or classes can also be used in other areas such as HTTP routes, RPC actions or frontend. This prevents, for example, that one has defined a user several times distributed in the entire application.": "实体类型系统的设计方式是，这些类型或类也可以在其他领域使用，如HTTP路由、RPC动作或前端。这就防止了，例如，一个人定义了一个用户，在整个应用中分布了好几次。",
        "Since Deepkit ORM is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于Deepkit ORM是基于Runtime Types的，所以有必要正确安装`@deepkit/type`。参见xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation]。",
        "If this is done successfully, `@deepkit/orm` itself and a database adapter can be installed.": "如果这样做成功了，就可以安装`@deepkit/orm`本身和一个数据库适配器。",
        "If classes are to be used as entities, `experimentalDecorators` must be enabled in tsconfig.json:": "如果要将类作为实体使用，必须在tsconfig.json中启用`experimentalDecorators`：",
        "Once the library is installed, a database adapter can be installed and the API of it can be used directly.": "一旦安装了这个库，就可以安装一个数据库适配器，可以直接使用它的API。",
        "SQLite": "SQLite",
        "MySQL": "ǞǞǞ",
        "Postgres": "淘宝网",
        "MongoDB": "梦之城_梦之城娱乐_梦之城国际娱乐_梦之城国际娱乐平台",
        "Primarily the `Database` object is used. Once instantiated, it can be used throughout the application to query or manipulate data. The connection to the database is initialized lazy.": "主要是使用`Database`对象。一旦实例化，它可以在整个应用程序中被用来查询或处理数据。与数据库的连接被初始化为懒惰。",
        "The `Database` object is passed an adapter, which comes from the database adapters libraries.": "`Database`对象被传递给一个适配器，它来自数据库适配器库。",
        "Connection": "连接",
        "Read Replica": "阅读复制品",
        "An entity is either a class or an object literal (interface) and always has a primary key.": "一个实体要么是一个类，要么是一个对象字面（接口），并且总是有一个主键。",
        "The entity is decorated with all necessary information using type decorators from `@deepkit/type`. For example, a primary key is defined as well as various fields and their validation constraints. These fields reflect the database structure, usually a table or a collection.": "使用`@deepkit/type`中的类型装饰器，对实体进行了所有必要的信息装饰。例如，定义了一个主键，以及各种字段和它们的验证约束。这些字段反映了数据库的结构，通常是一个表或一个集合。",
        "Through special type decorators like `Mapped<'name'>` a field name can also be mapped to another name in the database.": "通过特殊的类型装饰器，如 \"Mapped<'name'>\"，一个字段名也可以被映射到数据库中的另一个名字。",
        "Klasse": "级别",
        "Interface": "介面",
        "Primitives": "基本原理",
        "Primitive data types like String, Number (bigint), and Boolean are mapped to common database types. Only the TypeScript type is used.": "原始数据类型如String、Number（bigint）和Boolean被映射到常见的数据库类型。只有TypeScript的类型被使用。",
        "Primary Key": "主键",
        "Each entity needs exactly one primary key. Multiple primary keys are not supported.": "每个实体只需要一个主键。不支持多主键。",
        "The base type of a primary key can be arbitrary. Often a number or UUID is used.": "一个主键的基本类型可以是任意的。通常使用一个数字或UUID。",
        "For MongoDB the MongoId or ObjectID is often used.": "对于MongoDB，通常使用MongoId或ObjectID。",
        "For numbers `AutoIncrement` can be used.": "对于数字，可以使用 \"自动增量\"。",
        "Auto Increment": "自动增量",
        "Fields that should be automatically incremented during insertion are annotated with the `AutoIncrement` decorator. All adapters support auto-increment values. The MongoDB adapter uses an additional collection to keep track of the counter.": "在插入过程中应该自动递增的字段用`AutoIncrement`装饰器来注释。所有适配器都支持自动递增值。MongoDB适配器使用一个额外的集合来跟踪该计数器。",
        "An auto-increment field is an automatic counter and can only be applied to a primary key. The database automatically ensures that an ID is used only once.": "自动递增字段是一个自动计数器，只能应用于一个主键。数据库会自动确保一个ID只使用一次。",
        "Fields that should be of type UUID (v4) are annotated with the decorator UUID. The runtime type is `string` and mostly binary in the database itself. Use the `uuid()` function to create a new UUID v4.": "应该是UUID（v4）类型的字段用装饰器UUID来注释。运行时的类型是`string`，在数据库本身中大多是二进制的。使用`uuid()`函数来创建一个新的UUID v4。",
        "MongoDB ObjectID": "MongoDB ObjectID",
        "Fields that should be of type ObjectID in MongoDB are annotated with the decorator `MongoId`. The runtime type is `string` and in the database itself `ObjectId` (binary).": "在MongoDB中应该是ObjectID类型的字段用装饰器`MongoId`来注释。运行时的类型是`string`，而在数据库中则是`ObjectId`（二进制）。",
        "MongoID fields automatically get a new value when inserted. It is not mandatory to use the field name `_id`. It can have any name.": "MongoID字段在插入时自动获得一个新值。使用字段名`_id`并不是强制性的。它可以有任何名字。",
        "Optional / Nullable": "可选/可忽略不计",
        "Optional fields are declared as TypeScript type with `title?: string` or `title: string | null`. You should use only one variant of this, usually the optional `?` syntax, which works with `undefined`.": "可选字段被声明为TypeScript类型，有`title?: string`或`title: string | null`。你应该只使用其中的一个变体，通常是可选的`?`语法，它与`undefined`一起工作。",
        "Both variants result in the database type being `NULLABLE` for all SQL adapters. So the only difference between these decorators is that they represent different values at runtime.": "这两种变体都会导致所有SQL适配器的数据库类型为`NULLABLE`。所以这些装饰器的唯一区别是它们在运行时代表不同的值。",
        "In the following example, the changed field is optional and can therefore be undefined at runtime, although it is always represented as NULL in the database.": "在下面的例子中，改变的字段是可选的，因此在运行时可以不定义，尽管它在数据库中总是表示为NULL。",
        "This example shows how the nullable type works. NULL is used both in the database and in the javascript runtime. This is more verbose than `modified?: Date` and is not commonly used.": "这个例子显示了nullable类型是如何工作的。NULL在数据库和javascript的运行中都被使用。这比`modified?Date`，而且不常用。",
        "Database Type Mapping": "数据库类型映射",
        "With `DatabaseField` it is possible to map a field to any database type. The type must be a valid SQL statement that is passed unchanged to the migration system.": "通过`DatabaseField`，可以将一个字段映射到任何数据库类型。该类型必须是一个有效的SQL语句，并以不变应万变地传递给迁移系统。",
        "To map a field for a specific database, either `SQLite`, `MySQL`, or `Postgres` can be used.": "要为一个特定的数据库映射一个字段，可以使用`SQLite`、`MySQL`或`Postgres`。",
        "Embedded Types": "嵌入式类型",
        "Default Values": "默认值",
        "Default Expressions": "默认表达式",
        "Complex Types": "复杂类型",
        "Exclude": "不包括",
        "Database Specific Column Types": "数据库特定的列类型",
        "Session / Unit Of Work": "会议/工作单元",
        "A session is something like a unit of work. It keeps track of everything you do and automatically records the changes whenever `commit()` is called. It is the preferred way to execute changes in the database because it bundles statements in a way that makes it very fast. A session is very lightweight and can easily be created in a request-response lifecycle, for example.": "会话是类似于一个工作单位的东西。它跟踪你所做的一切，并在调用`commit()`时自动记录这些变化。它是在数据库中执行变化的首选方式，因为它以一种使其非常快的方式捆绑语句。会话是非常轻量级的，可以很容易地在请求-响应的生命周期中创建，例如：。",
        "Add new instance to the session with `session.add(T)` or remove existing instances with `session.remove(T)`. Once you are done with the Session object, simply dereference it everywhere so that the garbage collector can remove it.": "用`session.add(T)`向会话添加新的实例，或用`session.remove(T)`删除现有的实例。一旦你完成了对Session对象的处理，只需在各处取消对它的引用，这样垃圾回收器就可以将其删除。",
        "Changes are automatically detected for entity instances fetched via the Session object.": "对于通过Session对象获取的实体实例，会自动检测到变化。",
        "Identity Map": "身份地图",
        "Sessions provide an identity map that ensures there is only ever one javascript object per database entry. For example, if you run `session.query(User).find()` twice within the same session, you get two different arrays, but with the same entity instances in them.": "会话提供了一个身份映射，确保每个数据库条目只有一个JavaScript对象。例如，如果你在同一个会话中运行两次`session.query(User).find()`，你会得到两个不同的数组，但其中有相同的实体实例。",
        "If you add a new entity with `session.add(entity1)` and retrieve it again, you get exactly the same entity instance `entity1`.": "如果你用`session.add(entity1)`添加一个新的实体，并再次检索它，你会得到完全相同的实体实例`entity1`。",
        "Important: Once you start using sessions, you should use their `session.query` method instead of `database.query`. Only session queries have the identity mapping feature enabled.": "重要的是：一旦你开始使用会话，你应该使用其`session.query`方法，而不是`database.query`。只有会话查询才有身份映射的功能。",
        "Change Detection": "变化检测",
        "Request/Response": "请求/回应",
        "Query": "查询",
        "A query is an object that describes how to retrieve or modify data from the database. It has several methods to describe the query and termination methods that execute them. The database adapter can extend the query API in many ways to support database specific features.": "查询是一个描述如何从数据库检索或修改数据的对象。它有几个方法来描述查询和执行查询的终止方法。数据库适配器可以以多种方式扩展查询API，以支持数据库的特定功能。",
        "You can create a query using `Database.query(T)` or `Session.query(T)`. We recommend Sessions as it improves performance.": "你可以使用`Database.query(T)`或`Session.query(T)`创建一个查询。我们推荐Sessions，因为它可以提高性能。",
        "Filter": "过滤器",
        "A filter can be applied to limit the result set.": "可以应用一个过滤器来限制结果集。",
        "Equal": "平等",
        "Greater / Smaller": "更大/更小",
        "Grouping AND/OR": "分组 AND/OR",
        "In": "在",
        "Select": "选择",
        "To narrow down the fields to be received from the database, `select('field1')` can be used.": "为了缩小从数据库接收的字段，可以使用`select('field1')`。",
        "It is important to note that as soon as the fields are narrowed down using `select`, the results are no longer instances of the entity, but only object literals.": "值得注意的是，一旦使用`select`缩小字段范围，结果就不再是实体的实例，而只是对象字面。",
        "Order": "秩序",
        "With `orderBy(field, order)` the order of the entries can be changed.": "通过`orderBy(field, order)`，可以改变条目的顺序。",
        "Several times `orderBy` can be executed to refine the order more and more.": "可以执行几次`orderBy'，使订单越来越细化。",
        "Pagination": "分页",
        "The `itemsPerPage()` and `page()` methods can be used to paginate the results. Page starts at 1.": "`itemsPerPage()`和`page()`方法可以用来给结果分页。页数从1开始。",
        "With the alternative methods `limit` and `skip` you can paginate manually.": "使用替代方法`limit`和`skip`，你可以手动分页。",
        "Join": "加盟",
        "By default, references from the entity are neither included in queries nor loaded. To include a join in the query without loading the reference, use `join()` (left join) or `innerJoin()`. To include a join in the query and load the reference, use `joinWith()` or `innerJoinWith()`.": "默认情况下，实体的引用既不包括在查询中，也不加载。要在查询中包含一个连接而不加载引用，请使用`join()`（左连接）或`innerJoin()`。要在查询中包含一个连接并加载引用，请使用`joinWith()`或`innerJoinWith()`。",
        "All the following examples assume these model schemas:": "下面所有的例子都假设这些模型模式：",
        "To modify join queries, use the same methods, but with the `use` prefix: `useJoin`, `useInnerJoin`, `useJoinWith` or `useInnerJoinWith`. To end the join query modification, use `end()` to get back the parent query.": "要修改连接查询，使用相同的方法，但要使用`use`前缀：`useJoin`、`useInnerJoin`、`useJoinWith`或`useInnerJoinWith`。要结束连接查询的修改，使用`end()`来取回父查询。",
        "Aggregation": "聚合",
        "Aggregation methods allow you to count records and aggregate fields.": "聚合方法允许你计算记录和聚合字段。",
        "The following examples assume this model scheme:": "下面的例子假设了这个模型方案：",
        "`groupBy` allows to group the result by the specified field.": "`groupBy`允许按指定字段对结果进行分组。",
        "There are several aggregation methods: `withSum`, `withAverage`, `withCount`, `withMin`, `withMax`, `withGroupConcat`. Each requires a field name as the first argument and an optional second argument to change the alias.": "有几种聚合方法：`withSum`, `withAverage`, `withCount`, `withMin`, `withMax`, `withGroupConcat`。每个方法都需要一个字段名作为第一个参数和一个可选的第二个参数来改变别名。",
        "Returning": "返回",
        "With `returning` additional fields can be requested in case of changes via `patch` and `delete`.": "通过 \"returning\"，在通过 \"patch \"和 \"delete \"进行修改的情况下，可以要求增加字段。",
        "Caution: Not all database adapters return fields atomically. Use transactions to ensure data consistency.": "请注意：并非所有的数据库适配器都以原子方式返回字段。使用事务来确保数据的一致性。",
        "Find": "查找",
        "Returns an array of entries matching the specified filter.": "返回匹配指定过滤器的条目数组。",
        "FindOne": "找到一个",
        "Returns an item that matches the specified filter.": "返回一个符合指定过滤器的项目。",
        "If no item is found, an `ItemNotFound` error is thrown.": "如果没有找到项目，就会抛出一个`ItemNotFound'错误。",
        "FindOneOrUndefined": "查找一个或未定义",
        "Returns an entry that matches the specified filter.": "返回一个符合指定过滤器的条目。",
        "If no entry is found, undefined is returned.": "如果没有找到条目，则返回未定义。",
        "FindField": "查找字段",
        "Returns a list of a field that match the specified filter.": "返回一个符合指定过滤器的字段的列表。",
        "FindOneField": "查找一个字段",
        "If no entry is found, an `ItemNotFound` error is thrown.": "如果没有找到条目，就会抛出一个`ItemNotFound'错误。",
        "Patch": "补丁",
        "Patch is a change query that patches the records described in the query. The methods": "补丁是一个变更查询，对查询中描述的记录进行补丁。这些方法",
        "`patchOne` and `patchMany` finish the query and execute the patch.": "`patchOne`和`patchMany`完成查询并执行补丁。",
        "`patchMany` changes all records in the database that match the specified filter. If no filter is set, the whole table will be changed. Use `patchOne` to change only one entry at a time.": "`patchMany`改变数据库中所有符合指定过滤器的记录。如果没有设置过滤器，整个表将被改变。使用`patchOne`一次只改变一个条目。",
        "Delete": "删除",
        "`deleteMany` deletes all entries in the database that match the specified filter.": "`deleteMany`删除数据库中所有符合指定过滤器的条目。",
        "If no filter is set, the whole table will be deleted. Use `deleteOne` to delete only one entry at a time.": "如果没有设置过滤器，整个表将被删除。使用`deleteOne`，一次只删除一个条目。",
        "Has": "有",
        "Returns whether at least one entry exists in the database.": "返回数据库中是否存在至少一个条目。",
        "Count": "计数",
        "Returns the number of entries.": "返回条目的数量。",
        "Lift": "电梯",
        "Lifting a query means adding new functionality to it. This is usually used either by plugins or complex architectures to split larger query classes into several convenient, reusable classes.": "提升一个查询意味着向它添加新的功能。这通常由插件或复杂的架构来使用，将较大的查询类分割成几个方便、可重用的类。",
        "Repository": "存储库",
        "Relations": "关系",
        "Relationships allow you to connect two entities in a certain way. This is usually done in databases using the concept of foreign keys. Deepkit ORM supports relations for all official database adapters.": "关系允许你以某种方式连接两个实体。这通常是在数据库中使用外键的概念完成的。Deepkit ORM支持所有官方数据库适配器的关系。",
        "A relation is annotated with the `reference` decorator. Usually a relation also has a reverse relation, which is annotated with the `BackReference` type, but is only needed if the reverse relation is to be used in a database query. Back references are only virtual.": "一个关系用`reference`装饰器来注解。通常一个关系也有一个反向关系，它被注释为`BackReference`类型，但是只有在反向关系被用于数据库查询时才需要。反向引用只是虚拟的。",
        "One To Many": "一对多",
        "The entity that stores a reference is usually referred to as the `owning page` or the one that `owns` the reference. The following code shows two entities with a one-to-many relationship between `User` and `Post`. This means that one `User` can have multiple `Post`. The `post` entity has the `post->user` relationship. In the database itself there is now a field `Post. \"author\"` that contains the primary key of `User`.": "存储一个引用的实体通常被称为 \"拥有页 \"或 \"拥有 \"引用的实体。下面的代码显示了两个实体，在`User'和`Post'之间存在一对多的关系。这意味着一个`用户'可以有多个`帖子'。`post`实体有`post->user`关系。在数据库本身，现在有一个字段`Post.\"author\"`，包含`User`的主键。",
        "References are not selected in queries by default. See <<database-join>> for details.": "默认情况下，查询中不选择引用。详见<<数据库连接>>。",
        "Many To One": "多对一",
        "A reference usually has a reverse reference called many-to-one. It is only a virtual reference, since it is not reflected in the database itself. A back reference is annotated `BackReference` and is mainly used for reflection and query joins. If you add a `BackReference` from `User` to `Post`, you can join `Post` directly from `User` queries.": "一个引用通常有一个叫做多对一的反向引用。它只是一个虚拟引用，因为它没有反映在数据库本身。一个反向引用被注解为`BackReference`，主要用于反射和查询连接。如果你从 \"用户 \"到 \"岗位 \"添加一个 \"反向引用\"，你可以直接从 \"用户 \"查询中加入 \"岗位\"。",
        "Many To Many": "多对多",
        "A many-to-many relationship allows you to associate many records with many others. For example, it can be used for users in groups. A user can be in none, one or many groups. Consequently, a group can contain 0, one or many users.": "多对多的关系允许你将许多记录与其他许多记录联系起来。例如，它可以用于组中的用户。一个用户可以不在一个、一个或多个组中。因此，一个组可以包含0、1或许多用户。",
        "Many-to-many relationships are usually implemented using a pivot entity. The pivot entity contains the actual own references to two other entities, and these two entities have back references to the pivot entity.": "多对多的关系通常使用一个枢轴实体来实现。支点实体包含对其他两个实体的实际自己的引用，而这两个实体对支点实体有反向引用。",
        "With these entities, you can now create users and groups and connect them to the pivot entity. By using a back reference in User, we can retrieve the groups directly with a User query.": "有了这些实体，你现在可以创建用户和组，并将它们连接到透视实体。通过使用User中的反向引用，我们可以用User查询直接检索组。",
        "To unlink a user from a group, the UserGroup record is deleted:": "要解除一个用户与一个组的联系，需要删除UserGroup的记录：",
        "One To One": "一对一",
        "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT": "在删除/更新时：限制|级联|设置为空|没有行动|设置为默认",
        "Inheritance": "继承性",
        "Table Per Class": "每类表",
        "Single Table Inheritance": "单一表的继承性",
        "Index": "索引",
        "Case Sensitivity": "案例敏感度",
        "Character Sets": "字符集",
        "Collations": "斠定",
        "Batching": "分流",
        "Caching": "缓存",
        "Multitenancy": "多租户",
        "Events are a way to hook into Deepkit ORM and allow you to write powerful plugins. There are two categories of events: Query events and Unit-of-Work events. Plugin authors typically use both to support both ways of manipulating data.": "事件是一种与Deepkit ORM挂钩的方式，可以让你编写强大的插件。有两类事件：查询事件和工作单元事件。插件作者通常使用这两种方式来支持操纵数据的两种方式。",
        "Events are registered via `Database.listen` un an event token. Short-lived event listeners can also be registered on sessions.": "事件是通过`Database.listen`注册的，没有一个事件标记。短暂的事件监听器也可以在会议上注册。",
        "Query Events": "查询事件",
        "Query events are triggered when a query is executed via `Database.query()` or `Session.query()`.": "当通过`Database.query()`或`Session.query()`执行查询时，查询事件被触发。",
        "Each event has its own additional properties such as the type of entity, the query itself and the database session. You can override the query by setting a new query to `Event.query`.": "每个事件都有自己的附加属性，如实体的类型、查询本身和数据库会话。你可以通过设置一个新的查询到`Event.query`来覆盖查询。",
        "\"Query\" has several event tokens:": "\"查询 \"有几个事件令牌：",
        "Unit Of Work Events": "工作单元活动",
        "Unit-of-work events are triggered when a new session submits changes.": "当一个新的会话提交更改时，工作单元事件被触发。",
        "Transactions": "交易",
        "A transaction is a sequential group of statements, queries, or operations such as select, insert, update, or delete that are executed as a single unit of work that can be committed or rolled back.": "事务是一组连续的语句、查询或操作，如选择、插入、更新或删除，作为一个工作单位执行，可以提交或回滚。",
        "Deepkit supports transactions for all officially supported databases. By default, no transactions are used for any query or database session. To enable transactions, there are two main methods: sessions and callback.": "Deepkit支持所有官方支持的数据库的交易。默认情况下，任何查询或数据库会话都不使用事务。要启用事务，主要有两种方法：会话和回调。",
        "Session Transactions": "会议交易",
        "You can start and assign a new transaction for each session you create. This is the preferred way of interacting with the database, as you can easily pass on the Session object and all queries instantiated by this session will be automatically assigned to its transaction.": "你可以为你创建的每个会话启动和分配一个新的事务。这是与数据库交互的首选方式，因为你可以很容易地传递会话对象，这个会话实例化的所有查询都将自动分配给它的事务。",
        "A typical pattern is to wrap all operations in a try-catch block and execute `commit()` on the very last line (which is only executed if all previous commands succeeded) and `rollback()` in the catch block to roll back all changes as soon as an error occurs.": "一个典型的模式是将所有的操作包在一个try-catch块中，并在最后一行执行`commit()`（只有在所有先前的命令都成功的情况下才执行），在catch块中执行`rollback()`，一旦发生错误，立即回滚所有的修改。",
        "Although there is an alternative API (see below), all transactions work only with database session objects. To commit open changes from the unit-of-work in a database session to the database, `commit()` is normally called. In a transactional session, `commit()` not only commits all pending changes to the database, but also completes (\"commits\") the transaction, thus closing the transaction. Alternatively, you can call `session.flush()` to commit all pending changes without `commit` and thus without closing the transaction. To commit a transaction without flushing the unit-of-work, use `session.commitTransaction()`.": "虽然有一个替代的API（见下文），但所有的事务只与数据库会话对象一起工作。为了将数据库会话中的工作单元的开放变化提交到数据库中，通常会调用`commit()`。在一个事务性会话中，`commit()`不仅将所有未完成的修改提交到数据库中，而且还完成（\"提交\"）事务，从而关闭事务。另外，你也可以调用`session.flush()`来提交所有未完成的修改，而不使用`commit`，因此也不关闭事务。要提交一个事务而不刷新工作单元，请使用`session.commitTransaction()`。",
        "Once `commit()` or `rollback()` is executed in a session, the transaction is released. You must then call `useTransaction()` again if you want to continue in a new transaction.": "一旦`commit()`或`rollback()`在一个会话中被执行，事务就被释放了。如果你想在一个新的事务中继续，你必须再次调用`useTransaction()'。",
        "Please note that once the first database operation is executed in a transactional session, the assigned database connection becomes fixed and exclusive to the current session object (sticky). Thus, all subsequent operations will be performed on the same connection (and thus, in most databases, on the same database server). Only when either the transactional session is terminated (commit or rollback), the database connection is released again. It is therefore recommended to keep a transaction only as short as necessary.": "请注意，一旦在一个事务性会话中执行了第一个数据库操作，所分配的数据库连接就会成为固定的，并为当前会话对象所独有（粘性）。因此，所有后续的操作都将在同一个连接上执行（因此，在大多数数据库中，在同一个数据库服务器上）。只有当事务性会话被终止（提交或回滚）时，数据库连接才会被再次释放。因此，我们建议只在必要时保持一个事务的长度。",
        "If a session is already connected to a transaction, a call to `session.useTransaction()` always returns the same object. Use `session.isTransaction()` to check if a transaction is associated with the session.": "如果一个会话已经连接到一个事务，对`session.useTransaction()`的调用总是返回同一个对象。使用`session.isTransaction()`来检查一个事务是否与会话相关。",
        "Nested transactions are not supported.": "不支持嵌套交易。",
        "Transaktion Callback": "交易回拨",
        "An alternative to transactional sessions is `database.transaction(callback)`.": "事务性会话的一个替代方法是`database.transaction(callback)`。",
        "The `database.transaction(callback)` method performs an asynchronous callback within a new transactional session. If the callback succeeds (that is, no error is thrown), the session is automatically committed (and thus its transaction committed and all changes flushed). If the callback fails, the session automatically executes `rollback()` and the error is propagated.": "`database.transaction(callback)`方法在一个新的事务性会话中执行一个异步回调。如果回调成功（也就是说，没有抛出错误），会话就会自动提交（因此它的事务就会提交，所有的变化就会被刷新）。如果回调失败，会话将自动执行`rollback()`，并且错误将被传播。",
        "Isolations": "隔离",
        "Many databases support different types of transactions. To change the transaction behavior, you can call different methods for the returned transaction object from `useTransaction()`. The interface of this transaction object depends on the database adapter used. For example, the transaction object returned from a MySQL database has different options than the one returned from a MongoDB database. Use code completion or view the database adapter's interface to get a list of possible options.": "许多数据库支持不同类型的事务。为了改变交易行为，你可以为从`useTransaction()`返回的交易对象调用不同的方法。这个事务对象的接口取决于使用的数据库适配器。例如，从MySQL数据库返回的事务对象与从MongoDB数据库返回的对象有不同的选项。使用代码完成或查看数据库适配器的接口，以获得可能的选项列表。",
        "While transactions for MySQL, PostgreSQL, and SQLite work by default, you must first set up MongoDB as a \"replica set\".": "虽然MySQL、PostgreSQL和SQLite的交易默认是有效的，但你必须首先将MongoDB设置为一个 \"复制集\"。",
        "To convert a standard MongoDB instance to a replica set, please refer to the official documentation link:https://docs.mongodb.com/manual/tutorial/convert-standalone-to-replica-set/[Convert a Standalone to a Replica Set].": "要将一个标准的MongoDB实例转换为一个副本集，请参考官方文档链接：https://docs.mongodb.com/manual/tutorial/convert-standalone-to-replica-set/[将单机转换为副本集]。",
        "Locking": "锁定",
        "Optimistic Locking": "乐观的锁定",
        "Pessimistic Locking": "悲观的锁定",
        "Custom Types": "自定义类型",
        "Logging": "伐木",
        "Migration": "迁徙",
        "Seeding": "播种",
        "Raw Database Access": "原始数据库访问",
        "SQL": "SQL",
        "App Configuration": "应用程序配置",
        "Composite Primary Key": "复合主键",
        "Composite Primary-Key means, an entity has several primary keys, which are automatically combined to a \"composite primary key\". This way of modeling the database has advantages and disadvantages. We believe that composite primary keys have huge practical disadvantages that do not justify their advantages, so they should be considered bad practice and therefore avoided. Deepkit ORM does not support composite primary keys. In this chapter we explain why and show (better) alternatives.": "复合主键是指，一个实体有几个主键，它们被自动组合成一个 \"复合主键\"。这种数据库建模的方式有优点也有缺点。我们认为，复合主键有巨大的实际缺点，不能证明其优点，所以应该被认为是不好的做法，因此要避免使用。Deepkit ORM 不支持复合主键。在本章中，我们将解释原因，并展示（更好的）替代方案。",
        "Disadvantages": "劣势",
        "Joins are not trivial. Although they are highly optimized in RDBMS, they represent a constant complexity in applications that can easily get out of hand and lead to performance problems. Performance not only in terms of query execution time, but also in terms of development time.": "连接不是小事。尽管它们在RDBMS中被高度优化，但它们在应用程序中代表了一种持续的复杂性，很容易失控并导致性能问题。性能不仅体现在查询执行时间上，也体现在开发时间上。",
        "Joins": "加入",
        "Each individual join becomes more complicated as more fields are involved. While many databases have implemented optimizations to make joins with multiple fields not slower per se, it requires the developer to constantly think through these joins in detail, since forgetting keys, for example, can lead to subtle errors (since the join will work even without specifying all keys) and the developer therefore needs to know the full composite primary key structure.": "每一个单独的连接都会因为涉及更多的字段而变得更加复杂。虽然许多数据库已经实现了优化，使多字段的连接本身并不慢，但它要求开发者不断地详细思考这些连接，因为例如忘记键会导致微妙的错误（因为即使没有指定所有的键，连接也会工作），因此开发者需要知道完整的复合主键结构。",
        "Indizes": "铟为",
        "Indexes with multiple fields (which are composite primary keys) suffer from the problem of field ordering in queries. While database systems can optimize certain queries, complex structures make it difficult to write efficient operations that correctly use all defined indexes. For an index with multiple fields (such as a composite primary key), it is usually necessary to define the fields in the correct order for the database to actually use the index. If the order is not specified correctly (for example, in a WHERE clause), this can easily result in the database not using the index at all and instead performing a full table scan. Knowing which database query optimizes in which way is advanced knowledge that new developers don't usually have, but is necessary once you start working with composite primary keys so that you get the most out of your database and don't waste resources.": "有多个字段的索引（是复合主键）在查询中存在着字段排序的问题。虽然数据库系统可以优化某些查询，但是复杂的结构使得编写正确使用所有定义的索引的有效操作变得困难。对于一个有多个字段的索引（比如复合主键），通常需要以正确的顺序定义字段，以便数据库能够实际使用该索引。如果顺序没有被正确指定（例如，在WHERE子句中），这很容易导致数据库根本不使用该索引，而是执行全表扫描。了解数据库查询以何种方式进行优化是新的开发人员通常不具备的高级知识，但是一旦你开始使用复合主键，就有必要知道，这样你就可以从数据库中获得最大的收益，而不会浪费资源。",
        "Migrationen": "迁徙",
        "Once you decide that a particular entity needs an additional field to uniquely identify it (and thus become the Composite Primary Key), this will result in the adjustment of all entities in your database that have relationships to that entity.": "一旦你决定一个特定的实体需要一个额外的字段来唯一地识别它（从而成为复合主键），这将导致你数据库中所有与该实体有关系的实体的调整。",
        "For example, suppose you have an entity `user` with composite primary key and decide to use a foreign key to this `user` in different tables, e.g. in a pivot table `audit_log`, `groups` and `posts`. Once you change the primary key of `user`, all these tables need to be adjusted in a migration as well.": "例如，假设你有一个带有复合主键的实体`user`，并决定在不同的表中使用这个`user`的外键，例如在透视表`audit_log`，`groups`和`posts`。一旦你改变了`user'的主键，所有这些表也需要在迁移中调整。",
        "Not only does this make migration files much more complex, but it can also cause major downtime when running migration files, since schema changes usually require either a full database lock or at least a table lock. The more tables affected by a large change like an index change, the longer the migration will take. And the larger a table is, the longer the migration takes.": "这不仅使迁移文件变得更加复杂，而且在运行迁移文件时也会造成严重的停机，因为模式的改变通常需要一个完整的数据库锁或者至少一个表锁。像索引变更这样的大型变更所影响的表越多，迁移的时间就越长。而表越大，迁移的时间就越长。",
        "Consider the `audit_log` table. Such tables usually have many records (millions or so), and you have to touch them during a schema change only because you decided to use a composite primary key and add an extra field to the primary key of `user`. Depending on the size of all these tables, this either makes migration changes unnecessarily more expensive or, in some cases, so expensive that changing the primary key of `User` is no longer financially justifiable. This usually leads to workarounds (e.g. adding a unique index to the user table) that result in technical debt and sooner or later end up on the legacy list.": "考虑一下`audit_log`表。这样的表通常有很多记录（几百万条左右），你必须在模式改变时触动它们，只是因为你决定使用复合主键，并在`user`的主键上增加一个额外的字段。根据所有这些表的大小，这使得迁移的成本不必要地增加，或者在某些情况下，成本高到改变`用户'的主键在经济上不再合理。这通常会导致变通的方法（例如给用户表添加唯一索引），导致技术债务，并迟早会被列入遗留问题清单。",
        "For large projects, this can lead to huge downtime (from minutes to hours) and sometimes even the introduction of an entirely new migration abstraction system that essentially copies tables, inserts records into ghost tables, and moves tables back and forth after migration. This added complexity is in turn imposed on any entity that has a relationship to another entity with a composite primary key, and becomes greater the larger your database structure becomes. The problem gets worse with no way to solve it (except by removing the composite primary key entirely).": "对于大型项目来说，这可能会导致巨大的停机时间（从几分钟到几小时不等），有时甚至需要引入一个全新的迁移抽象系统，该系统基本上是复制表，将记录插入幽灵表，并在迁移之后来回移动表。这种增加的复杂性反过来又强加在任何与另一个实体有复合主键关系的实体上，而且你的数据库结构越大，复杂性就越大。这个问题越来越严重，但没有办法解决（除了完全删除复合主键）。",
        "Findability": "可查找性",
        "If you are a database administrator or Data EngineerScientist, you usually work directly on the database and explore the data when you need it. With composite primary keys, any user writing SQL directly must know the correct primary key of all tables involved (and the column order to get correct index optimizations). This added overhead not only complicates data exploration, report generation, etc., but can also lead to errors in older SQL if a composite primary key is suddenly changed. The old SQL is probably still valid and running fine, but suddenly returns incorrect results because the new field in the composite primary key is missing from the join. It is much easier here to have only one primary key. This makes it easier to find data and ensures that old SQL queries will still work correctly if you decide to change the way a user object is uniquely identified, for example.": "如果你是一个数据库管理员或数据工程师科学家，你通常直接在数据库上工作，并在需要时探索数据。有了复合主键，任何直接编写SQL的用户都必须知道所有涉及的表的正确主键（以及列的顺序以获得正确的索引优化）。这种额外的开销不仅使数据探索、报告生成等变得复杂，而且如果复合主键突然被改变，也会导致旧的SQL出错。旧的SQL可能仍然有效并且运行良好，但是突然返回不正确的结果，因为复合主键中的新字段在连接中丢失。在这里，只有一个主键要容易得多。这使得查找数据更容易，并确保旧的SQL查询仍能正常工作，例如，如果你决定改变一个用户对象的唯一标识方式。",
        "Revision": "修订版",
        "Once a composite primary key is used in an entity, refactoring the key can result in significant additional refactoring. Because an entity with a composite primary key typically does not have a single unique field, all filters and links must contain all values of the composite key. This usually means that the code relies on knowing the composite primary key, so all fields must be retrieved (e.g., for URLs like user:key1:key2). Once this key is changed, all places where this knowledge is explicitly used, such as URLs, custom SQL queries, and other places, must be rewritten.": "一旦在一个实体中使用了复合主键，重构该键就会导致大量的额外重构。因为一个有复合主键的实体通常没有一个唯一的字段，所有的过滤器和链接必须包含复合主键的所有值。这通常意味着代码依赖于对复合主键的了解，所以必须检索所有的字段（例如，对于user:key1:key2这样的URL）。一旦这个键被改变，所有明确使用这个知识的地方，如URL、自定义SQL查询和其他地方，都必须被重写。",
        "While ORMs typically create joins automatically without manually specifying the values, they cannot automatically cover refactoring for all other use cases such as URL structures or custom SQL queries, and especially not for places where the ORM is not used at all, such as in reporting systems and all external systems.": "虽然ORM通常会自动创建连接，而不需要手动指定值，但它们不能自动涵盖所有其他用例的重构，如URL结构或自定义SQL查询，尤其是在完全不使用ORM的地方，如报告系统和所有外部系统中。",
        "ORM complexity": "ORM的复杂性",
        "With the support of composite primary keys, the complexity of the code of a powerful ORM like Deepkit ORM increases tremendously. Not only will the code and maintenance become more complex and therefore more expensive, but there will be more edge cases from users that need to be fixed and maintained. The complexity of the query layer, change detection, migration system, internal relationship tracking, etc. increases significantly. The overall cost associated with building and supporting an ORM with composite primary keys is too high, all things considered, and cannot be justified, which is why Deepkit does not support it.": "随着对复合主键的支持，像Deepkit ORM这样强大的ORM的代码的复杂性会大大增加。不仅代码和维护会变得更加复杂，因此也更加昂贵，而且会有更多来自用户的边缘案例需要被修复和维护。查询层、变化检测、迁移系统、内部关系跟踪等的复杂性会大大增加。从所有方面考虑，构建和支持具有复合主键的ORM的整体成本太高，无法证明其合理性，这就是Deepkit不支持它的原因。",
        "Advantages": "优势",
        "Apart from this, composite primary keys also have advantages, albeit very superficial ones. By using as few indexes as possible for each table, writing (inserting/updating) data becomes more efficient, since fewer indexes need to be maintained. It also makes the structure of the model a bit cleaner (since it usually has one less column). However, the difference between a sequentially ordered, automatically incrementing primary key and a non-incrementing primary key is completely negligible these days, since disk space is cheap and the operation is usually just an \"append-only\" operation, which is very fast.": "除此之外，复合主键也有优势，尽管是非常表面的优势。通过为每个表使用尽可能少的索引，写入（插入/更新）数据变得更有效率，因为需要维护的索引更少。这也使得模型的结构变得更加简洁（因为它通常少了一列）。然而，现在顺序排列、自动递增的主键和非递增的主键之间的差别完全可以忽略不计，因为磁盘空间很便宜，而且操作通常只是一个 \"仅追加 \"的操作，非常快。",
        "There may certainly be a few edge cases (and for a few very specific database systems) where it is initially better to work with composite primary keys. But even in these systems, it might make more sense overall (considering all the costs) not to use them and to switch to another strategy.": "当然，在一些边缘情况下（以及一些非常特殊的数据库系统），最初使用复合主键会更好。但即使在这些系统中，不使用复合主键而改用另一种策略，总体上可能更有意义（考虑到所有的成本）。",
        "Alternative": "替代方案",
        "An alternative to composite primary keys is to use a single automatically incrementing numeric primary key, usually called \"id\", and move the composite primary key to a unique index with multiple fields. Depending on the primary key used (depending on the expected number of rows), the \"id\" uses either 4 or 8 bytes per record.": "一个替代复合主键的方法是使用一个自动递增的数字主键，通常称为 \"id\"，并将复合主键移到一个具有多个字段的唯一索引中。根据所使用的主键（取决于预期的行数），\"id \"在每条记录中使用4或8字节。",
        "By using this strategy, you are no longer forced to think about the problems described above and find a solution, which enormously reduces the cost of ever-growing projects.": "通过使用这种策略，你不再被迫思考上述问题并找到解决方案，这极大地降低了不断增长的项目的成本。",
        "The strategy specifically means that each entity has an \"id\" field, usually at the very beginning, and this field is then used to identify unique rows by default and in joins.": "该策略的具体含义是，每个实体都有一个 \"id \"字段，通常在最开始，然后这个字段在默认情况下和连接中被用来识别唯一的行。",
        "As an alternative to a composite primary key, you would use a unique multi-field index instead.": "作为复合主键的替代品，你可以使用唯一的多字段索引来代替。",
        "Deepkit ORM automatically supports incremental primary keys, including for MongoDB. This is the preferred method for identifying records in your database. However, for MongoDB you can use the ObjectId (`_id: MongoId & PrimaryKey = ''`) as a simple primary key. An alternative to the numeric, auto-incrementing primary key is a UUID, which works just as well (but has slightly different performance characteristics, since indexing is more expensive).": "Deepkit ORM自动支持增量主键，包括对MongoDB。这是在数据库中识别记录的首选方法。然而，对于MongoDB，您可以使用ObjectId（`_id: MongoId & PrimaryKey = ''`）作为一个简单的主键。替代数字、自动递增主键的方法是UUID，它的效果同样好（但性能特征略有不同，因为索引的成本更高）。",
        "Summary": "摘要",
        "Composite primary keys essentially mean that once they are in place, all future changes and practical use come at a much higher cost. While it looks like a clean architecture at the beginning (because you have one less column), it leads to significant practical costs once the project is actually developed, and the costs continue to increase as the project gets larger.": "复合主键本质上意味着，一旦它们到位，所有未来的变化和实际使用都要付出更高的成本。虽然它在开始时看起来是一个干净的架构（因为你少了一列），但一旦项目实际开发，它就会导致大量的实际成本，而且成本会随着项目的扩大而继续增加。",
        "Looking at the asymmetries between benefits and drawbacks, it is clear that composite primary keys cannot be justified in most cases. The costs are much greater than the benefits. Not only for you as a user, but also for us as the author and maintainer of the ORM code. For this reason, Deepkit ORM does not support composite primary keys.": "看一下好处和坏处之间的不对称性，很明显，复合主键在大多数情况下是没有道理的。其成本远远大于收益。不仅是对作为用户的你，而且对作为ORM代码的作者和维护者的我们。由于这个原因，Deepkit ORM不支持复合主键。",
        "Plugins": "插件",
        "Soft-Delete": "软删除",
        "The Soft-Delete plugin allows to keep database records hidden without actually deleting them. When a record is deleted, it is only marked as deleted and not actually deleted. All queries automatically filter for this deleted property, so it feels to the user as if it is actually deleted.": "软删除插件允许保持数据库记录的隐藏，而不实际删除它们。当一条记录被删除时，它只被标记为删除，而不是实际删除。所有的查询都会自动过滤这个删除的属性，所以对用户来说，感觉就像它真的被删除了一样。",
        "To use the plugin, you must instantiate the SoftDelete class and enable it for each entity.": "要使用该插件，你必须实例化SoftDelete类，并为每个实体启用它。",
        "To soft-delete records, use the usual methods: `deleteOne` or `deleteMany` in a query, or use the session to delete them. The soft-delete plugin will do the rest automatically in the background.": "要软删除记录，使用通常的方法：`deleteOne`或`deleteMany`在查询中，或使用会话来删除它们。软删除插件将在后台自动完成剩下的工作。",
        "Restore": "恢复",
        "Deleted records can be restored using a cancelled query via `SoftDeleteQuery`. It has `restoreOne` and `restoreMany`.": "被删除的记录可以通过`SoftDeleteQuery`使用取消的查询来恢复。它有`restoreOne`和`restoreMany`。",
        "The session also supports element recovery.": "该会议还支持元素恢复。",
        "Hard Delete": "硬删除",
        "To hard delete records, use a lifted query via SoftDeleteQuery. This essentially restores the old behavior without the single query plugin.": "要硬删除记录，请通过SoftDeleteQuery使用解除的查询。这实质上是恢复了旧的行为，而没有单一的查询插件。",
        "Query deleted.": "查询删除。",
        "With a \"lifted\" query via `SoftDeleteQuery` you can also include deleted records.": "通过`SoftDeleteQuery`的 \"解除 \"查询，你也可以包括已删除的记录。",
        "Deleted by": "被删除的",
        "`deletedBy` can be set via query and sessions.": "`deletedBy`可以通过查询和会话设置。",
        "Template": "模板",
        "The template engine allows to write type-safe, fast and secure HTML templates. It is based on TSX and is ready to use as soon as you use the `.tsx` file extension and adjust the `tsconfig.json` accordingly.": "模板引擎允许编写类型安全、快速和安全的HTML模板。它基于TSX，只要你使用`.tsx`文件扩展名并相应调整`tsconfig.json`就可以使用。",
        "The important thing is: it is not compatible with React. As soon as React is to be used, `@deepkit/template` is incompatible. Deepkit's template engine is only intended for SSR (server-side rendering).": "重要的是：它与React不兼容。一旦要使用React，`@deepkit/template`就不兼容了。Deepkit的模板引擎只用于SSR（服务器端渲染）。",
        "In your tsconfig you have to adjust following settings: `jsx` and `jsxImportSource`": "在你的tsconfig中，你必须调整以下设置：`jsx`和`jsxImportSource`。",
        "Now you can use TSX directly in your controller.": "现在你可以在你的控制器中直接使用TSX。",
        "When you return such a TSX in your route method, the HTTP content type is automatically set to `texthtml; charset=utf-8`.": "当你在路由方法中返回这样的TSX时，HTTP内容类型被自动设置为`texthtml; charset=utf-8`。",
        "Components": "组成部分",
        "You can structure your templates the way you are used to in React. Either modularize your layout into multiple function or class components.": "你可以按照你在React中习惯的方式构造你的模板。要么将你的布局模块化为多个函数或类组件。",
        "Function Components": "功能组件",
        "The easiest way is to use a function that returns TSX.": "最简单的方法是使用一个返回TSX的函数。",
        "Function components can be asynchronous (unlike in React). This is an important difference from other template engines you may be familiar with, like React.": "函数组件可以是异步的（与React不同）。这是与你可能熟悉的其他模板引擎的一个重要区别，比如React。",
        "All functions have access to the dependency injection container and can reference any dependencies starting with the third parameter.": "所有函数都可以访问依赖注入容器，并且可以引用从第三个参数开始的任何依赖。",
        "Class Components": "班级组成",
        "An alternative way to write a component is a class component. They are handled and instantiated in the Dependency Injection container and thus have access to all services registered in the container. This makes it possible to directly access a data source such as a database in your components, for example.": "另一种编写组件的方式是类组件。它们在依赖注入容器中被处理和实例化，因此可以访问容器中注册的所有服务。这使得在你的组件中直接访问数据源（如数据库）成为可能，例如。",
        "For class components the first constructor arguments are reserved. `props` can be defined arbitrarily, `children` is always \"any\", and then optional dependencies follow, which you can choose arbitrarily. Since class components are instantiated in the Dependency Injection container, you have access to all your services.": "对于类组件，第一个构造函数参数是保留的。`props`可以任意定义，`children`总是 \"any\"，然后是可选的依赖关系，你可以任意选择。由于类组件是在依赖注入容器中实例化的，你可以访问你的所有服务。",
        "Dynamic HTML": "动态HTML",
        "The template engine has automatically cleaned up all the variables used, so you can safely use user input directly in the template. To render dynamic HTML, you can use the html function.": "模板引擎已经自动清理了所有使用的变量，所以你可以安全地在模板中直接使用用户输入。要渲染动态HTML，你可以使用html函数。",
        "Optimization": "优化",
        "The template engine tries to optimize the generated JSX code so that it is much easier for NodeJSV8 to generate the HTML string. For this to work correctly, you should move all your components from the main app.tsx file to separate files. A structure might look like this:": "模板引擎试图优化生成的JSX代码，这样NodeJSV8就更容易生成HTML字符串。为了使其正常工作，你应该把你的所有组件从主app.tsx文件中移到单独的文件中。一个结构可能看起来像这样：",
        "Framework": "框架",
        "Deepkit Framework is based on runtime types in Deepkit Type. Make sure that `@deepkit/type` is installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Deepkit框架是基于Deepkit Type中的运行时类型。请确保`@deepkit/type`被正确安装。参见xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation]。",
        "Make sure that all peer dependencies are installed. By default, NPM 7+ installs them automatically.": "确保所有对等的依赖都已安装。默认情况下，NPM 7+会自动安装它们。",
        "To compile your application, we need the TypeScript compiler and recommend `ts-node` to easily run the app.": "为了编译你的应用程序，我们需要TypeScript编译器，并推荐`ts-node`来轻松运行应用程序。",
        "An alternative to using `ts-node` is to compile the source code with the TypeScript compiler and execute the JavaScript source code directly. This has the advantage of dramatically increasing execution speed for short commands. However, it also creates additional workflow overhead by either manually running the compiler or setting up a watcher. For this reason, `ts-node` is used in all examples in this documentation.": "使用`ts-node`的另一种方法是用TypeScript编译器编译源代码，直接执行JavaScript源代码。这样做的好处是极大地提高了短命令的执行速度。然而，它也会通过手动运行编译器或设置观察器而产生额外的工作流程开销。出于这个原因，本文档中的所有例子都使用了`ts-node`。",
        "Erste Applikation": "最早的应用",
        "Since the Deepkit framework does not use configuration files or a special folder structure, you can structure your project however you want. The only two files you need to get started are the TypeScript app.ts file and the TypeScript configuration tsconfig.json.": "由于Deepkit框架不使用配置文件或特殊的文件夹结构，你可以随心所欲地构造你的项目。你唯一需要开始的两个文件是TypeScript app.ts文件和TypeScript配置tsconfig.json。",
        "Our goal is to have the following files in our project folder:": "我们的目标是在我们的项目文件夹中拥有以下文件：",
        "In this code, you can see that we have defined a test command using the `TestCommand` class and created a new app that we run directly using `run()`. By running this script, we start the app.": "在这段代码中，你可以看到我们使用`TestCommand`类定义了一个测试命令，并创建了一个新的应用程序，我们使用`run()`直接运行。通过运行这个脚本，我们启动了这个应用程序。",
        "With the shebang in the first line (`#!...`) we can make our script executable with the following command.": "有了第一行的shebang(`#!...`)，我们可以用下面的命令使我们的脚本可执行。",
        "Und dann ausführen:": "并在此基础上开展工作：",
        "Now, to execute our test command, we run the following command.": "现在，为了执行我们的测试命令，我们运行以下命令。",
        "In Deepkit Framework everything is now done via this `app.ts`. You can rename the file as you like or create more. Custom CLI commands, HTTP/RPC server, migration commands, and so on are all started from this entry point.": "在Deepkit Framework中，现在所有的事情都是通过这个`app.ts`完成的。你可以随心所欲地重命名这个文件，或者创建更多的文件。自定义CLI命令、HTTP/RPC服务器、迁移命令等等，都是从这个入口点开始的。",
        "To start the HTTP/RPC server, run the following:": "要启动HTTP/RPC服务器，请运行以下内容：",
        "To serve requests please read chapter xref:http.adoc[HTTP] or xref:rpc.adoc[RPC]. In chapter xref:cli.adoc[CLI] you can learn more about CLI commands.": "要提供请求，请阅读xref:http.adoc[HTTP]或xref:rpc.adoc[RPC]一章。在xref:cli.adoc[CLI]一章中，你可以了解更多关于CLI命令。",
        "App": "应用",
        "Via the `App` object starts like application.": "通过`App`对象启动像应用程序。",
        "The `run()` method lists the arguments and executes the corresponding CLI controller. Since `FrameworkModule` provides its own CLI controllers, which are responsible for starting the HTTP server, for example, these can be called via it.": "`run()`方法列出参数并执行相应的CLI控制器。由于`FrameworkModule`提供了自己的CLI控制器，负责启动HTTP服务器，例如，可以通过它来调用这些控制器。",
        "The `App` object can also be used to access the Dependency Injection container without running a CLI controller.": "`App`对象也可以用来访问依赖注入容器，而无需运行CLI控制器。",
        "Module": "模块",
        "Deepkit framework is highly modular and allows you to split your application into several handy modules. Each module has its own dependency injection sub-container, configuration, commands and much more. In the chapter \"First application\" you have already created one module - the root module. `new App` takes almost the same arguments as a module, because it creates the root module for you automatically in the background.": "Deepkit框架是高度模块化的，允许你把你的应用程序分成几个方便的模块。每个模块都有自己的依赖性注入子容器、配置、命令等等。在 \"第一个应用程序 \"一章中，你已经创建了一个模块--根模块。`new App`需要的参数与模块几乎相同，因为它在后台为你自动创建根模块。",
        "You can skip this chapter if you do not plan to split your application into submodules, or if you do not plan to make a module available as a package to others.": "如果你不打算把你的应用程序分成子模块，或者你不打算把一个模块作为包提供给其他人，你可以跳过这一章。",
        "A module is a simple class:": "一个模块是一个简单的类：",
        "It basically has no functionality at this point because its module definition is an empty object and it has no methods, but this demonstrates the relationship between modules and your application (your root module). This MyModule module can then be imported into your application or other modules.": "在这一点上，它基本上没有任何功能，因为它的模块定义是一个空对象，它没有任何方法，但这展示了模块和你的应用程序（你的根模块）之间的关系。然后，这个MyModule模块可以被导入你的应用程序或其他模块中。",
        "You can now add features to this module as you would with `App`. The arguments are the same, except that imports are not available in a module definition. Add HTTPRPCCLI controllers, services, a configuration, event listeners, and various module hooks to make modules more dynamic.": "现在你可以像使用`App'那样向这个模块添加功能。参数是一样的，只是在模块定义中不能使用导入。添加HTTPRPCCLI控制器、服务、一个配置、事件监听器和各种模块钩子，使模块更加动态。",
        "Controllers": "控制器",
        "Modules can define controllers that are processed by other modules. For example, if you add a controller with decorators from the `@deepkit/http` package, its `HttpModule` module will pick this up and register the found routes in its router. A single controller may contain several such decorators. It is up to the module author who gives you these decorators how he processes the controllers.": "模块可以定义由其他模块处理的控制器。例如，如果你添加了一个带有`@deepkit/http`包的装饰器的控制器，它的`HttpModule`模块就会接收到这些装饰器，并在其路由器中注册找到的路由。一个控制器可以包含几个这样的装饰器。这取决于给你这些装饰器的模块作者如何处理这些控制器。",
        "In Deepkit there are three packages that handles such controllers: HTTP, RPC, and CLI. See their respective chapters to learn more. Below is an example of an HTTP controller:": "在Deepkit中，有三个包可以处理这种控制器：HTTP、RPC和CLI。请参阅它们各自的章节以了解更多信息。下面是一个HTTP控制器的例子：",
        "Provider": "供应商",
        "When you define a provider in the `providers` section of your application, it is accessible throughout your application. For modules, however, these providers are automatically encapsulated in that module's dependency injection subcontainer. You must manually export each provider to make it available to another module or your application.": "当你在你的应用程序的`providers`部分定义一个提供者时，它可以在整个应用程序中访问。然而，对于模块，这些提供者被自动封装在该模块的依赖注入子容器中。你必须手动导出每个提供者，使其对其他模块或你的应用程序可用。",
        "To learn more about how providers work, see the xref:dependency-injection.adoc[Dependency Injection] chapter.": "要了解更多关于提供者如何工作的信息，请参阅xref:dependency-injection.adoc[依赖注入]章节。",
        "When a user imports this module, he has no access to `HelloWorldService` because it is encapsulated in the sub-dependency injection container of `MyModule`.": "当用户导入这个模块时，他无法访问`HelloWorldService`，因为它被封装在`MyModule`的子依赖注入容器中。",
        "Exports": "出口",
        "To make providers available in the importer's module, you can include the provider's token in `exports`. This essentially moves the provider up one level into the dependency injection container of the parent module - the importer.": "为了使提供者在导入者的模块中可用，你可以在`exports`中包含提供者的标记。这实质上是将提供者上移到父模块的依赖注入容器中，即导入者。",
        "If you have other providers like `FactoryProvider`, `UseClassProvider` etc., you should still use only the class type in the exports.": "如果你有其他的提供者，如`FactoryProvider`，`UseClassProvider`等，你仍然应该在出口中只使用类的类型。",
        "We can now import that module and use its exported service in our application code.": "我们现在可以导入该模块并在我们的应用程序代码中使用其导出的服务。",
        "Read the xref:dependency-injection.adoc[Dependency Injection] chapter to learn more.": "阅读xref:dependency-injection.adoc[依赖注入]章节以了解更多。",
        "Konfiguration": "配置",
        "In Deepkit framework, modules and your application can have configuration options. For example, a configuration can consist of database URLs, passwords, IPs, and so on. Services, HTTPRPCCLI controllers, and template functions can read these configuration options via dependency injection.": "在Deepkit框架中，模块和你的应用程序可以有配置选项。例如，一个配置可以由数据库的URL、密码、IP等组成。服务、HTTPRPCCLI控制器和模板函数可以通过依赖性注入读取这些配置选项。",
        "A configuration can be defined by defining a class with properties. This is a type-safe way to define a configuration for your entire application, and its values are automatically serialized and validated.": "一个配置可以通过定义一个带有属性的类来定义。这是一种类型安全的方式，可以为你的整个应用程序定义一个配置，而且它的值会被自动序列化和验证。",
        "Beispiel": "例子",
        "Configuration class": "配置类",
        "Die Werte für die Konfigurationsoptionen können entweder im Konstruktor des Moduls, mit der Methode `.configure()` oder über Konfigurationslader (z.B. Umgebungsvariablenlader) bereitgestellt werden.": "配置选项的操作方法可以通过Moduls的Konstruktor、`.configure()方法或Konfigurationslader(z.B. Umgebungsvariablenlader)来进行设置。",
        "To dynamically change the configuration options of an imported module, you can use the `process` hook. This is a good place to either redirect configuration options or set up an imported module depending on the current module configuration or other module instance information.": "为了动态地改变一个导入的模块的配置选项，你可以使用`process`钩子。这是一个很好的地方，既可以重定向配置选项，也可以根据当前的模块配置或其他模块实例信息来设置导入的模块。",
        "At the application level, it works a little differently:": "在应用层面，它的工作方式有点不同：",
        "When the root application module is created from a regular module, it works similarly to regular modules.": "当根应用程序模块由普通模块创建时，其工作方式与普通模块类似。",
        "Read configuration values": "读取配置值",
        "To use a configuration option in a service, you can use normal dependency injection. It is possible to inject either the entire configuration object, a single value, or a portion of the configuration.": "要在服务中使用配置选项，你可以使用正常的依赖注入。可以注入整个配置对象、单个值或配置的一部分。",
        "Partial": "部分",
        "To inject only a subset of the configuration values, use the `Pick` type.": "要想只注入配置值的一个子集，请使用`Pick`类型。",
        "Single value": "单一价值",
        "To inject only a single value, use the index access operator.": "要只注入一个值，请使用索引访问操作符。",
        "All": "全部",
        "To inject all config values, use the class as dependency.": "要注入所有的配置值，请使用该类作为依赖关系。",
        "Debugger": "调试器",
        "The configuration values of your application and all modules can be displayed in the debugger. Enable the debug option in `FrameworkModule` and open `http://localhost:8080/_debug/configuration`.": "你的应用程序和所有模块的配置值都可以在调试器中显示。在`FrameworkModule`中启用调试选项，并打开`http://localhost:8080/_debug/configuration`。",
        "You can also use `ts-node app.ts app:config` to display all available configuration options, the active value, their default value, description and data type.": "你也可以使用`ts-node app.ts app:config`来显示所有可用的配置选项、活动值、它们的默认值、描述和数据类型。",
        "Set configuration values": "设置配置值",
        "By default, no values are overwritten, so default values are used. There are several ways to set configuration values.": "默认情况下，没有值被覆盖，所以使用默认值。有几种方法来设置配置值。",
        "Environment variables for each option": "每个选项的环境变量",
        "Environment variable via JSON": "通过JSON的环境变量",
        "dotenv-Files": "dotenv-Files",
        "You can use several methods to load the configuration at the same time. The order in which they are called is important.": "你可以同时使用几个方法来加载配置。调用这些方法的顺序是很重要的。",
        "Environment variables": "环境变量",
        "To allow setting each configuration option via its own environment variable, use `loadConfigFromEnv`. The default prefix is `APP_`, but you can change it. It also automatically loads `.env` files. By default, it uses an uppercase naming strategy, but you can change that too.": "要允许通过自己的环境变量设置每个配置选项，请使用`loadConfigFromEnv`。默认前缀是`APP_`，但你可以改变它。它也会自动加载`.env`文件。默认情况下，它使用大写的命名策略，但你也可以改变它。",
        "For configuration options like `pageTitle` above, you can use `APP_PAGE_TITLE=\"Other Title\"` to change the value.": "对于上述`pageTitle'这样的配置选项，你可以使用`APP_PAGE_TITLE=\"Other Title\"`来改变数值。",
        "JSON environment variable": "JSON环境变量",
        "To change multiple configuration options via a single environment variable, use `loadConfigFromEnvVariable`. The first argument is the name of the environment variable.": "要通过一个环境变量改变多个配置选项，使用`loadConfigFromEnvVariable`。第一个参数是环境变量的名称。",
        "DotEnv Files": "DotEnv文件",
        "To change multiple configuration options via a dotenv file, use `loadConfigFromEnv`. The first argument is either a path to a dotenv (relative to `cwd`) or multiple paths. If it is an array, each path is tried until an existing file is found.": "要通过dotenv文件改变多个配置选项，使用`loadConfigFromEnv`。第一个参数是一个dotenv的路径（相对于`cwd`）或多个路径。如果它是一个数组，每个路径都被尝试，直到找到一个现有的文件。",
        "Module Configuration": "模块配置",
        "Each imported module can have a module name. This name is used for the configuration paths used above.": "每个导入的模块可以有一个模块名称。这个名字用于上面的配置路径。",
        "For example, for configuring environment variables, the path for the `FrameworkModule` option port is `FRAMEWORK_PORT`. All names are written in uppercase by default. If a prefix of `APP_` is used, the port can be changed via the following:": "例如，对于配置环境变量，`FrameworkModule`选项端口的路径是`FRAMEWORK_PORT`。所有的名字都默认以大写字母书写。如果使用`APP_`的前缀，可以通过以下方式改变端口：",
        "In dotenv files it would also be `APP_FRAMEWORK_PORT=9999`.": "在dotenv文件中，它也是`APP_FRAMEWORK_PORT=9999`。",
        "In JSON environment variables via `loadConfigFromEnvVariable('APP_CONFIG')` on the other hand, it is the structure of the actual configuration class. `framework` becomes an object.": "在JSON环境变量中通过`loadConfigFromEnvVariable('APP_CONFIG')`另一方面，它是实际配置类的结构。`framework`成为一个对象。",
        "This works the same for all modules. No module prefix is required for your application configuration option (`new App`).": "这对所有模块都是一样的。你的应用程序配置选项（`new App`）不需要模块前缀。",
        "Application Server": "应用服务器",
        "Public Directory": "公共目录",
        "The FrameworkModule provides a way to serve static files such as images, PDFs, binaries, etc. over HTTP. The `publicDir` configuration option lets you specify which folder to use as the default entry point for requests that do not lead to an HTTP controller route. By default, this behavior is disabled (empty value).": "FrameworkModule提供了一种通过HTTP提供静态文件的方法，如图片、PDF、二进制文件等。`publicDir`配置选项可以让你指定哪个文件夹作为不通往HTTP控制器路线的请求的默认入口。默认情况下，这种行为是禁用的（空值）。",
        "To enable the provision of public files, set `publicDir` to a folder of your choice. Normally you would choose a name like `publicDir` to make things obvious.": "要启用公共文件的提供，请将`publicDir`设置为你选择的文件夹。通常你会选择一个像`publicDir'这样的名字，使事情变得明显。",
        "To change the `publicDir` option, you can change the first argument of `FrameworkModule`.": "要改变`publicDir`选项，你可以改变`FrameworkModule`的第一个参数。",
        "All files within this configured folder are now accessible via HTTP. For example, if you open `http:localhost:8080logo.jpg`, you will see the image `logo.jpg` in the `publicDir` directory.": "这个配置的文件夹内的所有文件现在都可以通过HTTP访问。例如，如果你打开`http:localhost:8080logo.jpg`，你会看到`publicDir`目录下的图片`logo.jpg`。",
        "File Structure": "文件结构",
        "Deepkit has its own powerful database abstraction library called Deepkit ORM. It is an Object-Relational Mapping (ORM) library that facilitates work with SQL databases and MongoDB.": "Deepkit有自己的强大的数据库抽象库，称为Deepkit ORM。它是一个对象关系映射(ORM)库，可以促进与SQL数据库和MongoDB的工作。",
        "Although you can use any database library, we recommend Deepkit ORM as it is the fastest TypeScript database abstraction library that is perfectly integrated with the Deepkit framework and has many features that will improve your workflow and efficiency.": "虽然你可以使用任何数据库库，但我们推荐Deepkit ORM，因为它是最快的TypeScript数据库抽象库，与Deepkit框架完美结合，并具有许多功能，可以改善你的工作流程和效率。",
        "To get all the information about Deepkit ORM, see the xref:database.adoc[Database] chapter.": "要获得关于Deepkit ORM的所有信息，请参阅xref:database.adoc[数据库]章节。",
        "Database Classes": "数据库类",
        "The simplest way to use the `Database` object of Deepkit ORM within the application is to register a class that derives from it.": "在应用程序中使用Deepkit ORM的`Database'对象的最简单方法是注册一个从它派生出来的类。",
        "Create a new class and in its constructor specify the adapter with its parameters and add to the second parameter all entity models that should be connected to this database.": "创建一个新的类，并在其构造函数中指定带有参数的适配器，并在第二个参数中添加应连接到该数据库的所有实体模型。",
        "You can now register this database class as a provider. We also enable `migrateOnStartup` which will automatically create all tables in your database at bootstrap. This is ideal for rapid prototyping, but is not recommended for a serious project or production setup. Normal database migrations should then be used here.": "你现在可以把这个数据库类注册为一个提供者。我们还启用了`migrateOnStartup`，这将在启动时自动创建数据库中的所有表。这对于快速原型设计来说是很理想的，但对于一个严肃的项目或生产设置来说，不建议使用。这里应该使用普通的数据库迁移。",
        "We also enable `debug`, which allows us to open the debugger when the application's server is started and manage your database models directly in its built-in ORM browser.": "我们还启用了`debug`，它允许我们在应用程序的服务器启动时打开调试器，并在其内置的ORM浏览器中直接管理你的数据库模型。",
        "You can now access `SQLiteDatabase` anywhere using Dependency Injection:": "现在你可以使用依赖注入在任何地方访问`SQLiteDatabase`：",
        "Multiple Databases": "多个数据库",
        "You can add as many database classes as you like and name them as you like. Be sure to change the name of each database so that it doesn't conflict with others when you use the ORM browser.": "你可以添加任意多的数据库类，并按你的意愿命名。请确保改变每个数据库的名称，这样当你使用ORM浏览器时，它就不会与其他数据库冲突。",
        "Manage Data": "管理数据",
        "You now have everything set up to manage your database data with the Deepkit ORM Browser. To open the ORM Browser and manage the content, write all the steps from above in the `app.ts` file and start the server.": "现在你已经设置好了一切，可以用Deepkit ORM浏览器管理你的数据库数据。要打开ORM浏览器并管理内容，请将上面的所有步骤写入`app.ts`文件并启动服务器。",
        "You can now open http://localhost:8080/_debug/database/default.": "你现在可以打开http://localhost:8080/_debug/database/default。",
        "You can see the ER (entity relationship) diagram. At the moment only one entity is available. If you add more with relationships, you will see all the information at a glance.": "你可以看到ER（实体关系）图。目前只有一个实体可用。如果你添加更多的关系，你将看到所有的信息，一目了然。",
        "If you click on `User` in the left sidebar, you can manage its content. Click the `+` icon and change the title of the new record. After you have changed the required values (such as the user name), click `Confirm`. This will commit all changes to the database and make them permanent. The auto increment ID will be assigned automatically.": "如果你点击左侧边栏的 \"用户\"，你可以管理其内容。点击`+`图标，改变新记录的标题。在你修改了所需的值（如用户名）后，点击`确认'。这将向数据库提交所有更改，并使其成为永久性的。自动递增的ID将被自动分配。",
        "Learn More": "了解更多",
        "To learn more about how `SQLiteDatabase` works, please read the chapter xref:database.adoc[Database] and its subchapters, such as querying data, manipulating data via sessions, defining relations and much more.": "要了解更多关于`SQLiteDatabase`的工作原理，请阅读xref:database.adoc[Database]一章及其子章，如查询数据、通过会话操作数据、定义关系等。",
        "Please note that the chapters there refer to the standalone library `@deepkit/orm` and do not include documentation about the part of the deepkit framework you read above in this chapter. In the standalone library, you instantiate your database class manually, for example via `new SQLiteDatabase()`. However, in your Deepkit framework application, this is done automatically using the Dependency Injection container.": "请注意，那里的章节指的是独立的库`@deepkit/orm`，不包括你在本章上面读到的deepkit框架部分的文档。在独立库中，你要手动实例化你的数据库类，例如通过`new SQLiteDatabase()`。然而，在你的 Deepkit 框架应用程序中，这是用依赖性注入容器自动完成的。",
        "Logger": "记录仪",
        "Deepkit Logger is a standalone library with a primary Logger class that you can use to log information. This class is automatically deployed in the Dependency Injection container of your Deepkit Framework application.": "Deepkit Logger是一个独立的库，有一个主要的Logger类，你可以用它来记录信息。这个类会自动部署在Deepkit Framework应用程序的依赖注入容器中。",
        "The `Logger` class has several methods, each of which behaves like `console.log`.": "`Logger`类有几个方法，每个方法的行为都像`console.log`。",
        "By default, a logger has `info` level, i.e. it processes only info messages and more (i.e. log, warning, error, but not debug). To change the log level call for example `logger.level = 5`.": "默认情况下，一个日志记录器具有`info`级别，即它只处理信息消息和更多的信息（即日志、警告、错误，但不是调试）。要改变日志级别，可以调用例如`logger.level = 5`。",
        "Use in the application": "在应用中使用",
        "To use the logger in your Deepkit framework application, you can simply inject `Logger` into your services or controllers.": "要在你的Deepkit框架应用程序中使用记录器，你可以简单地将`Logger`注入你的服务或控制器中。",
        "Colors": "颜色",
        "The logger supports colored log messages. You can provide colors by using XML tags that surround the text you want to appear in color.": "记录器支持彩色的日志信息。你可以通过使用XML标签来提供颜色，这些标签围绕着你想用颜色显示的文本。",
        "For transporters that do not support colors, the color information is automatically removed. In the default transporter (`ConsoleTransport`) the color is displayed. The following colors are available: `black`, `red`, `green`, `blue`, `cyan`, `magenta`, `white` and `grey`/`gray`.": "对于不支持颜色的传输器，颜色信息被自动删除。在默认的传输器（`ConsoleTransport`）中，颜色被显示。有以下颜色可供选择：黑\"、\"红\"、\"绿\"、\"蓝\"、\"青\"、\"玛格丽特\"、\"白 \"和 \"灰\"。",
        "Transporter": "运输车",
        "You can configure a single transporter or multiple transporters. In a Deepkit Framework application, the `ConsoleTransport` transporter is configured automatically. To configure additional transporters, you can use xref:dependency-injection.adoc#di-setup-calls[Setup Calls]:": "你可以配置一个传输器或多个传输器。在 Deepkit Framework 应用程序中，`ConsoleTransport`传输器是自动配置的。要配置额外的传输器，您可以使用xref:dependency-injection.adoc#di-setup-calls[设置调用]：",
        "To replace all transporters with a new set of transporters, use `setTransport`:": "要用一组新的运输工具替换所有运输工具，请使用`setTransport`：",
        "Formatter": "形成器",
        "With formatters you can change the message format, e.g. add the timestamp. When an application is started via `server:start`, a `DefaultFormatter` is automatically added (which adds timestamp, range and log level) if no other formatter is available.": "通过格式化器，你可以改变消息的格式，例如，添加时间戳。当一个应用程序通过`server:start`启动时，如果没有其他格式，会自动添加`DefaultFormatter`（添加时间戳、范围和日志级别）。",
        "Scoped Logger": "范围内的记录器",
        "Scoped loggers add an arbitrary area name to each log entry, which can be helpful in determining which subarea of your application the log entry originated from.": "范围内的日志记录器为每个日志条目添加一个任意的区域名称，这有助于确定日志条目来自于应用程序的哪个子区域。",
        "JSON Transporter": "JSON传输器",
        "To change the output to JSON protocols, you can use the supplied `JSONTransport`.": "要改变输出为JSON协议，你可以使用提供的`JSONTransport`。",
        "Context Data": "背景数据",
        "To add contextual data to a log entry, add a simple object literal as the last argument. Only log calls with at least two arguments can contain contextual data.": "要将上下文数据添加到一个日志条目中，请添加一个简单的对象字面作为最后一个参数。只有至少有两个参数的日志调用才能包含上下文数据。",
        "Auto-CRUD": "自动CRUD",
        "Deepkit framework comes with various event tokens on which event listeners can be registered.": "Deepkit框架带有各种事件令牌，可以在上面注册事件监听器。",
        "See the xref:events.adoc[Events] chapter to learn more about how events work.": "参见xref:events.adoc[Events]章节，以了解更多关于事件如何工作的信息。",
        "Dispatch Events": "调度事件",
        "Events are sent via the `EventDispatcher` class. In a Deepkit Framework application, this can be provided via dependency injection.": "事件是通过`EventDispatcher`类发送的。在Deepkit框架的应用程序中，可以通过依赖性注入提供。",
        "Event Listener": "事件监听器",
        "There are two ways to react to events. Either via controller classes or regular functions.": "有两种方法对事件做出反应。要么通过控制器类，要么通过常规函数。",
        "Both are registered in the app or in modules under `listeners`.": "两者都在应用中或模块中的 \"听众 \"下注册。",
        "_Controller Listener_": "控制者监听器_",
        "_Functional Listener_": "_Functional Listener_",
        "Framework Events": "框架事件",
        "Deepkit Framework itself has several events from the application server that you can listen for.": "Deepkit Framework本身有几个来自应用服务器的事件，你可以监听。",
        "Deployment": "部署",
        "In this chapter, you will learn how to compile your application in JavaScript, configure it for your production environment, and deploy it using Docker.": "在本章中，你将学习如何用JavaScript编译你的应用程序，为你的生产环境配置它，并使用Docker部署它。",
        "Compile TypeScript": "编译TypeScript",
        "Suppose you have an application like this in an `app.ts` file:": "假设你在一个`app.ts`文件里有一个这样的应用程序：",
        "If you use `ts-node app.ts server:start`, you will see that everything works correctly. In a production environment, you would not typically start the server with `ts-node`. You would compile it into JavaScript and then use the node. To do this, you must have a correct `tsconfig.json` with the correct configuration options. In the \"First Application\" section, your `tsconfig.json` is configured to output JavaScript to the `.dist` folder. We assume that you have configured it that way as well.": "如果你使用`ts-node app.ts server:start`，你会看到一切工作正常。在一个生产环境中，你通常不会用`ts-node`来启动服务器。你会把它编译成JavaScript，然后使用该节点。要做到这一点，你必须有一个正确的`tsconfig.json`和正确的配置选项。在 \"第一个应用程序 \"部分，你的`tsconfig.json`被配置为输出JavaScript到`.dist`文件夹。我们假设你也是这样配置的。",
        "If all compiler settings are correct and your `outDir` points to a folder like `dist`, then as soon as you run the `tsc` command in your project, all your linked files in the files in the `tsconfig.json` will be compiled to JavaScript. It is enough to specify your entry files in this list. All imported files are also compiled automatically and do not need to be explicitly added to `tsconfig.json`. `tsc` is part of Typescript when you install `npm install typescript`.": "如果所有的编译器设置都是正确的，并且你的`outDir`指向`dist`这样的文件夹，那么只要你在项目中运行`tsc`命令，你在`tsconfig.json`中的所有链接文件都会被编译成JavaScript。在这个列表中指定你的输入文件就可以了。所有导入的文件也会被自动编译，不需要明确的加入到`tsconfig.json`中。`tsc`是Typescript的一部分，当你安装`npm install typescript`时。",
        "The TypeScript compiler does not output anything if it was successful. You can now check the output of `dist`.": "如果成功了，TypeScript编译器不会输出任何东西。现在你可以检查`dist`的输出。",
        "You can see that there is only one file. You can run it via `node distapp.js` and get the same functionality as with `ts-node app.ts`.": "你可以看到，只有一个文件。你可以通过`node distapp.js`运行它，得到与`ts-node app.ts`相同的功能。",
        "For a deployment, it is important that the TypeScript files are compiled correctly and everything works directly through Node. You could now simply move your `dist` folder including your `node_modules` and run `node distapp.js server:start` and your app is successfully deployed. However, you would use other solutions like Docker to package your app correctly.": "对于部署来说，重要的是TypeScript文件被正确编译，并且一切都可以直接通过Node工作。你现在可以简单地移动你的`dist`文件夹，包括你的`node_modules`，然后运行`node distapp.js server:start`，你的应用程序就成功部署了。然而，你会使用其他解决方案，如Docker来正确打包你的应用程序。",
        "In a production environment, you would not bind the server to `localhost`, but most likely to all devices via `0.0.0.0`. If you are not behind a reverse proxy, you would also set the port to 80. To configure these two settings, you need to customize the `FrameworkModule`. The two options we are interested in are `host` and `port`. In order for them to be configured externally via environment variables or via .dotenv files, we must first allow this. Fortunately, our code above has already done this with the `loadConfigFromEnv()` method.": "在生产环境中，你不会将服务器绑定到 \"localhost\"，而很可能是通过 \"0.0.0.0 \"绑定到所有设备。如果你不在一个反向代理后面，你也会把端口设置为80。为了配置这两个设置，你需要定制`FrameworkModule`。我们感兴趣的两个选项是`host`和`port`。为了使它们能够通过环境变量或.dotenv文件进行外部配置，我们必须首先允许这样做。幸运的是，我们上面的代码已经用`loadConfigFromEnv()`方法完成了这个工作。",
        "Please refer to the xref:framework.adoc#confiruration[Konfiguration] chapter to learn more about how to set the application configuration options.": "请参考xref:framework.adoc#confiruration[Konfiguration]章节，了解更多关于如何设置应用程序配置选项的信息。",
        "To see what configuration options are available and what value they have, you can use the `ts-node app.ts app:config` command. You can also see them in the Framework Debugger.": "要查看有哪些配置选项以及它们的值，你可以使用`ts-node app.ts app:config`命令。你也可以在框架调试器中看到它们。",
        "SSL": "SSL",
        "It is recommended (and sometimes required) to run your application over HTTPS with SSL. There are several options for configuring SSL. To enable SSL, use": "建议（有时需要）通过HTTPS和SSL运行你的应用程序。有几个选项可以配置SSL。要启用SSL，请使用",
        "`framework.ssl` and configure its parameters with the following options.": "`framework.ssl`，并用下列选项配置其参数。",
        "Local SSL": "本地SSL",
        "In the local development environment, you can enable self-signed HTTPs with the `framework.selfSigned` option.": "在本地开发环境中，你可以用`framework.selfSigned`选项来启用自签名的HTTPs。",
        "If you start this server now, your HTTP server is available as HTTPS at `https:localhost:8080`. In Chrome, you now get the error message \"NET::ERR_CERT_INVALID\" when you open this URL because self-signed certificates are considered a security risk: `chrome:flagsallow-insecure-localhost`.": "如果你现在启动这个服务器，你的HTTP服务器就可以作为HTTPS在`https:localhost:8080`上使用。在Chrome浏览器中，当你打开这个URL时，你现在会得到错误信息 \"NET::ERR_CERT_INVALID\"，因为自签的证书被认为有安全风险：`chrome:flagsallow-insecure-localhost`。",
        "Testing": "测试",
        "The services and controllers in the Deepkit framework are designed to support SOLID and clean code that is well-designed, encapsulated, and separated. These features make the code easy to test.": "Deepkit框架中的服务和控制器被设计为支持SOLID和干净的代码，这些代码被精心设计、封装和分离。这些特点使代码易于测试。",
        "This documentation shows you how to set up a testing framework named link:https://jestjs.io[Jest] with `ts-jest`. To do this, run the following command to install `jest` and `ts-jest`.": "本文档告诉你如何用`ts-jest`建立一个名为link:https://jestjs.io[Jest]的测试框架。要做到这一点，运行以下命令来安装`jest`和`ts-jest`。",
        "Jest needs a few configuration options to know where to find the test suits and how to compile the TS code. Add the following configuration to your `package.json`:": "Jest需要一些配置选项来知道在哪里找到测试套件，以及如何编译TS代码。在你的`package.json`中添加以下配置：",
        "Your test files should be named `.spec.ts`. Create a `test.spec.ts` file with the following content.": "你的测试文件应该被命名为`.spec.ts`。创建一个`test.spec.ts`文件，内容如下。",
        "You can now use the jest command to run all your test suits at once.": "现在你可以使用jest命令来一次运行所有的测试服。",
        "Please read the link:https://jestjs.io[Jest-Dokumentation] to learn more about how the Jest CLI tool works and how you can write more sophisticated tests and entire test suites.": "请阅读链接：https://jestjs.io[Jest-Dokumentation]，了解更多关于Jest CLI工具的工作原理，以及如何编写更复杂的测试和整个测试套件。",
        "Unit Test": "单位测试",
        "Whenever possible, you should unit test your services. The simpler, better separated, and better defined your service dependencies are, the easier it is to test them. In this case, you can write simple tests like the following:": "只要有可能，你应该对你的服务进行单元测试。你的服务依赖关系越简单，分离得越好，定义得越清楚，测试起来就越容易。在这种情况下，你可以写一些简单的测试，比如下面这些：",
        "Integration tests": "集成测试",
        "It's not always possible to write unit tests, nor is it always the most efficient way to cover business-critical code and behavior. Especially if your architecture is very complex, it is beneficial to be able to easily perform end-to-end integration tests.": "编写单元测试并不总是可能的，也不总是覆盖关键业务代码和行为的最有效方式。特别是当你的架构非常复杂时，能够轻松地进行端到端的集成测试是很有好处的。",
        "As you have already learned in the Dependency Injection chapter, the Dependency Injection Container is the heart of Deepkit. This is where all services are built and run. Your application defines services (providers), controllers, listeners, and imports. For integration testing, you don't necessarily want to have all services available in a test case, but you usually want to have a stripped down version of the application available to test the critical areas.": "正如你在依赖性注入一章中已经了解到的，依赖性注入容器是 Deepkit 的核心。这里是所有服务的构建和运行的地方。您的应用程序定义了服务（提供者）、控制器、监听器和导入。对于集成测试，你不一定要在测试案例中使用所有的服务，但你通常希望有一个精简的应用程序版本，以测试关键领域。",
        "If you have divided your application into several modules, you can test them more easily. For example, suppose you have created an `AppCoreModule` and want to test some services.": "如果你把你的应用程序分成几个模块，你可以更容易地测试它们。例如，假设你已经创建了一个 \"AppCoreModule\"，并想测试一些服务。",
        "You use your module as follows:": "你按以下方式使用你的模块：",
        "And test it without booting the entire application server.": "并在不启动整个应用服务器的情况下进行测试。",
        "TypeScript has become powerful enough to describe complex structures and even replace declaration formats like GraphQL, ProtoBuf, and JSON-Schema entirely. With a runtime type system, it's possible to cover the use cases of these tools without any code generators or runtime JavaScript type declaration libraries like \"Zod\". The Deepkit library aims to provide runtime type information and make it easier to develop efficient and compatible solutions.": "TypeScript 已经强大到足以描述复杂的结构，甚至可以完全取代 GraphQL、ProtoBuf 和 JSON-Schema 等声明格式。有了运行时类型系统，无需任何代码生成器或运行时 JavaScript 类型声明库（如 \"Zod\"），就可以覆盖这些工具的用例。Deepkit 库旨在提供运行时类型信息，使开发高效、兼容的解决方案变得更加容易。",
        "Deepkit is built upon the ability to read type information at runtime, using as much TypeScript type information as possible for efficiency. The runtime type system allows reading and computing dynamic types, such as class properties, function parameters, and return types. Deepkit hooks into TypeScript's compilation process to ensure that all type information is embedded into the generated JavaScript using a https://github.com/microsoft/TypeScript/issues/47658[custom bytecode and virtual machine], enabling developers to access type information programmatically.": "Deepkit 基于在运行时读取类型信息的能力，尽可能多地使用 TypeScript 类型信息以提高效率。运行时类型系统允许读取和计算动态类型，如类属性、函数参数和返回类型。Deepkit 与 TypeScript 的编译过程挂钩，确保使用 https://github.com/microsoft/TypeScript/issues/47658[自定义字节码和虚拟机]将所有类型信息嵌入到生成的 JavaScript 中，使开发人员能够以编程方式访问类型信息。",
        "To work directly with the type information itself, there are two basic variants: Type objects and Reflection classes. Type objects are regular JS objects returned by `typeOf<T>()`. Reflection classes are discussed below.": "要直接处理类型信息本身，有两种基本变体：类型对象和反射类。类型对象是由 `typeOf<T>()` 返回的常规 JS 对象。下面将讨论反射类。",
        "The function `typeOf` works for all types, including interfaces, object literals, classes, functions, and type aliases. It returns a type object that contains all the information about the type. You can pass any type as a type argument, including generics.": "函数 `typeOf` 适用于所有类型，包括接口、对象文字、类、函数和类型别名。它返回一个包含该类型所有信息的类型对象。你可以传递任何类型作为类型参数，包括泛型。",
        "The type object is a simple object literal that contains a `kind` property that indicates the type of the type object. The `kind` property is a number and gets its meaning from the enum `ReflectionKind`. `ReflectionKind` is defined in the `@deepkit/type` package as follows:": "类型对象是一个简单的对象字面形式，它包含一个 `kind` 属性，用于指示类型对象的类型。类型 \"属性是一个数字，其含义来自枚举 \"ReflectionKind\"。`ReflectionKind` 在 `@deepkit/type` 包中定义如下：",
        "Reflection Classes": "反思课",
        "Command-line Interface (CLI) programs are programs that interact via the terminal in the form of text input and text output. The advantage of interacting with the application in this variant is that only a terminal must exist either locally or via an SSH connection.": "命令行界面（CLI）程序是通过终端以文本输入和文本输出的形式进行交互的程序。以这种方式与应用程序交互的好处是，只需在本地或通过 SSH 连接存在一个终端。",
        "A CLI application in Deepkit has full access to the DI container and can thus access all providers and configuration options.": "Deepkit 中的 CLI 应用程序可以完全访问 DI 容器，因此可以访问所有提供程序和配置选项。",
        "The arguments and options of the CLI application are controlled by method parameters via TypeScript types and are automatically serialized and validated.": "CLI 应用程序的参数和选项由方法参数通过 TypeScript 类型控制，并自动序列化和验证。",
        "CLI is one of three entry points to a Deepkit Framework application. In the Deepkit framework, the application is always launched via a CLI program, which is itself written in TypeScript by the user. Therefore, there is no Deepkit specific global CLI tool to launch a Deepkit application. This is how you launch the HTTP/RPC server, perform migrations, or run your own commands. This is all done through the same entry point, the same file. Once the Deepkit framework is used by importing `FrameworkModule` from `@deepkit/framework`, the application gets additional commands for the application server, migrations, and more.": "CLI 是 Deepkit 框架应用程序的三个入口之一。在 Deepkit 框架中，应用程序总是通过 CLI 程序启动，而 CLI 程序本身是由用户使用 TypeScript 编写的。因此，没有 Deepkit 专用的全局 CLI 工具来启动 Deepkit 应用程序。这就是启动 HTTP/RPC 服务器、执行迁移或运行自己的命令的方式。所有这些都通过同一个入口点、同一个文件完成。从 `@deepkit/framework` 导入 `FrameworkModule` 后，一旦使用了 Deepkit 框架，应用程序就会获得应用服务器、迁移等其他命令。",
        "The CLI framework allows you to easily register your own commands and is based on simple classes. In fact, it is based on `@deepkit/app`, a small package intended only for this purpose, which can also be used standalone without the deepkit framework. In this package you can find decorators that are needed to decorate the CLI controller class.": "CLI 框架允许您轻松注册自己的命令，它基于简单的类。事实上，它基于 `@deepkit/app`，这是一个专门用于此目的的小软件包，也可独立使用，无需 deepkit 框架。在该包中，您可以找到装饰 CLI 控制器类所需的装饰器。",
        "Controllers are managed or instantiated by the Dependency Injection container and can therefore use other providers. See the xref:dependency-injection.adoc[Dependency Injection] chapter for more details.": "控制器由依赖注入容器管理或实例化，因此可以使用其他提供程序。详情请参阅 xref:dependency-injection.adoc[依赖注入]章节。",
        "Since CLI programs in Deepkit are based on Runtime Types, it is necessary to have @deepkit/type already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于 Deepkit 中的 CLI 程序基于运行时类型，因此必须正确安装 @deepkit/type。请参阅 xref:runtime-types.adoc#runtime-types-installation[运行时类型安装]。",
        "Note that @deepkit/app is partially based on TypeScript decorators and this feature should be enabled accordingly with `experimentalDecorators`.": "请注意，@deepkit/app 部分基于 TypeScript 装饰器，因此应使用 `experimentalDecorators` 相应地启用此功能。",
        "If you use functions as controllers only, you do not need TypeScript decorators.": "如果只将函数用作控制器，则不需要 TypeScript 装饰器。",
        "To create a command for your application, you need to create a CLI controller.": "要为应用程序创建命令，需要创建 CLI 控制器。",
        "This is a simple class that has an `execute` method and or a simple function.": "这是一个简单的类，有一个 `execute` 方法或一个简单的函数。",
        "Functional controller:": "功能控制器：",
        "Class controllers:": "班级控制器：",
        "This code is already a complete CLI application and can be started this way:": "这段代码已经是一个完整的 CLI 应用程序，可以通过这种方式启动：",
        "You can see that a \"test\" command is available. To execute this, the name must be passed as an argument:": "可以看到有一个 \"测试 \"命令。要执行该命令，必须将名称作为参数传递：",
        "It is also possible to make the file executable using `chmod +x app.ts`, so that the command `./app.ts` is already sufficient to start it. Note that then a so-called Shebang is necessary. Shebang denotes the character combination `#!` at the beginning of a script program. In the example above this is already present: `#!/usr/bin/env ts-node-script` and uses the script mode of `ts-node`.": "也可以使用 `chmod +x app.ts` 使文件可执行，这样命令 `./app.ts` 就足以启动它。请注意，这就需要所谓的 Shebang。Shebang 表示脚本程序开头的字符组合 `#!`。在上面的示例中已经存在：`#!/usr/bin/env ts-node-script` 并使用了 `ts-node` 的脚本模式。",
        "In this way, any number of commands can be created and registered. The unique name should be well-chosen and allows grouping of commands with the `:` character (e.g. `user:create`, `user:remove`, etc).": "这样就可以创建和注册任意数量的命令。唯一名称应精心选择，并允许使用\": \"字符对命令进行分组（例如，\"user:create\"、\"user:remove \"等）。",
        "Arguments": "论据",
        "Arguments are just parameters of the `execute` method or the function. They are automatically mapped to the command line arguments.": "参数只是 `execute` 方法或函数的参数。它们会自动映射为命令行参数。",
        "If you mark a parameter optional, it is not required to be passed. If you have a default value, it is also not required to be passed.": "如果将参数标记为可选参数，则不要求传递该参数。如果有默认值，也不需要传递。",
        "Depending on the type (string, number, union, etc) the passed value is automatically deserialized and validated.": "根据类型（字符串、数字、联合等）的不同，传递的值会自动进行反序列化和验证。",
        "If you execute this command now without specifying the name parameter, an error will be issued:": "如果您现在执行此命令，但未指定名称参数，系统将提示错误：",
        "By using `--help` you will get more information about the required arguments:": "通过使用 `--help`，你可以获得有关所需参数的更多信息：",
        "Once the name is passed as an argument, the command is executed and the name is passed correctly.": "一旦将名称作为参数传递，命令就会执行，名称也会正确传递。",
        "Flags are another way to pass values to your command. Mostly these are optional, but they don`t have to be. Parameters decorated withFlag type decorator can be passed via --name value or --name=value.": "标志是向命令传递值的另一种方式。大多数情况下，它们是可选的，但也并非必须如此。使用 Flag 类型装饰器装饰的参数可以通过 --name value 或 --name=value 传递。",
        "In the help view you can see in the \"OPTIONS\" that a `--id` flag is necessary. If you enter this flag correctly, the command will receive this value.": "在帮助视图的 \"OPTIONS（选项）\"中，你可以看到\"--id \"标志是必要的。如果输入正确，命令就会收到这个值。",
        "Flags have the advantage that they can also be used as a valueless flag, for example to activate a certain behavior. As soon as a parameter is marked as an optional Boolean, this behavior is activated.": "标志的优点是也可用作无值标志，例如用于激活某种行为。只要参数被标记为可选的布尔值，该行为就会被激活。",
        "To pass multiple values to the same flag, a flag can be marked as an array.": "要为同一个标志传递多个值，可以将标志标记为数组。",
        "To allow a flag to be passed as a single character as well, `Flag<{char: 'x'}>` can be used.": "为了让标记也能以单个字符的形式传递，可以使用 `Flag<{char: 'x'}>`。",
        "The signature of the method/function defines which arguments or flags are optional. If the parameter is optional in the type system, the user does not have to provide it.": "方法/函数的签名定义了哪些参数或标志是可选的。如果参数在类型系统中是可选的，用户就不必提供。",
        "The same for parameters with a default value:": "有默认值的参数也是如此：",
        "This also applies to flags in the same way.": "这同样适用于旗帜。",
        "All arguments and flags are automatically deserialized based on its types, validated and can be provided with additional constraints.": "所有参数和标志都会根据其类型自动反序列化，并经过验证，还可以提供额外的约束条件。",
        "Thus, arguments defined as numbers are always guaranteed to be real numbers in the controller, even though the command-line interface is based on text and thus strings. The conversion happens automatically with the feature xref:serialization.adoc#serialisation-loosely-convertion[].": "因此，尽管命令行界面基于文本和字符串，但在控制器中，定义为数字的参数始终保证是实数。转换是通过 xref:serialization.adoc#serialisation-loosely-convertion[] 功能自动完成的。",
        "Additional constraints can be defined with the type decorators from `@deepkit/type`.": "可使用 `@deepkit/type` 中的类型装饰器定义其他约束条件。",
        "The type `Postive` in `id` indicates that only positive numbers are wanted. If the user now passes a negative number, the code will not be executed at all and an error message will be presented.": "id` 中的 `Postive` 类型表示只需要正数。如果用户输入的是负数，代码将无法执行，并显示错误信息。",
        "If the number is positive, this works again as before. This additional validation, which is very easy to do, makes the command much more robust against wrong entries. See the chapter xref:validation.adoc[Validation] for more information.": "如果数字是正数，则与之前一样继续运行。这种额外的验证操作非常简单，能使命令更有效地防止错误输入。更多信息，请参阅 xref:validation.adoc[验证]一章。",
        "To describe a flag or argument, use `@description` comment decorator.": "要描述标志或参数，请使用 `@description` 注释装饰器。",
        "In the help view, this description appears after the flag or argument:": "在帮助视图中，该说明会出现在标志或参数之后：",
        "The exit code is 0 by default, which means that the command was executed successfully. To change the exit code, a number other than 0 should be returned in the exucute method.": "退出代码默认为 0，表示命令已成功执行。要更改退出代码，应在 exucute 方法中返回 0 以外的数字。",
        "The class and function of the command is managed by the DI Container, so dependencies can be defined that are resolved via the DI Container.": "命令的类和功能由 DI 容器管理，因此可以定义通过 DI 容器解决的依赖关系。",
        "First application": "首次申请",
        "Welcome to the Deepkit documentation. In this documentation you will find more information about the use of each library and the Deepkit framework in full detail with sample code.": "欢迎阅读 Deepkit 文档。在本文档中，您可以找到更多关于每个库和 Deepkit 框架使用的详细信息，并附有示例代码。",
        "Work in Progress": "进行中的工作",
        "This documentation is still in progress. Within the documentation there are still many placeholders that have not been written. We are constantly improving the documentation. If you need something urgently, please go to our Discord server.": "本文档仍在编写中。文档中仍有许多占位符尚未编写。我们将不断改进文档。如果您有急需，请访问我们的 Discord 服务器。",
        "API": "应用程序接口",
        "Use the API documentation to get very detailed information about the API of each module.": "使用 API 文档可获得每个模块的 API 的详细信息。",
        "link:https://api.framework.deepkit.io/[API Documentation, role=big]": "link:https://api.framework.deepkit.io/[API Documentation, role=big]",
        "Support": "支持",
        "If you need help, please join the Discord community server:": "如果您需要帮助，请加入 Discord 社区服务器：",
        "link:https://deepkit.io/community[Community, role=big]": "link:https://deepkit.io/community[Community, role=big]",
        "Since Dependency Injection in Deepkit is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于 Deepkit 中的依赖注入基于运行时类型，因此必须正确安装 `@deepkit/type`。请参阅 xref:runtime-types.adoc#runtime-types-installation[运行时类型安装]。",
        "Each property can add additional meta-data that can be read via the Reflection API. See xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] for more information.": "每个属性都可以添加可通过 Reflection API 读取的附加元数据。有关详细信息，请参阅 xref:runtime-types.adoc#runtime-types-reflection[运行时类型反射]。",
        "See xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] to learn more.": "请参阅 xref:runtime-types.adoc#runtime-types-reflection[运行时类型反射]了解更多信息。",
        "An event system allows application components within the same process to communicate by sending and listening to events. This aids in code modularization by facilitating message exchanges between functions that might not directly be aware of each other.": "事件系统允许同一进程中的应用程序组件通过发送和监听事件进行通信。这有助于代码模块化，因为它方便了可能无法直接感知彼此的功能之间的信息交换。",
        "The application or library provides an opportunity to execute additional functions at specific points during its operation. These additional functions register themselves as what are termed \"event listeners\".": "应用程序或程序库提供了在其运行过程中的特定时刻执行附加功能的机会。这些附加功能将自己注册为所谓的 \"事件监听器\"。",
        "An event can take various forms:": "活动可以有多种形式：",
        "The application starts up or shuts down.": "应用程序启动或关闭。",
        "A new user is created or deleted.": "创建或删除新用户。",
        "An error is thrown.": "会出现错误。",
        "A new HTTP request is received.": "收到新的 HTTP 请求。",
        "The Deepkit Framework and its associated libraries offer a range of events that users can listen to and respond to. However, users also have the flexibility to create as many custom events as needed, allowing for modular expansion of the application.": "Deepkit 框架及其相关库提供了一系列用户可以监听和响应的事件。不过，用户也可以根据需要灵活创建自定义事件，从而实现应用的模块化扩展。",
        "Below is an example of the low-level API from @deepkit/event. When using the Deepkit Framework, event listeners are not registered directly via the EventDispatcher, but rather through modules. But you can still use the low-level API if you want to.": "下面是 @deepkit/event 的底层 API 示例。使用 Deepkit 框架时，事件侦听器不是直接通过 EventDispatcher 注册的，而是通过模块注册的。但如果需要，您仍然可以使用底层 API。",
        "Since Deepkit's event system is based on runtime types, it's essential to have @deepkit/type installed correctly. For further details, refer to xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于 Deepkit 的事件系统基于运行时类型，因此必须正确安装 @deepkit/type。有关详细信息，请参阅 xref:runtime-types.adoc#runtime-types-installation[运行时类型安装]。",
        "Once this is successfully accomplished, you can install @deepkit/event or the entire Deepkit Framework, which already includes the library under the hood.": "安装成功后，您就可以安装 @deepkit/event 或整个 Deepkit 框架，其中已包含该库。",
        "It's important to note that @deepkit/event relies on TypeScript decorators for its class listeners. Therefore, when using a class, you'll need to enable the `experimentalDecorators` feature.": "需要注意的是，@deepkit/event 的类侦听器依赖于 TypeScript 装饰器。因此，在使用类时，您需要启用 `experimentalDecorators` 功能。",
        "As soon as the library is installed, the API can be used directly.": "一旦安装了该库，就可以直接使用 API。",
        "At the core of Deepkit's event system are Event Tokens. These are unique objects that specify both the event ID and the type of event. An event token serves two primary purposes:": "Deepkit 事件系统的核心是事件令牌。它们是指定事件 ID 和事件类型的唯一对象。事件令牌有两个主要用途：",
        "It acts as a trigger for an event.": "它是事件的触发器。",
        "It listens to the event it triggers.": "它会监听自己触发的事件。",
        "When an event gets triggered from an event token, the owner of that token is conceptually the entity that initiated the event. The event token decides the data available at the event and whether asynchronous event listeners are allowed.": "事件令牌触发事件时，该令牌的所有者在概念上就是发起事件的实体。事件标记决定事件中可用的数据，以及是否允许异步事件监听器。",
        "Creating Custom Event Data:": "创建自定义事件数据",
        "Using `DataEventToken` from @deepkit/event:": "使用 @deepkit/event 中的 \"DataEventToken\"：",
        "Extending BaseEvent:": "扩展 BaseEvent：",
        "Functional Listeners": "功能监听器",
        "Functional listeners allow users to register a simple function callback with the dispatcher directly. Here's how:": "功能监听器允许用户直接向调度程序注册一个简单的函数回调。具体方法如下",
        "If you wish to introduce additional arguments like `logger: Logger`, they are automatically injected by the dependency injection system, thanks to Deepkit's runtime type reflection.": "如果您希望引入额外的参数，如 `logger：由于 Deepkit 的运行时类型反射，依赖注入系统会自动注入这些参数。",
        "Note that the first argument has to be the event itself. You can not avoid this argument.": "请注意，第一个参数必须是事件本身。您不能回避这个参数。",
        "If you use `@deepkit/app`, you can also use app.listen() to register a functional listener.": "如果使用 `@deepkit/app`，还可以使用 app.listen() 注册功能监听器。",
        "Class-based Listeners": "基于类别的监听器",
        "Class listeners are classes adorned with decorators. They offer a structured way to listen to events.": "类监听器是带有装饰器的类。它们提供了一种结构化的事件监听方式。",
        "For class listeners, dependency injection works through either the method arguments or the constructor.": "对于类监听器，依赖注入是通过方法参数或构造函数来实现的。",
        "Deepkit's event system boasts a powerful dependency injection mechanism. When using functional listeners, additional arguments get automatically injected thanks to the runtime type reflection system. Similarly, class-based listeners support dependency injection through either the constructor or method arguments.": "Deepkit 的事件系统拥有强大的依赖注入机制。使用函数式监听器时，运行时类型反射系统会自动注入附加参数。同样，基于类的监听器也支持通过构造函数或方法参数进行依赖注入。",
        "For example, in the case of a functional listener, if you add an argument like `logger: Logger`, the correct Logger instance gets automatically provided when the function gets called.": "例如，在函数监听器的情况下，如果添加一个参数，如 `logger：Logger` 这样的参数，函数调用时就会自动提供正确的 Logger 实例。",
        "Event Propagation": "事件传播",
        "Every event object comes equipped with a stop() function, allowing you to control the propagation of the event. If an event is halted, no subsequent listeners (in the order they were added) will be executed. This provides granular control over the execution and handling of events, especially useful in scenarios where certain conditions may require the halting of event processing.": "每个事件对象都配有一个 stop() 函数，可以控制事件的传播。如果一个事件被停止，后续的监听器（按照添加的顺序）将不会被执行。这提供了对事件执行和处理的细粒度控制，在某些情况下可能需要停止事件处理时尤其有用。",
        "For instance:": "例如",
        "With the Deepkit framework's event system, developers can create modular, scalable, and maintainable applications with ease. Understanding the event system provides the flexibility to tailor the application's behavior based on specific occurrences or conditions.": "借助 Deepkit 框架的事件系统，开发人员可以轻松创建模块化、可扩展和可维护的应用程序。通过了解事件系统，可以根据特定事件或条件灵活调整应用程序的行为。"
    },
    "english": {}
}
